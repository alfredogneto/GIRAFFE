#include "RigidNURBSSurface_RigidNURBSSurface.h"
#include"Database.h"
//#include "sms.h"

//Variáveis globais
extern
Database db;

////////////////////////////////////////////////////////////////////
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#ifdef _DEBUG
#define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
// Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
// allocations to be of _CLIENT_BLOCK type
#else
#define DBG_NEW new
#endif
////////////////////////////////////////////////////////////////////

RigidNURBSSurface_RigidNURBSSurface::RigidNURBSSurface_RigidNURBSSurface()
{

	//Marina
	cNR1 = new Matrix*[/*n_pointwise*/1];
	cNR2 = new Matrix*[/*n_pointwise*/1];
	patches1 = new Matrix*[/*n_pointwise*/1];
	patches2 = new Matrix*[/*n_pointwise*/1];
	invertnormalA = new bool(false);
	invertnormalB = new bool(false);

	for (int i = 0; i < /*n_pointwise*/1; i++)
	{
		patches1[i] = new Matrix(2);
		patches2[i] = new Matrix(2);
		cNR1[i] = new Matrix(4);
		cNR2[i] = new Matrix(4);
	}

	derivative_order = 3;
	dataA = new Matrix*[derivative_order + 1];
	for (int i = 0; i < derivative_order + 1; i++)
	{
		dataA[i] = new Matrix[derivative_order + 1];
		for (int j = 0; j < derivative_order + 1; j++)
			dataA[i][j] = Matrix(3);
	}
	dataB = new Matrix*[derivative_order + 1];
	for (int i = 0; i < derivative_order + 1; i++)
	{
		dataB[i] = new Matrix[derivative_order + 1];
		for (int j = 0; j < derivative_order + 1; j++)
			dataB[i][j] = Matrix(3);
	}

	index1 = 0;				//index 1
	index2 = 0;				//index 2
	sub_index1 = 0;			//sub index 1
	sub_index2 = 0;			//sub index 2
	active = false;			//default: unnactive

	deg_pointA = 0;	//ID of the point in surface 1 to be considered in the degeneration (zero if no degeneration)
	deg_curveA = 0; //ID of the curve in surface 1 to be considered in the degeneration (zero if no degeneration)
	deg_pointB = 0; //ID of the point in surface 2 to be considered in the degeneration (zero if no degeneration)
	deg_curveB = 0; //ID of the curve in surface 2 to be considered in the degeneration (zero if no degeneration)

	//faceAID = 0;	//ID of face A
	//faceBID = 0;	//ID of face B
	CAD_AID = 0;	//ID of CAD A
	CAD_BID = 0;	//ID of CAD B
	node_A = 0;		//ID of nó A
	node_B = 0;		//ID of nó B
	material_A = 0;	//ID of material A (for interface law atribution)
	material_B = 0;	//ID of material B (for interface law atribution)

	cd = NULL;
	Rc = NULL;
	Kc = NULL;

	//vertexIDsA[0] = 0;
	//vertexIDsA[1] = 0;
	//vertexIDsA[2] = 0;
	//vertexIDsB[0] = 0;
	//vertexIDsB[1] = 0;
	//vertexIDsB[2] = 0;

	surfA = NULL;
	surfB = NULL;
	//faceA = NULL;
	//faceB = NULL;

	alloc_specific_control = false;
	//alloc_specific_explicit_control = false;

	GammaA = DBG_NEW Matrix(3);
	GammaB = DBG_NEW Matrix(3);

	eligible = false;
	prev_eligible = false;

	previous_evaluation = false;

	extra_leng = 0.0;
	//meq = new double;

	//Wnum = new double;
	//Wteo = new double;
	impactcontrol = new bool; //PODE IGNORAR
	//*Wnum = 0.0;
	//*Wteo = 0.0;
	*impactcontrol = false;

	//Marina
	int patchA = 0;
	int subA_u = 0;
	int subA_v = 0;
	int patchB = 0;
	int subB_u = 0;
	int subB_v = 0;

	cAp = DBG_NEW double[2];
	cBp = DBG_NEW double[2];
	cAi = DBG_NEW double[2];
	cBi = DBG_NEW double[2];
	xAi = DBG_NEW double[3];
	xBi = DBG_NEW double[3];
	uA = DBG_NEW double[3];
	uB = DBG_NEW double[3];
	alphaA = DBG_NEW double[3];
	alphaB = DBG_NEW double[3];
	duiA = DBG_NEW double[3];
	duiB = DBG_NEW double[3];
	dalphaiA = DBG_NEW double[3];
	dalphaiB = DBG_NEW double[3];
	dduiA = DBG_NEW double[3];
	dduiB = DBG_NEW double[3];
	ddalphaiA = DBG_NEW double[3];
	ddalphaiB = DBG_NEW double[3];

	fn = DBG_NEW double[3];
	ft = DBG_NEW double[3];
	vnrel = new double;

	QAi = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		QAi[i] = DBG_NEW double[3];
	QBi = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		QBi[i] = DBG_NEW double[3];

	Q0A = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		Q0A[i] = DBG_NEW double[3];
	Q0B = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		Q0B[i] = DBG_NEW double[3];

	Rc = DBG_NEW double[12];
	Kc = DBG_NEW double*[12];
	for (int i = 0; i < 12; i++)
		Kc[i] = DBG_NEW double[12];
	for (int ni = 0; ni < 12; ni++)
		for (int nj = 0; nj < 12; nj++)
			Kc[ni][nj] = 0.0;

	GAp = DBG_NEW double[3];
	dGAp = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		dGAp[i] = DBG_NEW double[2];
	ddGAp = DBG_NEW double**[3];
	for (int i = 0; i < 3; i++)
		ddGAp[i] = DBG_NEW double*[2];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 2; j++)
			ddGAp[i][j] = DBG_NEW double[2];
	dddGAp = DBG_NEW double***[3];
	for (int i = 0; i < 3; i++)
		dddGAp[i] = DBG_NEW double**[2];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 2; j++)
			dddGAp[i][j] = DBG_NEW double*[2];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 2; j++)
			for (int k = 0; k < 2; k++)
				dddGAp[i][j][k] = DBG_NEW double[2];

	GBp = DBG_NEW double[3];
	dGBp = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		dGBp[i] = DBG_NEW double[2];
	ddGBp = DBG_NEW double**[3];
	for (int i = 0; i < 3; i++)
		ddGBp[i] = DBG_NEW double*[2];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 2; j++)
			ddGBp[i][j] = DBG_NEW double[2];
	dddGBp = DBG_NEW double***[3];
	for (int i = 0; i < 3; i++)
		dddGBp[i] = DBG_NEW double**[2];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 2; j++)
			dddGBp[i][j] = DBG_NEW double*[2];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 2; j++)
			for (int k = 0; k < 2; k++)
				dddGBp[i][j][k] = DBG_NEW double[2];

	GAi = DBG_NEW double[3];
	dGAi = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		dGAi[i] = DBG_NEW double[2];

	GBi = DBG_NEW double[3];
	dGBi = DBG_NEW double*[3];
	for (int i = 0; i < 3; i++)
		dGBi[i] = DBG_NEW double[2];
	
	DefaultValues();

	alloc_specific_control = true;
	//alloc_specific_explicit_control = true;
}


RigidNURBSSurface_RigidNURBSSurface::~RigidNURBSSurface_RigidNURBSSurface()
{
	SetUnnactive();
	delete GammaA;
	delete GammaB;

	//delete meq;
	//delete Wnum;
	//delete Wteo;
	delete impactcontrol;

	//Limpeza de memória
	for (int i = 0; i < /*n_pointwise*/1; i++)
	{
		delete patches1[i];
		delete patches2[i];
		delete cNR1[i];
		delete cNR2[i];
	}
	delete[]patches1;
	delete[]patches2;
	delete[]cNR1;
	delete[]cNR2;

	for (int i = 0; i < derivative_order + 1; i++)
		delete[] dataA[i];
	delete[]dataA;
	for (int i = 0; i < derivative_order + 1; i++)
		delete[] dataB[i];
	delete[]dataB;

	delete[] cAp;
	delete[] cBp;
	delete[] cAi;
	delete[] cBi;
	delete[] xAi;
	delete[] xBi;
	delete[] uA;
	delete[] uB;
	delete[] alphaA;
	delete[] alphaB;
	delete[] duiA;
	delete[] duiB;
	delete[] dalphaiA;
	delete[] dalphaiB;
	delete[] dduiA;
	delete[] dduiB;
	delete[] ddalphaiA;
	delete[] ddalphaiB;

	delete[] fn;
	delete[] ft;
	delete vnrel;

	for (int i = 0; i < 3; i++)
		delete[] QAi[i];
	delete[]QAi;
	for (int i = 0; i < 3; i++)
		delete[] QBi[i];
	delete[]QBi;

	delete[] Rc;
	for (int i = 0; i < 12; i++)
		delete[]Kc[i];
	delete[]Kc;

	delete[] GAp;

	for (int i = 0; i < 3; i++)
		delete[] dGAp[i];
	delete[]dGAp;

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 2; j++)
			delete[] ddGAp[i][j];
		delete[] ddGAp[i];
	}
	delete[]ddGAp;

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
				delete[] dddGAp[i][j][k];
			delete[] dddGAp[i][j];
		}
		delete[] dddGAp[i];
	}
	delete[]dddGAp;

	delete[] GBp;

	for (int i = 0; i < 3; i++)
		delete[] dGBp[i];
	delete[]dGBp;

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 2; j++)
			delete[] ddGBp[i][j];
		delete[] ddGBp[i];
	}
	delete[]ddGBp;

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
				delete[] dddGBp[i][j][k];
			delete[] dddGBp[i][j];
		}
		delete[] dddGBp[i];
	}
	delete[]dddGBp;

	delete[] GAi;

	for (int i = 0; i < 3; i++)
		delete[] dGAi[i];
	delete[]dGAi;

	delete[] GBi;

	for (int i = 0; i < 3; i++)
		delete[] dGBi[i];
	delete[]dGBi;

	for (int i = 0; i < 3; i++)
		delete[] Q0A[i];
	delete[]Q0A;
	for (int i = 0; i < 3; i++)
		delete[] Q0B[i];
	delete[]Q0B;
}

void RigidNURBSSurface_RigidNURBSSurface::EvaluateNormalGap()
{
	//Cálculo da função gap (escalar)
	SurfacePoints();
	//Gap vetorial
	*cd->g[0] = *GammaA - *GammaB;
	//Normal do contato
	if (norm(*cd->g[0]) != 0.0)
		*cd->n[0] = (1.0 / norm(*cd->g[0]))*(*cd->g[0]);
	else
		zeros(cd->n[0]);

	
	if(eligible == true)
		cd->g_n[0] = -1.0*norm(*cd->g[0]);
	else
		cd->g_n[0] = 1.0*norm(*cd->g[0]);
	
	Matrix cur_nA(3);
	Matrix cur_nB(3);
	
	if ((*patches2[0])(0, 0) == sub_index1 && (*patches2[0])(1, 0) == sub_index2) {
		cd->other_patch[0] = false;
	}
	else {
		surfA->patches[(*patches2[0])(0, 0)]->NormalExt(ptrQAp, &(*cNR2[/*i*/0])(0, 0), &(*cNR2[/*i*/0])(1, 0), &cur_nA);
		surfB->patches[(*patches2[0])(1, 0)]->NormalExt(ptrQBp, &(*cNR2[/*i*/0])(2, 0), &(*cNR2[/*i*/0])(3, 0), &cur_nB);
		if ((*pair_control->contact_detectionA)) {
			if (dot(*cd->g[0], cur_nB) < 0) {
				cd->other_patch[0] = true;
			}
			else {
				cd->other_patch[0] = false;
			}
		}
		else {
			if (dot(*cd->g[0], cur_nA) > 0) {
				cd->other_patch[0] = true;
			}
			else {
				cd->other_patch[0] = false;
			}
		}
	}

	//if (index1 == 48 && index2 == 131 /*&& sub_index1 == 5 && sub_index2 == 2*/ && (db.last_converged_time + db.current_time_step) > 1.035) {
		//db.myprintf("gap = %f\n", cd->g_n[0]);
	//}

	//if ((cd->g_n[0] <= *gnb && cd->return_value[0] == 0) /*|| (cd->copy_g_n[0] <= *gnb && cd->copy_return_value[0] == 0)*/)
		//eligible = true;

	// SE HOUVER ALGUM PROBLEMA, OLHAR CÓDIGO ANTIGO
}

void RigidNURBSSurface_RigidNURBSSurface::EvaluateNormalGapEligibleOrNot()
{

	//Cálculo da função gap (escalar)
	SurfacePointsTemp();
	//Gap vetorial
	*cd->g[0] = *GammaA - *GammaB;
	//Normal do contato
	if (norm(*cd->g[0]) != 0.0)
		*cd->n[0] = (1.0 / norm(*cd->g[0]))*(*cd->g[0]);
	else
		zeros(cd->n[0]);

	Matrix cur_nA(3);
	Matrix cur_nB(3);
	surfA->patches[(*patches2[0])(0, 0)]->NormalExt(ptrQAp, &(*cNR2[/*i*/0])(0, 0), &(*cNR2[/*i*/0])(1, 0), &cur_nA);
	surfB->patches[(*patches2[0])(1, 0)]->NormalExt(ptrQBp, &(*cNR2[/*i*/0])(2, 0), &(*cNR2[/*i*/0])(3, 0), &cur_nB);
	
	/*if (dot(*cd->g[0], cur_nA) > 0) {
		eligible = true;
	}
	else {
		eligible = false;
	}*/

	if ((*pair_control->contact_detectionA)) {
		if (dot(*cd->g[0], cur_nB) < 0) {
			eligible = true;
		}
		else {
			eligible = false;
		}
	}
	else if ((*pair_control->contact_detectionAB)) {
		bool gap_neg = false;
		for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
		{
			if (db.gcs->contactPP_list[index1][i]->index2 == index2) {
				if (db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_g_n[0] < 0) {
					gap_neg = true;
				}
			}
		}
		if (dot(*cd->n[0], *cd->copy_n[0]) >= 0) {
			if (gap_neg) {
				eligible = true;
			}
			else {
				eligible = false;
			}
		}
		else
		{
			if (gap_neg) {
				eligible = false;
			}
			else {
				eligible = true;
			}
		}
	}
	else {
		if (dot(*cd->g[0], cur_nA) > 0) {
			eligible = true;
		}
		else {
			eligible = false;
		}
	}

	//if (index1 == 48 && index2 == 131 /*&& sub_index1 == 5 && sub_index2 == 2*/ && (db.last_converged_time + db.current_time_step) > 1.03872) {
		//db.myprintf("sub_index1 = %d\n", sub_index1);
		//db.myprintf("sub_index2 = %d\n", sub_index2);
		//db.myprintf("eligible = %d\n", eligible);
	//}
}

bool RigidNURBSSurface_RigidNURBSSurface::HaveErrors()
{
	/*if (write_report)
	{
		for (int i = 0; i < c_data->n_solutions; i++)
		{
			OpenTRReport(i);
			fprintf(f_TR_report[i], "///////////////////////////////////////////////////////////////////////\n");
			fprintf(f_TR_report[i], "\nTime\t%.6f\tIteration\t%d\t", db.last_converged_time + db.current_time_step, db.current_iteration_number);
			fprintf(f_TR_report[i], "EndStepCheck\n");
		}
	}*/

	//Retorno com problemas: true
	//Retorno sem problemas: false

	//Teste para avaliar solucoes nao convergidas
	//Varredura das soluções ativas
	//for (int i = 0; i < c_data->n_solutions; i++)
	//{
		//Se não for solução repetida (ou seja, se for solução ativa)
		if (cd->repeated[/*i*/0] == false)
		{
			//Se algum dos pares ativos apresentou divergência do método de otimização
			if (cd->return_value[/*i*/0] == 1)
			{
				db.myprintf("LCP between surfaces %d , %d and %d , %d has presented problems. Code 1.\n", index1, sub_index1, index2, sub_index2);
				/*if (write_report)
				{
					fprintf(f_TR_report[i], "LCP between surfaces %d and %d has presented problems. Code 1.\n", surf1_ID, surf2_ID);
					for (int ip = 0; ip < c_data->n_solutions; ip++)
						fclose(f_TR_report[ip]);
				}*/
				return true;

			}
			//Se houve muita mudança de range das coordenadas convectivas é indicativo de perda da solução desejada para c_bar
			if (cd->return_value[/*i*/0] == 3)
			{
				db.myprintf("LCP between surfaces %d and %d has presented problems. Code 3.\n", index1, index2);
				/*if (write_report)
				{
					fprintf(f_TR_report[i], "LCP between surfaces %d and %d has presented problems. Code 3.\n", surf1_ID, surf2_ID);
					for (int ip = 0; ip < c_data->n_solutions; ip++)
						fclose(f_TR_report[ip]);
				}*/
				return true;
			}
		}
	//}


	/*if (write_report)
	{
		for (int ip = 0; ip < c_data->n_solutions; ip++)
			fclose(f_TR_report[ip]);
	}*/

	return false;
}

void RigidNURBSSurface_RigidNURBSSurface::SolveLCP()
{

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Degeneração: 
	// Inicialmente o LCP é resolvido sem degeneração
	// Caso alguma região problemática seja detectada, procede-se com a degeneração do contato entre partículas NURBS
	// n_solutions = 1

	cd->degenerated[0] = false;

	cd->deg_control[0][0] = false;
	cd->deg_control[0][1] = false;
	cd->deg_control[0][2] = false;
	cd->deg_control[0][3] = false;

	cd->copy_deg_coordinates[0][0] = (*cNR2[0])(0, 0);
	cd->copy_deg_coordinates[0][1] = (*cNR2[0])(1, 0);
	cd->copy_deg_coordinates[0][2] = (*cNR2[0])(2, 0);
	cd->copy_deg_coordinates[0][3] = (*cNR2[0])(3, 0);

	// Degeneration basis - canonical basis
	(*cd->P[0])(0, 0) = 1.0;
	(*cd->P[0])(1, 1) = 1.0;
	(*cd->P[0])(2, 2) = 1.0;
	(*cd->P[0])(3, 3) = 1.0;

	// Degenerative operator
	cd->MountDegenerativeOperator();
	/*-----------------------------------------------------------------------------------------------------------------*/


	//Valores salvos pela função (indicativos do que ocorreu em sua execução)
	//0 - Convergiu e está no range de interesse para contato e não houve grande mudança de posição do ponto material de contato, no caso de haver contato anterior - OK
	//1 - Não houve convergência (pode ou não estar no range para contato) - e é strong_candidate. Retorno problemático responsável por veto de passo da simulação.
	//2 - Não é strong_candidate - OK
	//3 - mudança abrupta na posição de contato. Retorno problemático responsável por veto de passo da simulação.
	//4 - Houve convergência, mas não está no range para contato. Possivelmente elemento vizinho. - OK

	int contact = 0;
	int number_patchesA = 0;
	int number_patchesB = 0;
	int patch_temp = 0;

	// Ponteiro para o par de partículas
	for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
	{
		if (db.gcs->contactPP_list[index1][i]->index2 == index2 && db.gcs->contactPP_list[index1][i]->sub_index1 == sub_index1 && db.gcs->contactPP_list[index1][i]->sub_index2 == sub_index2) {
			pair_control = static_cast<ContactNURBSParticleNURBSParticle*>(db.gcs->contactPP_list[index1][i]);
			contact = i;
			break;
		}
	}

	bool aut_exit = false;
	eligible = false;
	int cases = 0;

	double tol = 0.0;
	double err = 0.0;
	bool conv = true;

	// Ponto no sistema local
	double f[3];
	f[0] = 0.0;
	f[1] = 0.0;
	f[2] = 0.0;

	// Ponto no sistema global
	double *fg;
	fg = new double[3];
	fg[0] = 0.0;
	fg[1] = 0.0;
	fg[2] = 0.0;

	// Ponto da projeção
	double *point;
	point = new double[3];
	point[0] = 0.0;
	point[1] = 0.0;
	point[2] = 0.0;
			
	// Ponto na superfície NURBS
	Matrix p(3);
	p(0, 0) = 0.0;
	p(1, 0) = 0.0;
	p(2, 0) = 0.0;

	if (index1 == 0 && index2 == 1 &&/* sub_index1 == 5 && sub_index2 == 2 &&*/ (db.last_converged_time + db.current_time_step) > 1.3032) {
		cout << "stop" << endl;
	}

	bool contact_aux = false;

	// Verificar se contato entre partículas já foi detectado sem degeneração
	for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
	{
		if (db.gcs->contactPP_list[index1][i]->index2 == index2 && (db.gcs->contactPP_list[index1][i]->sub_index1 != sub_index1 || db.gcs->contactPP_list[index1][i]->sub_index2 != sub_index2) && *db.gcs->contactPP_list[index1][i]->contact_detection) {
			contact_aux = true;
			cd->convective[/*i*/0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][0];
			cd->convective[/*i*/0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][1];
			cd->convective[/*i*/0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][2];
			cd->convective[/*i*/0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][3];
			cd->patchA[/*i*/0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchA[/*i*/0];
			cd->patchB[/*i*/0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchB[/*i*/0];

			cd->degenerated[0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->degenerated[0];

			cd->deg_control[0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][0];
			cd->deg_control[0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][1];
			cd->deg_control[0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][2];
			cd->deg_control[0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][3];

			cd->copy_deg_coordinates[0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][0];
			cd->copy_deg_coordinates[0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][1];
			cd->copy_deg_coordinates[0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][2];
			cd->copy_deg_coordinates[0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][3];

			//Degeneration basis - canonical basis
			(*cd->P[0])(0, 0) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(0, 0);
			(*cd->P[0])(1, 1) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(1, 1);
			(*cd->P[0])(2, 2) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(2, 2);
			(*cd->P[0])(3, 3) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(3, 3);

			//Degenerative operator
			cd->MountDegenerativeOperator();

			break;
		}
	}

	if (contact_aux) {
		aut_exit = true;
		eligible = false;
		cd->return_value[/*i*/0] = 4;
		cd->other_patch[0] = true;
	}
	else {
		seq_number = /*i*/0;//para controle do report
		//Se não for solução repetida (ou seja, se for ativa)
		if (cd->repeated[/*i*/0] == false)
		{
			//CASO 1 - não é strong candidate - retorno imediato:
			if (cd->copy_return_value[/*ip*/0] == 2 || cd->return_value[/*ip*/0] == 2) // Acontece se for primeira iteração?
			{
				//if (write_report)
					//fprintf(f_TR_report[i], "Candidate is not Strong\n");

				InitialGuess(cd); //Realiza chute inicial com critério geométrico -> escreve em 'convective'
				for (int ii = 0; ii < 4; ii++)
					(*cNR1[/*i*/0])(ii, 0) = cd->convective[/*i*/0][ii];
				(*patches1[/*i*/0])(0, 0) = cd->patchA[/*i*/0];
				(*patches1[/*i*/0])(1, 0) = cd->patchB[/*i*/0];
			}
			//CASO 2: não houve convergência ou houve convergência para uma solução longe da desejada
			//Toma como chute inicial a última solução correta conhecida (cópia do passo convergido anterior da phase 2)
			if (cd->return_value[/*i*/0] == 1 || cd->return_value[/*i*/0] == 3)
			{
				(*cNR1[/*i*/0])(0, 0) = cd->copy_convective[/*i*/0][0];
				(*cNR1[/*i*/0])(1, 0) = cd->copy_convective[/*i*/0][1];
				(*cNR1[/*i*/0])(2, 0) = cd->copy_convective[/*i*/0][2];
				(*cNR1[/*i*/0])(3, 0) = cd->copy_convective[/*i*/0][3];
				(*patches1[/*i*/0])(0, 0) = cd->copy_patchA[/*i*/0];
				(*patches1[/*i*/0])(1, 0) = cd->copy_patchB[/*i*/0];
				//Se antes não era strong candidate, o copy_convective não traz info válida. Assim, calcula o chute inicial (geométrico) novamente
				if (cd->copy_return_value[/*i*/0] == 2)
				{
					InitialGuess(cd); //Realiza chute inicial com critério geométrico -> escreve em 'convective'
					for (int ii = 0; ii < 4; ii++)
						(*cNR1[/*i*/0])(ii, 0) = cd->convective[/*i*/0][ii];
					(*patches1[/*i*/0])(0, 0) = cd->patchA[/*i*/0];
					(*patches1[/*i*/0])(1, 0) = cd->patchB[/*i*/0];
				}
			}
			//CASO 3: houve convergência
			//Toma como chute inicial a última solução convergida
			if (cd->return_value[/*i*/0] == 0 || cd->return_value[/*i*/0] == 4)
			{
				(*cNR1[/*i*/0])(0, 0) = cd->convective[/*i*/0][0];
				(*cNR1[/*i*/0])(1, 0) = cd->convective[/*i*/0][1];
				(*cNR1[/*i*/0])(2, 0) = cd->convective[/*i*/0][2];
				(*cNR1[/*i*/0])(3, 0) = cd->convective[/*i*/0][3];
				//*cNR2[i] = *cNR1[i];
				(*patches1[/*i*/0])(0, 0) = cd->patchA[/*i*/0];
				(*patches1[/*i*/0])(1, 0) = cd->patchB[/*i*/0];
			}

			bool converged1 = false;
			bool converged2 = false;
			bool converged3 = false;
			int info = 0;

			/*-----------------------------------------------------------------------------------------------------------------*/
			// Verificar se alguma superfície é um plano
			// Superfície A
			int dA = 2;
			Matrix** dataA;
			dataA = new Matrix*[dA + 1];
			for (int i = 0; i < dA + 1; i++)
			{
				dataA[i] = new Matrix[dA + 1];
				for (int j = 0; j < dA + 1; j++)
					dataA[i][j] = Matrix(3);
			}
			surfA->patches[(*patches1[/*i*/0])(0, 0)]->NURBSDerivatives((*cNR1[/*i*/0])(0, 0), (*cNR1[/*i*/0])(1, 0), dataA, dA);
			double der_zeta_zeta_A = sqrt(dataA[2][0](0, 0) * dataA[2][0](0, 0) + dataA[2][0](1, 0) * dataA[2][0](1, 0) + dataA[2][0](2, 0) * dataA[2][0](2, 0));
			double der_zeta_theta_A = sqrt(dataA[1][1](0, 0) * dataA[1][1](0, 0) + dataA[1][1](1, 0) * dataA[1][1](1, 0) + dataA[1][1](2, 0) * dataA[1][1](2, 0));
			double der_theta_theta_A = sqrt(dataA[0][2](0, 0) * dataA[0][2](0, 0) + dataA[0][2](1, 0) * dataA[0][2](1, 0) + dataA[0][2](2, 0) * dataA[0][2](2, 0));

			// Superfície B
			int dB = 2;
			Matrix** dataB;
			dataB = new Matrix*[dB + 1];
			for (int i = 0; i < dB + 1; i++)
			{
				dataB[i] = new Matrix[dB + 1];
				for (int j = 0; j < dB + 1; j++)
					dataB[i][j] = Matrix(3);
			}
			surfB->patches[(*patches1[/*i*/0])(1, 0)]->NURBSDerivatives((*cNR1[/*i*/0])(2, 0), (*cNR1[/*i*/0])(3, 0), dataB, dB);
			double der_zeta_zeta_B = sqrt(dataB[2][0](0, 0) * dataB[2][0](0, 0) + dataB[2][0](1, 0) * dataB[2][0](1, 0) + dataB[2][0](2, 0) * dataB[2][0](2, 0));
			double der_zeta_theta_B = sqrt(dataB[1][1](0, 0) * dataB[1][1](0, 0) + dataB[1][1](1, 0) * dataB[1][1](1, 0) + dataB[1][1](2, 0) * dataB[1][1](2, 0));
			double der_theta_theta_B = sqrt(dataB[0][2](0, 0) * dataB[0][2](0, 0) + dataB[0][2](1, 0) * dataB[0][2](1, 0) + dataB[0][2](2, 0) * dataB[0][2](2, 0));

			bool planeA = false;
			bool planeB = false;

			if (der_zeta_zeta_A < tol_small_1 /*&& der_zeta_theta_A < tol_small_1*/ && der_theta_theta_A < tol_small_1) {
				planeA = true;
			}

			if (der_zeta_zeta_B < tol_small_1 /*&& der_zeta_theta_B < tol_small_1*/ && der_theta_theta_B < tol_small_1) {
				planeB = true;
			}
			for (int i = 0; i < dA + 1; i++)
			{
				delete[]dataA[i];
			}
			delete[]dataA;
			for (int i = 0; i < dB + 1; i++)
			{
				delete[]dataB[i];
			}
			delete[]dataB;
			/*-----------------------------------------------------------------------------------------------------------------*/

			////////////////NO DEGENERATION///////////////
			//if (c_data->degenerated[i] == false)
			//{
				//Se o contato era previamente ativo ou vizinho
			if ((cd->return_value[/*i*/0] == 0 || cd->return_value[/*i*/0] == 4) && (cd->g_n[0] < 0.0 || cd->other_patch[0] == true))
			{
				//if (write_report)
					//fprintf(f_TR_report[i], "Direct search for saddle\n");
				//Tentativa de achar direto a sela
				*cNR2[/*i*/0] = *cNR1[/*i*/0];
				*patches2[/*i*/0] = *patches1[/*i*/0];
				converged2 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 2);
				if (converged2 && (CharacterizeCriticalPoint(cNR2[/*i*/0], *patches2[/*i*/0]) == 0)) // para verificar se não virou mínimo
				{
					eligible = false;
					(*pair_control->contact_detection) = true;
				}
				else {
					converged1 = true; // lidar com mínimo não convergido
					eligible = true;
					if (converged2) {
						(*pair_control->contact_detection) = true;
							
						cd->degenerated[0] = false;

						cd->deg_control[0][0] = false;
						cd->deg_control[0][1] = false;
						cd->deg_control[0][2] = false;
						cd->deg_control[0][3] = false;

						cd->copy_deg_coordinates[0][0] = (*cNR2[/*i*/0])(0, 0);
						cd->copy_deg_coordinates[0][1] = (*cNR2[/*i*/0])(1, 0);
						cd->copy_deg_coordinates[0][2] = (*cNR2[/*i*/0])(2, 0);
						cd->copy_deg_coordinates[0][3] = (*cNR2[/*i*/0])(3, 0);

						//Degeneration basis - canonical basis
						(*cd->P[0])(0, 0) = 1.0;
						(*cd->P[0])(1, 1) = 1.0;
						(*cd->P[0])(2, 2) = 1.0;
						(*cd->P[0])(3, 3) = 1.0;

						//Degenerative operator
						cd->MountDegenerativeOperator();

						if ((*patches2[0])(0, 0) != sub_index1 || (*patches2[0])(1, 0) != sub_index2) {
							for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
							{
								if (db.gcs->contactPP_list[index1][i]->index2 == index2 && db.gcs->contactPP_list[index1][i]->sub_index1 == (*patches2[0])(0, 0) && db.gcs->contactPP_list[index1][i]->sub_index2 == (*patches2[0])(1, 0) /*&& i < contact*/) {
									//db.gcs->contactPP_list[index1][i]->contact_pairs[0]->eligible = true;
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][0] = (*cNR2[/*i*/0])(0, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][1] = (*cNR2[/*i*/0])(1, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][2] = (*cNR2[/*i*/0])(2, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][3] = (*cNR2[/*i*/0])(3, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchA[/*i*/0] = (*patches2[/*i*/0])(0, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchB[/*i*/0] = (*patches2[/*i*/0])(1, 0);
									EvaluateNormalGap();
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(0, 0) = (*cd->g[0])(0, 0);
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(1, 0) = (*cd->g[0])(1, 0);
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(2, 0) = (*cd->g[0])(2, 0);
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(0, 0) = (*cd->n[0])(0, 0);
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(1, 0) = (*cd->n[0])(1, 0);
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(2, 0) = (*cd->n[0])(2, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g_n[0] = cd->g_n[0];
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->return_value[0] = 0;
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->other_patch[0] = false;

									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->degenerated[0] = false;

									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][0] = false;
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][1] = false;
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][2] = false;
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][3] = false;

									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][0] = (*cNR2[/*i*/0])(0, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][1] = (*cNR2[/*i*/0])(1, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][2] = (*cNR2[/*i*/0])(2, 0);
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][3] = (*cNR2[/*i*/0])(3, 0);

									//Degeneration basis - canonical basis
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(0, 0) = 1.0;
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(1, 1) = 1.0;
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(2, 2) = 1.0;
									(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(3, 3) = 1.0;

									//Degenerative operator
									db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->MountDegenerativeOperator();

								}
							}
						}
					}
				}
			}
			//Se não entrou no if anterior ou se não convergiu o if anterior
			if (converged2 == false)
			{
				//if (write_report)
					//fprintf(f_TR_report[i], "Search for minimum\n");
				//Determinação de mínimo ou intersecção
				//InitialGuess(cd); //Realiza chute inicial com critério geométrico -> escreve em 'convective'
				//for (int ii = 0; ii < 4; ii++)
					//(*cNR1[/*i*/0])(ii, 0) = cd->convective[/*i*/0][ii];
				//(*patches1[/*i*/0])(0, 0) = cd->patchA[/*i*/0];
				//(*patches1[/*i*/0])(1, 0) = cd->patchB[/*i*/0];
				converged1 = GeneralFindMinimumSolution(cd, cNR1[/*i*/0], *patches1[/*i*/0], info, number_patchesA, number_patchesB);
				if (converged1) {
					*cNR2[/*i*/0] = *cNR1[/*i*/0];
					*patches2[/*i*/0] = *patches1[/*i*/0];
					//Se for intersecção - busca o ponto de sela
					if (CharacterizeCriticalPoint(cNR2[/*i*/0], *patches2[/*i*/0]) == 1)
					{
						converged2 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
						EvaluateNormalGapEligibleOrNot();

						if (converged2) {
							eligible = true;
							(*pair_control->contact_detection) = true;

							cd->degenerated[0] = false;

							cd->deg_control[0][0] = false;
							cd->deg_control[0][1] = false;
							cd->deg_control[0][2] = false;
							cd->deg_control[0][3] = false;

							cd->copy_deg_coordinates[0][0] = (*cNR2[/*i*/0])(0, 0);
							cd->copy_deg_coordinates[0][1] = (*cNR2[/*i*/0])(1, 0);
							cd->copy_deg_coordinates[0][2] = (*cNR2[/*i*/0])(2, 0);
							cd->copy_deg_coordinates[0][3] = (*cNR2[/*i*/0])(3, 0);

							//Degeneration basis - canonical basis
							(*cd->P[0])(0, 0) = 1.0;
							(*cd->P[0])(1, 1) = 1.0;
							(*cd->P[0])(2, 2) = 1.0;
							(*cd->P[0])(3, 3) = 1.0;

							//Degenerative operator
							cd->MountDegenerativeOperator();

							if ((*patches2[0])(0, 0) != sub_index1 || (*patches2[0])(1, 0) != sub_index2) {
								for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
								{
									if (db.gcs->contactPP_list[index1][i]->index2 == index2 && db.gcs->contactPP_list[index1][i]->sub_index1 == (*patches2[0])(0, 0) && db.gcs->contactPP_list[index1][i]->sub_index2 == (*patches2[0])(1, 0) /*&& i < contact*/) {
										//db.gcs->contactPP_list[index1][i]->contact_pairs[0]->eligible = true;
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][0] = (*cNR2[/*i*/0])(0, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][1] = (*cNR2[/*i*/0])(1, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][2] = (*cNR2[/*i*/0])(2, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][3] = (*cNR2[/*i*/0])(3, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchA[/*i*/0] = (*patches2[/*i*/0])(0, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchB[/*i*/0] = (*patches2[/*i*/0])(1, 0);
										EvaluateNormalGap();
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(0, 0) = (*cd->g[0])(0, 0);
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(1, 0) = (*cd->g[0])(1, 0);
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(2, 0) = (*cd->g[0])(2, 0);
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(0, 0) = (*cd->n[0])(0, 0);
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(1, 0) = (*cd->n[0])(1, 0);
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(2, 0) = (*cd->n[0])(2, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g_n[0] = cd->g_n[0];
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->return_value[0] = 0;
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->other_patch[0] = false;

										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->degenerated[0] = false;

										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][0] = false;
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][1] = false;
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][2] = false;
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][3] = false;

										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][0] = (*cNR2[/*i*/0])(0, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][1] = (*cNR2[/*i*/0])(1, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][2] = (*cNR2[/*i*/0])(2, 0);
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][3] = (*cNR2[/*i*/0])(3, 0);

										//Degeneration basis - canonical basis
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(0, 0) = 1.0;
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(1, 1) = 1.0;
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(2, 2) = 1.0;
										(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(3, 3) = 1.0;

										//Degenerative operator
										db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->MountDegenerativeOperator();

									}
								}
							}
						}
						else {
							for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
							{
								if (db.gcs->contactPP_list[index1][i]->index2 == index2 && (db.gcs->contactPP_list[index1][i]->sub_index1 != sub_index1 || db.gcs->contactPP_list[index1][i]->sub_index2 != sub_index2) && (*db.gcs->contactPP_list[index1][i]->contact_detectionA || *db.gcs->contactPP_list[index1][i]->contact_detectionB || *db.gcs->contactPP_list[index1][i]->contact_detectionAB)) {
									contact_aux = true;
									cd->convective[/*i*/0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][0];
									cd->convective[/*i*/0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][1];
									cd->convective[/*i*/0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][2];
									cd->convective[/*i*/0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][3];
									cd->patchA[/*i*/0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchA[/*i*/0];
									cd->patchB[/*i*/0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchB[/*i*/0];

									cd->degenerated[0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->degenerated[0];

									cd->deg_control[0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][0];
									cd->deg_control[0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][1];
									cd->deg_control[0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][2];
									cd->deg_control[0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][3];

									cd->copy_deg_coordinates[0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][0];
									cd->copy_deg_coordinates[0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][1];
									cd->copy_deg_coordinates[0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][2];
									cd->copy_deg_coordinates[0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][3];

									//Degeneration basis - canonical basis
									(*cd->P[0])(0, 0) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(0, 0);
									(*cd->P[0])(1, 1) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(1, 1);
									(*cd->P[0])(2, 2) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(2, 2);
									(*cd->P[0])(3, 3) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(3, 3);

									//Degenerative operator
									cd->MountDegenerativeOperator();

									break;
								}
							}
							if (contact_aux) {
								aut_exit = true;
								converged2 = true;
								eligible = false;
								cd->return_value[/*i*/0] = 4;
								cd->other_patch[0] = true;
							}
							else {
								if (planeA || planeB) {
									*cNR1[/*i*/0] = *cNR2[/*i*/0];
									*patches1[/*i*/0] = *patches2[/*i*/0];
									cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR2[/*i*/0], *patches2[/*i*/0]);
									if(cases == 1) {
										*cNR1[/*i*/0] = *cNR2[/*i*/0];
										*patches1[/*i*/0] = *patches2[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
										if (converged3) { // Considera-se que não vai haver regiões patológicas, caso contrário já havia sido detectado antes
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											*patches2[/*i*/0] = *patches1[/*i*/0];
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else if (cases == 2) {
										*cNR1[/*i*/0] = *cNR2[/*i*/0];
										*patches1[/*i*/0] = *patches2[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											*patches2[/*i*/0] = *patches1[/*i*/0];
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else if (cases == 3) {
										 if (planeA) {
											 (*cNR2[/*i*/0])(2, 0) = (*cNR1[/*i*/0])(2, 0);
											 (*cNR2[/*i*/0])(3, 0) = (*cNR1[/*i*/0])(3, 0);
											 cd->deg_control[0][2] = false;
											 cd->deg_control[0][3] = false;
										 }
										 else {
											 (*cNR2[/*i*/0])(0, 0) = (*cNR1[/*i*/0])(0, 0);
											 (*cNR2[/*i*/0])(1, 0) = (*cNR1[/*i*/0])(1, 0);
											 cd->deg_control[0][0] = false;
											 cd->deg_control[0][1] = false;
										 }
										 
										 cd->copy_deg_coordinates[0][0] = (*cNR2[/*i*/0])(0, 0);
										 cd->copy_deg_coordinates[0][1] = (*cNR2[/*i*/0])(1, 0);
										 cd->copy_deg_coordinates[0][2] = (*cNR2[/*i*/0])(2, 0);
										 cd->copy_deg_coordinates[0][3] = (*cNR2[/*i*/0])(3, 0);

										 // Degeneration basis - canonical basis
										 (*cd->P[0])(0, 0) = 1.0;
										 (*cd->P[0])(1, 1) = 1.0;
										 (*cd->P[0])(2, 2) = 1.0;
										 (*cd->P[0])(3, 3) = 1.0;

										 // Degenerative operator
										 cd->MountDegenerativeOperator();

										 cd->degenerated[0] = true;

										converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											if (planeA) {
												(*pair_control->contact_detectionA) = true;
											}
											else {
												(*pair_control->contact_detectionB) = true;
											}
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											*patches2[/*i*/0] = *patches1[/*i*/0];
											cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR2[/*i*/0], *patches2[/*i*/0]);
											*cNR1[/*i*/0] = *cNR2[/*i*/0];
											*patches1[/*i*/0] = *patches2[/*i*/0];
											converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
											if (converged3) {
												converged1 = true;
												converged2 = converged1;
												(*pair_control->contact_detectionAB) = true;
												EvaluateNormalGapEligibleOrNot();
											}
											else {
												*cNR2[/*i*/0] = *cNR1[/*i*/0];
												*patches2[/*i*/0] = *patches1[/*i*/0];
												converged1 = true;
												converged2 = converged1;
												(*pair_control->contact_detectionAB) = true;
												EvaluateNormalGapEligibleOrNot();
											}
										}
									}
									else if (cases == 4) {
										converged2 = false;
										eligible = false;
									}
								}else{
									cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR2[/*i*/0], *patches2[/*i*/0]);
									if (cases == 1) {
										*cNR1[/*i*/0] = *cNR2[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);

										if (converged3) { // Considera-se que não vai haver regiões patológicas, caso contrário já havia sido detectado antes
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else if (cases == 2) {
										*cNR1[/*i*/0] = *cNR2[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else if (cases == 3) {
										*cNR1[/*i*/0] = *cNR2[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR2[/*i*/0], patches2[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionAB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionAB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else if (cases == 4) {
										converged2 = false;
										eligible = false;
									}
								}	
							}
						}
					}
					//Se nao, retorna o minimo
					else
					{
						converged2 = converged1;
						eligible = false;
						(*pair_control->contact_detection) = true;
					}
				}
				else {
					for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
					{
						if (db.gcs->contactPP_list[index1][i]->index2 == index2 && (db.gcs->contactPP_list[index1][i]->sub_index1 != sub_index1 || db.gcs->contactPP_list[index1][i]->sub_index2 != sub_index2) && (*db.gcs->contactPP_list[index1][i]->contact_detectionA || *db.gcs->contactPP_list[index1][i]->contact_detectionB || *db.gcs->contactPP_list[index1][i]->contact_detectionAB)) {
							contact_aux = true;
							cd->convective[/*i*/0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][0];
							cd->convective[/*i*/0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][1];
							cd->convective[/*i*/0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][2];
							cd->convective[/*i*/0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][3];
							cd->patchA[/*i*/0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchA[/*i*/0];
							cd->patchB[/*i*/0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchB[/*i*/0];

							cd->degenerated[0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->degenerated[0];

							cd->deg_control[0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][0];
							cd->deg_control[0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][1];
							cd->deg_control[0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][2];
							cd->deg_control[0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][3];

							cd->copy_deg_coordinates[0][0] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][0];
							cd->copy_deg_coordinates[0][1] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][1];
							cd->copy_deg_coordinates[0][2] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][2];
							cd->copy_deg_coordinates[0][3] = db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][3];

							//Degeneration basis - canonical basis
							(*cd->P[0])(0, 0) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(0, 0);
							(*cd->P[0])(1, 1) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(1, 1);
							(*cd->P[0])(2, 2) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(2, 2);
							(*cd->P[0])(3, 3) = (*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(3, 3);

							//Degenerative operator
							cd->MountDegenerativeOperator();
							break;
						}
					}
					if (contact_aux) {
						aut_exit = true;
						converged2 = true;
						eligible = false;
						cd->return_value[/*i*/0] = 4;
						cd->other_patch[0] = true;
					}
					else {
						if (planeA || planeB) {
							*cNR2[/*i*/0] = *cNR1[/*i*/0];
							*patches2[/*i*/0] = *patches1[/*i*/0];
							cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR1[/*i*/0], *patches1[/*i*/0]);
							if (cases == 1) {
								converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
								if (converged3) {
									*cNR2[/*i*/0] = *cNR1[/*i*/0];
									(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
									(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
									EvaluateNormalGapEligibleOrNot();
									if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										*patches2[/*i*/0] = *patches1[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
											(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else {
										converged2 = converged3;
										eligible = false;
										(*pair_control->contact_detectionA) = true;
									}
								}
								else {
									converged2 = true;
									eligible = false;
								}
							}
							else if (cases == 2) {
								converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
								if (converged3) {
									*cNR2[/*i*/0] = *cNR1[/*i*/0];
									(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
									(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
									EvaluateNormalGapEligibleOrNot();
									if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										*patches2[/*i*/0] = *patches1[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
											(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else {
										converged2 = converged3;
										eligible = false;
										(*pair_control->contact_detectionB) = true;
									}
								}
								else {
									converged2 = true;
									eligible = false;
								}
							}
							else if (cases == 3) {
								if (planeA) {
									(*cNR1[/*i*/0])(2, 0) = (*cNR2[/*i*/0])(2, 0);
									(*cNR1[/*i*/0])(3, 0) = (*cNR2[/*i*/0])(3, 0);
									cd->deg_control[0][2] = false;
									cd->deg_control[0][3] = false;
								}
								else {
									(*cNR1[/*i*/0])(0, 0) = (*cNR2[/*i*/0])(0, 0);
									(*cNR1[/*i*/0])(1, 0) = (*cNR2[/*i*/0])(1, 0);
									cd->deg_control[0][0] = false;
									cd->deg_control[0][1] = false;
								}

								cd->copy_deg_coordinates[0][0] = (*cNR1[/*i*/0])(0, 0);
								cd->copy_deg_coordinates[0][1] = (*cNR1[/*i*/0])(1, 0);
								cd->copy_deg_coordinates[0][2] = (*cNR1[/*i*/0])(2, 0);
								cd->copy_deg_coordinates[0][3] = (*cNR1[/*i*/0])(3, 0);

								// Degeneration basis - canonical basis
								(*cd->P[0])(0, 0) = 1.0;
								(*cd->P[0])(1, 1) = 1.0;
								(*cd->P[0])(2, 2) = 1.0;
								(*cd->P[0])(3, 3) = 1.0;

								// Degenerative operator
								cd->MountDegenerativeOperator();

								cd->degenerated[0] = true;

								converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
								if (converged3) {
									*cNR2[/*i*/0] = *cNR1[/*i*/0];
									(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
									(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
									EvaluateNormalGapEligibleOrNot();
									if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										*patches2[/*i*/0] = *patches1[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
											(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
											if (planeA) {
												(*pair_control->contact_detectionA) = true;
											}
											else {
												(*pair_control->contact_detectionB) = true;
											}
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR1[/*i*/0], *patches1[/*i*/0]);
											if (cases == 1) {
												*cNR2[/*i*/0] = *cNR1[/*i*/0];
												*patches2[/*i*/0] = *patches1[/*i*/0];
												converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
												if (converged3) { // Considera-se que não vai haver regiões patológicas, caso contrário já havia sido detectado antes
													converged1 = true;
													converged2 = converged1;
													*cNR2[/*i*/0] = *cNR1[/*i*/0];
													(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
													(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
													(*pair_control->contact_detectionA) = true;
													EvaluateNormalGapEligibleOrNot();
												}
												else {
													converged1 = true;
													converged2 = converged1;
													(*pair_control->contact_detectionA) = true;
													EvaluateNormalGapEligibleOrNot();
												}
											}
											else if (cases == 2) {
												*cNR2[/*i*/0] = *cNR1[/*i*/0];
												*patches2[/*i*/0] = *patches1[/*i*/0];
												converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
												if (converged3) {
													converged1 = true;
													converged2 = converged1;
													*cNR2[/*i*/0] = *cNR1[/*i*/0];
													(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
													(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
													(*pair_control->contact_detectionB) = true;
													EvaluateNormalGapEligibleOrNot();
												}
												else {
													converged1 = true;
													converged2 = converged1;
													(*pair_control->contact_detectionB) = true;
													EvaluateNormalGapEligibleOrNot();
												}
											}
											else if (cases == 3) {
												*cNR2[/*i*/0] = *cNR1[/*i*/0];
												*patches2[/*i*/0] = *patches1[/*i*/0];
												converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
												if (converged3) {
													converged1 = true;
													converged2 = converged1;
													*cNR2[/*i*/0] = *cNR1[/*i*/0];
													(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
													(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
													(*pair_control->contact_detectionAB) = true;
													EvaluateNormalGapEligibleOrNot();
												}
												else {
													converged1 = true;
													converged2 = converged1;
													(*pair_control->contact_detectionAB) = true;
													EvaluateNormalGapEligibleOrNot();
												}
											}
											else if (cases == 4) {
												converged2 = false;
												eligible = false;
											}
										}
									}
									else {
										converged2 = converged3;
										eligible = false;
										if (planeA) {
											(*pair_control->contact_detectionA) = true;
										}
										else {
											(*pair_control->contact_detectionB) = true;
										}
									}
								}
								else {
									*cNR1[/*i*/0] = *cNR2[/*i*/0];
									*patches1[/*i*/0] = *patches2[/*i*/0];
									cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR1[/*i*/0], *patches1[/*i*/0]);
									converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
									if (converged3) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
										(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
										EvaluateNormalGapEligibleOrNot();
										if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											*patches2[/*i*/0] = *patches1[/*i*/0];
											converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
											if (converged3) {
												converged1 = true;
												converged2 = converged1;
												*cNR2[/*i*/0] = *cNR1[/*i*/0];
												(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
												(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
												(*pair_control->contact_detectionAB) = true;
												EvaluateNormalGapEligibleOrNot();
											}
											else {
												converged1 = true;
												converged2 = converged1;
												(*pair_control->contact_detectionAB) = true;
												EvaluateNormalGapEligibleOrNot();
											}
										}
										else {
											converged2 = converged3;
											eligible = false;
											(*pair_control->contact_detectionAB) = true;
										}
									}
									else {
										converged2 = true;
										eligible = false;
									}

								}
							}
							else if (cases == 4) {
								converged2 = false;
								eligible = false;
							}
						}
						else {
							cases = VerifyCriticalMultipatchNURBSRegion(cd, cNR1[/*i*/0], *patches1[/*i*/0]);
							if (cases == 1) {
								converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
								if (converged3) {
									*cNR2[/*i*/0] = *cNR1[/*i*/0];
									(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
									(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
									EvaluateNormalGapEligibleOrNot();
									if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
											(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionA) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else {
										converged2 = converged3;
										eligible = false;
										(*pair_control->contact_detectionA) = true;
									}
								}
								else {
									converged2 = true;
									eligible = false;
								}



							}
							else if (cases == 2) {
								converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
								if (converged3) {
									*cNR2[/*i*/0] = *cNR1[/*i*/0];
									(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
									(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
									EvaluateNormalGapEligibleOrNot();
									if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
											(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else {
										converged2 = converged3;
										eligible = false;
										(*pair_control->contact_detectionB) = true;
									}
								}
								else {
									converged2 = true;
									eligible = false;
								}
							}
							else if (cases == 3) {
								converged3 = FindMinimumSolutionDegenerated(cd, cd->P_0[0], cNR1[/*i*/0], *patches1[/*i*/0]);
								if (converged3) {
									*cNR2[/*i*/0] = *cNR1[/*i*/0];
									(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
									(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
									EvaluateNormalGapEligibleOrNot();
									if (CharacterizeCriticalPointDegenerated(cNR1[/*i*/0], *patches1[/*i*/0]) == 1 || eligible) {
										*cNR2[/*i*/0] = *cNR1[/*i*/0];
										converged3 = FindMinimumSolutionCSO(cd, cNR1[/*i*/0], patches1[/*i*/0], 1);
										if (converged3) {
											converged1 = true;
											converged2 = converged1;
											*cNR2[/*i*/0] = *cNR1[/*i*/0];
											(*patches2[0])(0, 0) = (*patches1[0])(0, 0);
											(*patches2[0])(1, 0) = (*patches1[0])(1, 0);
											(*pair_control->contact_detectionAB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
										else {
											converged1 = true;
											converged2 = converged1;
											(*pair_control->contact_detectionAB) = true;
											EvaluateNormalGapEligibleOrNot();
										}
									}
									else {
										converged2 = converged3;
										eligible = false;
										(*pair_control->contact_detectionAB) = true;
									}
								}
								else {
									converged2 = true;
									eligible = false;
								}
							}
							else if (cases == 4) {
								converged2 = false;
								eligible = false;
							}
						}
					}
				}
			}
			//}
			////////////////DEGENERATION///////////////
			//else
			//{

			//}

			if (((db.last_converged_time + db.current_time_step) > 2.432 && (db.last_converged_time + db.current_time_step) < 2.468)) {
				//cout << "inter.: " << converged1 << endl;
				//cout << "penet.: " << converged2 << endl;
			}

			if (converged2 == true && aut_exit == false)
			{
				//Next convective coordinates:
				cd->convective[/*i*/0][0] = (*cNR2[/*i*/0])(0, 0);
				cd->convective[/*i*/0][1] = (*cNR2[/*i*/0])(1, 0);
				cd->convective[/*i*/0][2] = (*cNR2[/*i*/0])(2, 0);
				cd->convective[/*i*/0][3] = (*cNR2[/*i*/0])(3, 0);
				cd->patchA[/*i*/0] = (*patches2[/*i*/0])(0, 0);
				cd->patchB[/*i*/0] = (*patches2[/*i*/0])(1, 0);

				//Preenche return value com 0, 2 ou 4
				cd->return_value[/*i*/0] = VerifyConvectiveRange(cd, *cNR2[/*i*/0], *patches2[/*i*/0]);
				//Correction (for not creating a not-strong candidate here!):
				if (cd->return_value[/*i*/0] == 2) {
					cd->return_value[/*i*/0] = 4;
					(*pair_control->contact_detection) = false;
					(*pair_control->contact_detectionA) = false;
					(*pair_control->contact_detectionB) = false;
					(*pair_control->contact_detectionAB) = false;
				}
				if (cd->return_value[/*i*/0] == 4) {
					eligible = false;
					(*pair_control->contact_detection) = false;
					(*pair_control->contact_detectionA) = false;
					(*pair_control->contact_detectionB) = false;
					(*pair_control->contact_detectionAB) = false;
				}
				if (cd->return_value[/*i*/0] == 0) {
					//cout << " ";

					if (*pair_control->contact_detection) {
						for (int i = 0; i < db.gcs->contactPP_list[index1].size(); i++)
						{
							if (db.gcs->contactPP_list[index1][i]->index2 == index2 && (db.gcs->contactPP_list[index1][i]->sub_index1 != sub_index1 || db.gcs->contactPP_list[index1][i]->sub_index2 != sub_index2) && (*db.gcs->contactPP_list[index1][i]->contact_detectionA || *db.gcs->contactPP_list[index1][i]->contact_detectionB || *db.gcs->contactPP_list[index1][i]->contact_detectionAB)) {
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->eligible = false;
								*db.gcs->contactPP_list[index1][i]->contact_detectionA = false;
								*db.gcs->contactPP_list[index1][i]->contact_detectionB = false;
								*db.gcs->contactPP_list[index1][i]->contact_detectionAB = false;
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][0] = (*cNR2[/*i*/0])(0, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][1] = (*cNR2[/*i*/0])(1, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][2] = (*cNR2[/*i*/0])(2, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->convective[/*i*/0][3] = (*cNR2[/*i*/0])(3, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchA[/*i*/0] = (*patches2[/*i*/0])(0, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->patchB[/*i*/0] = (*patches2[/*i*/0])(1, 0);
								EvaluateNormalGap();
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(0, 0) = (*cd->g[0])(0, 0);
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(1, 0) = (*cd->g[0])(1, 0);
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g[0])(2, 0) = (*cd->g[0])(2, 0);
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(0, 0) = (*cd->n[0])(0, 0);
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(1, 0) = (*cd->n[0])(1, 0);
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->n[0])(2, 0) = (*cd->n[0])(2, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->g_n[0] = -cd->g_n[0];
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->return_value[0] = 4;
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->other_patch[0] = true;

								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->degenerated[0] = false;

								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][0] = false;
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][1] = false;
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][2] = false;
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->deg_control[0][3] = false;

								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][0] = (*cNR2[/*i*/0])(0, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][1] = (*cNR2[/*i*/0])(1, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][2] = (*cNR2[/*i*/0])(2, 0);
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->copy_deg_coordinates[0][3] = (*cNR2[/*i*/0])(3, 0);

								//Degeneration basis - canonical basis
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(0, 0) = 1.0;
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(1, 1) = 1.0;
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(2, 2) = 1.0;
								(*db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->P[0])(3, 3) = 1.0;

								//Degenerative operator
								db.gcs->contactPP_list[index1][i]->contact_pairs[0]->cd->MountDegenerativeOperator();
							}
						}
					}
				}
				//Teste - mudanca de solucao na propria superficie
				if (cd->copy_return_value[/*i*/0] == 0 && ((eligible && cd->copy_g_n[0] < 0)||(eligible == false && cd->copy_g_n[0] > 0)))
				{
					//&& cd->copy_patchA[/*i*/0] == (*patches2[/*i*/0])(0, 0) && cd->copy_patchB[/*i*/0] == (*patches2[/*i*/0])(1, 0)
					//Previous convective coordinates:
					(*cNR1[/*i*/0])(0, 0) = cd->copy_convective[/*i*/0][0];
					(*cNR1[/*i*/0])(1, 0) = cd->copy_convective[/*i*/0][1];
					(*cNR1[/*i*/0])(2, 0) = cd->copy_convective[/*i*/0][2];
					(*cNR1[/*i*/0])(3, 0) = cd->copy_convective[/*i*/0][3];
					(*patches1[/*i*/0])(0, 0) = cd->copy_patchA[/*i*/0];
					(*patches1[/*i*/0])(1, 0) = cd->copy_patchB[/*i*/0];

					//Verificação de normais 
					Matrix cur_n1(3);
					Matrix cur_n2(3);
					surfA->patches[(*patches2[/*i*/0])(0, 0)]->NormalExt(ptrQAp, &(*cNR2[/*i*/0])(0, 0), &(*cNR2[/*i*/0])(1, 0), &cur_n1);
					surfB->patches[(*patches2[/*i*/0])(1, 0)]->NormalExt(ptrQBp, &(*cNR2[/*i*/0])(2, 0), &(*cNR2[/*i*/0])(3, 0), &cur_n2);
					Matrix prev_n1(3);
					Matrix prev_n2(3);
					surfA->patches[(*patches1[/*i*/0])(0, 0)]->NormalExt(ptrQAp, &(*cNR1[/*i*/0])(0, 0), &(*cNR1[/*i*/0])(1, 0), &prev_n1);
					surfB->patches[(*patches1[/*i*/0])(1, 0)]->NormalExt(ptrQBp, &(*cNR1[/*i*/0])(2, 0), &(*cNR1[/*i*/0])(3, 0), &prev_n2);
					if (dot(cur_n1, prev_n1) < 0 || dot(cur_n2, prev_n2) < 0)
						{
						cd->return_value[/*i*/0] = 0;
						eligible = false;
						if ((*pair_control->contact_detection)) {
							(*pair_control->contact_detection) = false;
							}
						else if ((*pair_control->contact_detectionA)) {
							(*pair_control->contact_detectionA) = false;
							}
						else if ((*pair_control->contact_detectionB)) {
							(*pair_control->contact_detectionB) = false;
							}
						else if ((*pair_control->contact_detectionAB)) {
							(*pair_control->contact_detectionAB) = false;
							}
						/*db.myprintf("Code 3. n1.n1 = %.6e, n2.n2 = %.6e\n", dot(cur_n1, prev_n1), dot(cur_n2, prev_n2));
						db.myprintf("cur: %.6e,  %.6e,  %.6e , %.6e\n", (*cNR2[i])(0, 0), (*cNR2[i])(1, 0), (*cNR2[i])(2, 0), (*cNR2[i])(3, 0));
						db.myprintf("pre: %.6e,  %.6e,  %.6e , %.6e\n", (*cNR1[i])(0, 0), (*cNR1[i])(1, 0), (*cNR1[i])(2, 0), (*cNR1[i])(3, 0));
						db.myprintf("Surf1 %d Surf2 %d, charac1 %d, charact2 %d\n", surf1_ID, surf2_ID,
							CharacterizeCriticalPointDegenerated(cNR1[i], c_data->P_0[i], true),
							CharacterizeCriticalPointDegenerated(cNR2[i], c_data->P_0[i], true));*/
							}
					}

				//if (write_report)
					//fprintf(f_TR_report[i], "SolveLCP return value is %d \n", c_data->return_value[i]);
			}
			else if (converged2 == true && aut_exit == true) {

			}
			else
			{
				// lidar com mínimo não convergido
				//if (converged1 == false) {
					//eligible = false;
					//cd->return_value[/*i*/0] = 2;
				//}
				//else {
					//eligible = false;
					//cd->return_value[/*i*/0] = 1;
				//}

				eligible = false;
				(*pair_control->contact_detection) = false;
				cd->return_value[/*i*/0] = 1;

				//if (write_report)
					//fprintf(f_TR_report[i], "LCP between surfaces %d and %d has presented problems. Code 1.\n", surf1_ID, surf2_ID);
				//db.myprintf("LCP between surfaces %d and %d has presented problems. Code 1.\n", surf1_ID, surf2_ID);

				//Writing report based on divergence (for monitoring issues)
				/*if (write_report_diverged == true && write_report == false)
				{
					write_report = true;
					for (int ii = 0; ii < n_pointwise; ii++)
					{
						InitializeTRReport(ii);
						OpenTRReport(ii);
						fprintf(f_TR_report[ii], "///////////////////////////////////////////////////////////////////////\n");
						fprintf(f_TR_report[ii], "\nTime\t%.6f\tIteration\t%d\t", db.last_converged_time + db.current_time_step, db.current_iteration_number);
						fprintf(f_TR_report[ii], "Write Report automatically launched on divergence of LCP\n");
					}
				}*/
			}

			//if (index1 == 48 && index2 == 131 /*&& sub_index1 == 5 && sub_index2 == 2*/ && (db.last_converged_time + db.current_time_step) > 1.03872) {
				//db.myprintf("sub_index1 = %d\n", sub_index1);
				//db.myprintf("sub_index2 = %d\n", sub_index2);
				//db.myprintf("eligible = %d\n", eligible);
			//}

			if (((db.last_converged_time + db.current_time_step) > 2.432 && (db.last_converged_time + db.current_time_step) < 2.44)) {
				//cout << "return_value: " << cd->return_value[/*i*/0] << endl;
				//cout << endl;
			}

		}
	}

    delete[] fg;

	delete[] point;
}

void RigidNURBSSurface_RigidNURBSSurface::SolvePreviousContact()
{
	previous_evaluation = true;
	//LCP
	SolveLCP();
	SurfacePoints();
	//Gap vetorial
	*cd->copy_g[0] = *GammaA - *GammaB;
	//Normal do contato
	if (norm(*cd->copy_g[0]) != 0.0)
		*cd->copy_n[0] = (1.0 / norm(*cd->copy_g[0]))*(*cd->copy_g[0]);
	else
		zeros(cd->copy_n[0]);
	//Gap escalar
	if (eligible == true)
		*cd->copy_g_n = -1.0*norm(*cd->copy_n[0]);
	else
		*cd->copy_g_n = 1.0*norm(*cd->copy_n[0]);

	previous_evaluation = false;
}

void RigidNURBSSurface_RigidNURBSSurface::MountLocalContributions()
{

	cAp[0] = cd->convective[0][0];
	cAp[1] = cd->convective[0][1];
	cBp[0] = cd->convective[0][2];
	cBp[1] = cd->convective[0][3];

	Matrix p(4);
	p(0, 0) = cAp[0];
	p(1, 0) = cAp[1];
	p(2, 0) = cBp[0];
	p(3, 0) = cBp[1];

	Matrix patch_p(2);
	patch_p(0, 0) = cd->patchA[0];
	patch_p(1, 0) = cd->patchB[0];

	bool previouscontact = prev_eligible;

	// Verificar se previouscontact é falso
		// Opção a: não havia contato prévio entre as partículas e, portanto, o gti deve ser 0 e o previouscontact deve ser 'false'
		// Opção b: houve mudança de patch e, portanto, o gti deve ser o do patch vizinho que havia contato r o previous contact deve ser 'true'

	Matrix i(4);
	Matrix patch_i(2);

	cAi[0] = cd->copy_convective[0][0];
	cAi[1] = cd->copy_convective[0][1];
	cBi[0] = cd->copy_convective[0][2];
	cBi[1] = cd->copy_convective[0][3];

	i(0, 0) = cAi[0];
	i(1, 0) = cAi[1];
	i(2, 0) = cBi[0];
	i(3, 0) = cBi[1];

	patch_i(0, 0) = cd->copy_patchA[0];
	patch_i(1, 0) = cd->copy_patchB[0];

	if (previouscontact == false) {
		for (int cont = 0; cont < db.gcs->contactPP_list[index1].size(); cont++)
		{
			if ((db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->prev_eligible == true) && (db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->eligible == false) && (db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->index2 == index2))
			{
				gti[0] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[0];
				gti[1] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[1];
				gti[2] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[2];
				previouscontact = true;

				cAi[0] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][0];
				cAi[1] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][1];
				cBi[0] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][2];
				cBi[1] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][3];

				i(0, 0) = cAi[0];
				i(1, 0) = cAi[1];
				i(2, 0) = cBi[0];
				i(3, 0) = cBi[1];

				patch_i(0, 0) = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_patchA[0];
				patch_i(1, 0) = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_patchB[0];
			}
			else
			{
				
			}
		}
	}

	// Verificar se previouscontact é falso, o que indica que houve mudança de patch (se gira e deixa de ser contato e depois volta, o previouscontact é coerente?)
	// Analisar para as particulas se tinha algum contato anterior no passo anterior (como?)
	// Se sim, pegar informações pertinentes CAi,gti, ni

	/*if (index1 == 0) {
		cout << "InvH" << endl;
		cout << invH[0][0] << " " << invH[0][1] << " " << invH[0][2] << endl;
		cout << invH[1][0] << " " << invH[1][1] << " " << invH[1][2] << endl;
		cout << invH[2][0] << " " << invH[2][1] << " " << invH[2][2] << endl;
		cout << endl;
		cout << cAi[0] << " " << cAi[1] << endl;
		cout << endl;
	}*/

	v = DBG_NEW double[5800];

	double value = 0.0;
	double* a4;
	double* a5;
	double* a6;
	if (typeid(*db.solution[db.current_solution_number - 1]) == typeid(Dynamic))
	{
		Dynamic* ptr_sol = static_cast<Dynamic*>(db.solution[db.current_solution_number - 1]);
		a4 = &ptr_sol->a4;
		a5 = &ptr_sol->a5;
		a6 = &ptr_sol->a6;
	}
	else
	{
		a4 = &value;
		a5 = &value;
		a6 = &value;
	}
	//Zerando matrizes e vetores
	for (int i = 0; i < 12; i++)
	{
		Rc[i] = 0.0;
		for (int j = 0; j < 12; j++)
			Kc[i][j] = 0.0;
	}

	

	EvaluateNURBSDerivatives_p(p, patch_p);
	EvaluateNURBSDerivatives_i(i, patch_i);
	//EvaluateNURBSDOFsVariables();

	//Avalia contribuições de contato

#pragma region AceGen
	double v01; double v010; double v011; double v012; double v013; double v014;
	double v015; double v016; double v017; double v018; double v019; double v02;
	double v020; double v021; double v022; double v023; double v024; double v025;
	double v026; double v027; double v03; double v04; double v05; double v06; double v07;
	double v08; double v09;
	int i851, i919, i1147, i1518, i2415, i2479, i2899, i2900, i2901, i2902, i2903, i2904, i2955
		, i2956, i2957, i2958, i2959, i2960, i2975, i2976, i2977, i2978, i2979, i2980, i2987, i2988
		, i2989, i3136, i3137, i3138, i3139, i3140, i3141, b709, b710, b742, b764, b765, b781, b782
		, b783, b799, b816, b817, b829, b1152, b1153, b1154, b1195, b1223, b1257, b1796, b1841, b1899
		, b1913, b1914, b1931, b1999, b2080, b2105, b2420, b2561;
	v[4588] = 0e0;
	v[4589] = 0e0;
	v[4590] = 1e0;
	v[4591] = 0e0;
	v[4592] = 0e0;
	v[4593] = 0e0;
	v[4594] = 0e0;
	v[4595] = 0e0;
	v[4596] = -1e0;
	v[4597] = 0e0;
	v[4598] = 0e0;
	v[4599] = 0e0;
	v[4600] = 0e0;
	v[4601] = 1e0;
	v[4602] = 0e0;
	v[4603] = 0e0;
	v[4604] = 0e0;
	v[4605] = 0e0;
	v[4606] = 0e0;
	v[4607] = -1e0;
	v[4608] = 0e0;
	v[4609] = 0e0;
	v[4610] = 0e0;
	v[4611] = 0e0;
	v[4612] = 1e0;
	v[4613] = 0e0;
	v[4614] = 0e0;
	v[4615] = 0e0;
	v[4616] = 0e0;
	v[4617] = 0e0;
	v[4618] = -1e0;
	v[4619] = 0e0;
	v[4620] = 0e0;
	v[4621] = 0e0;
	v[4622] = 0e0;
	v[4623] = 0e0;
	v[872] = GAp[0] * QAi[0][0] + GAp[1] * QAi[0][1] + GAp[2] * QAi[0][2];
	v[870] = GAp[0] * QAi[1][0] + GAp[1] * QAi[1][1] + GAp[2] * QAi[1][2];
	v[868] = GAp[0] * QAi[2][0] + GAp[1] * QAi[2][1] + GAp[2] * QAi[2][2];
	v[401] = alphaA[0] / 2e0;
	v[399] = 2e0*alphaA[0];
	v[226] = Power(alphaA[0], 2);
	v[402] = 2e0*alphaA[1];
	v[4468] = 0e0;
	v[4469] = 0e0;
	v[4470] = 0e0;
	v[4471] = v[399];
	v[4472] = v[402];
	v[4473] = 0e0;
	v[4474] = 0e0;
	v[4475] = 0e0;
	v[4476] = 0e0;
	v[4477] = 0e0;
	v[4478] = 0e0;
	v[4479] = 0e0;
	v[4740] = 0e0;
	v[4741] = 0e0;
	v[4742] = 0e0;
	v[4743] = -v[399];
	v[4744] = -v[402];
	v[4745] = 0e0;
	v[4746] = 0e0;
	v[4747] = 0e0;
	v[4748] = 0e0;
	v[4749] = 0e0;
	v[4750] = 0e0;
	v[4751] = 0e0;
	v[400] = alphaA[1] / 2e0;
	v[4288] = 0e0;
	v[4289] = 0e0;
	v[4290] = 0e0;
	v[4291] = v[400];
	v[4292] = v[401];
	v[4293] = 0e0;
	v[4294] = 0e0;
	v[4295] = 0e0;
	v[4296] = 0e0;
	v[4297] = 0e0;
	v[4298] = 0e0;
	v[4299] = 0e0;
	v[224] = (alphaA[0] * alphaA[1]) / 2e0;
	v[219] = Power(alphaA[1], 2);
	v[451] = -v[219] - v[226];
	v[429] = alphaA[2] + v[224];
	v[419] = -alphaA[2] + v[224];
	v[404] = 2e0*alphaA[2];
	v[5480] = 0e0;
	v[5481] = 0e0;
	v[5482] = 0e0;
	v[5483] = -v[399];
	v[5484] = 0e0;
	v[5485] = -v[404];
	v[5486] = 0e0;
	v[5487] = 0e0;
	v[5488] = 0e0;
	v[5489] = 0e0;
	v[5490] = 0e0;
	v[5491] = 0e0;
	v[4420] = 0e0;
	v[4421] = 0e0;
	v[4422] = 0e0;
	v[4423] = v[399];
	v[4424] = 0e0;
	v[4425] = v[404];
	v[4426] = 0e0;
	v[4427] = 0e0;
	v[4428] = 0e0;
	v[4429] = 0e0;
	v[4430] = 0e0;
	v[4431] = 0e0;
	v[4372] = 0e0;
	v[4373] = 0e0;
	v[4374] = 0e0;
	v[4375] = 0e0;
	v[4376] = v[402];
	v[4377] = v[404];
	v[4378] = 0e0;
	v[4379] = 0e0;
	v[4380] = 0e0;
	v[4381] = 0e0;
	v[4382] = 0e0;
	v[4383] = 0e0;
	v[4788] = 0e0;
	v[4789] = 0e0;
	v[4790] = 0e0;
	v[4791] = 0e0;
	v[4792] = -v[402];
	v[4793] = -v[404];
	v[4794] = 0e0;
	v[4795] = 0e0;
	v[4796] = 0e0;
	v[4797] = 0e0;
	v[4798] = 0e0;
	v[4799] = 0e0;
	v[4276] = 0e0;
	v[4277] = 0e0;
	v[4278] = 0e0;
	v[4279] = v[399];
	v[4280] = v[402];
	v[4281] = v[404];
	v[4282] = 0e0;
	v[4283] = 0e0;
	v[4284] = 0e0;
	v[4285] = 0e0;
	v[4286] = 0e0;
	v[4287] = 0e0;
	v[403] = alphaA[2] / 2e0;
	v[4300] = 0e0;
	v[4301] = 0e0;
	v[4302] = 0e0;
	v[4303] = v[403];
	v[4304] = 0e0;
	v[4305] = v[401];
	v[4306] = 0e0;
	v[4307] = 0e0;
	v[4308] = 0e0;
	v[4309] = 0e0;
	v[4310] = 0e0;
	v[4311] = 0e0;
	v[4312] = 0e0;
	v[4313] = 0e0;
	v[4314] = 0e0;
	v[4315] = 0e0;
	v[4316] = v[403];
	v[4317] = v[400];
	v[4318] = 0e0;
	v[4319] = 0e0;
	v[4320] = 0e0;
	v[4321] = 0e0;
	v[4322] = 0e0;
	v[4323] = 0e0;
	v[231] = (alphaA[1] * alphaA[2]) / 2e0;
	v[446] = alphaA[0] + v[231];
	v[438] = -alphaA[0] + v[231];
	v[229] = (alphaA[0] * alphaA[2]) / 2e0;
	v[442] = -alphaA[1] + v[229];
	v[425] = alphaA[1] + v[229];
	v[220] = Power(alphaA[2], 2);
	v[1075] = 4e0 + v[219] + v[220] + v[226];
	v[3350] = 1e0 / Power(v[1075], 4);
	v[1500] = 1e0 / Power(v[1075], 3);
	v[1569] = -8e0*v[1500] * v[399];
	v[1567] = 8e0*v[1500] * v[402];
	v[1564] = -8e0*v[1500] * v[404];
	v[966] = 1e0 / Power(v[1075], 2);
	v[3102] = 4e0*v[966];
	v[433] = -v[220] - v[226];
	v[414] = -v[219] - v[220];
	v[2527] = -2e0*v[414] * v[966];
	v[413] = 4e0*v[404] * v[966];
	v[455] = -(v[413] * v[451]) / 2e0;
	v[412] = -4e0*v[402] * v[966];
	v[435] = (v[412] * v[433]) / 2e0;
	v[411] = 4e0*v[399] * v[966];
	v[415] = -(v[411] * v[414]) / 2e0;
	v[310] = (*a4)*alphaA[0] + (*a5)*dalphaiA[0] + (*a6)*ddalphaiA[0];
	v[316] = (*a4)*alphaA[1] + (*a5)*dalphaiA[1] + (*a6)*ddalphaiA[1];
	v[318] = (*a4)*alphaA[2] + (*a5)*dalphaiA[2] + (*a6)*ddalphaiA[2];
	v[860] = -(GBp[0] * QBi[0][0]) - GBp[1] * QBi[0][1] - GBp[2] * QBi[0][2];
	v[858] = -(GBp[0] * QBi[1][0]) - GBp[1] * QBi[1][1] - GBp[2] * QBi[1][2];
	v[856] = -(GBp[0] * QBi[2][0]) - GBp[1] * QBi[2][1] - GBp[2] * QBi[2][2];
	v[407] = alphaB[0] / 2e0;
	v[405] = 2e0*alphaB[0];
	v[266] = Power(alphaB[0], 2);
	v[408] = 2e0*alphaB[1];
	v[4576] = 0e0;
	v[4577] = 0e0;
	v[4578] = 0e0;
	v[4579] = 0e0;
	v[4580] = 0e0;
	v[4581] = 0e0;
	v[4582] = 0e0;
	v[4583] = 0e0;
	v[4584] = 0e0;
	v[4585] = v[405];
	v[4586] = v[408];
	v[4587] = 0e0;
	v[4812] = 0e0;
	v[4813] = 0e0;
	v[4814] = 0e0;
	v[4815] = 0e0;
	v[4816] = 0e0;
	v[4817] = 0e0;
	v[4818] = 0e0;
	v[4819] = 0e0;
	v[4820] = 0e0;
	v[4821] = -v[405];
	v[4822] = -v[408];
	v[4823] = 0e0;
	v[406] = alphaB[1] / 2e0;
	v[4336] = 0e0;
	v[4337] = 0e0;
	v[4338] = 0e0;
	v[4339] = 0e0;
	v[4340] = 0e0;
	v[4341] = 0e0;
	v[4342] = 0e0;
	v[4343] = 0e0;
	v[4344] = 0e0;
	v[4345] = v[406];
	v[4346] = v[407];
	v[4347] = 0e0;
	v[264] = (alphaB[0] * alphaB[1]) / 2e0;
	v[259] = Power(alphaB[1], 2);
	v[550] = -v[259] - v[266];
	v[528] = alphaB[2] + v[264];
	v[518] = -alphaB[2] + v[264];
	v[410] = 2e0*alphaB[2];
	v[5492] = 0e0;
	v[5493] = 0e0;
	v[5494] = 0e0;
	v[5495] = 0e0;
	v[5496] = 0e0;
	v[5497] = 0e0;
	v[5498] = 0e0;
	v[5499] = 0e0;
	v[5500] = 0e0;
	v[5501] = -v[405];
	v[5502] = 0e0;
	v[5503] = -v[410];
	v[4528] = 0e0;
	v[4529] = 0e0;
	v[4530] = 0e0;
	v[4531] = 0e0;
	v[4532] = 0e0;
	v[4533] = 0e0;
	v[4534] = 0e0;
	v[4535] = 0e0;
	v[4536] = 0e0;
	v[4537] = v[405];
	v[4538] = 0e0;
	v[4539] = v[410];
	v[4480] = 0e0;
	v[4481] = 0e0;
	v[4482] = 0e0;
	v[4483] = 0e0;
	v[4484] = 0e0;
	v[4485] = 0e0;
	v[4486] = 0e0;
	v[4487] = 0e0;
	v[4488] = 0e0;
	v[4489] = 0e0;
	v[4490] = v[408];
	v[4491] = v[410];
	v[4860] = 0e0;
	v[4861] = 0e0;
	v[4862] = 0e0;
	v[4863] = 0e0;
	v[4864] = 0e0;
	v[4865] = 0e0;
	v[4866] = 0e0;
	v[4867] = 0e0;
	v[4868] = 0e0;
	v[4869] = 0e0;
	v[4870] = -v[408];
	v[4871] = -v[410];
	v[4324] = 0e0;
	v[4325] = 0e0;
	v[4326] = 0e0;
	v[4327] = 0e0;
	v[4328] = 0e0;
	v[4329] = 0e0;
	v[4330] = 0e0;
	v[4331] = 0e0;
	v[4332] = 0e0;
	v[4333] = v[405];
	v[4334] = v[408];
	v[4335] = v[410];
	v[409] = alphaB[2] / 2e0;
	v[4348] = 0e0;
	v[4349] = 0e0;
	v[4350] = 0e0;
	v[4351] = 0e0;
	v[4352] = 0e0;
	v[4353] = 0e0;
	v[4354] = 0e0;
	v[4355] = 0e0;
	v[4356] = 0e0;
	v[4357] = v[409];
	v[4358] = 0e0;
	v[4359] = v[407];
	v[4360] = 0e0;
	v[4361] = 0e0;
	v[4362] = 0e0;
	v[4363] = 0e0;
	v[4364] = 0e0;
	v[4365] = 0e0;
	v[4366] = 0e0;
	v[4367] = 0e0;
	v[4368] = 0e0;
	v[4369] = 0e0;
	v[4370] = v[409];
	v[4371] = v[406];
	v[271] = (alphaB[1] * alphaB[2]) / 2e0;
	v[545] = alphaB[0] + v[271];
	v[537] = -alphaB[0] + v[271];
	v[269] = (alphaB[0] * alphaB[2]) / 2e0;
	v[541] = -alphaB[1] + v[269];
	v[524] = alphaB[1] + v[269];
	v[260] = Power(alphaB[2], 2);
	v[1085] = 4e0 + v[259] + v[260] + v[266];
	v[3344] = 1e0 / Power(v[1085], 4);
	v[1502] = 1e0 / Power(v[1085], 3);
	v[1583] = -8e0*v[1502] * v[405];
	v[1581] = 8e0*v[1502] * v[408];
	v[1578] = -8e0*v[1502] * v[410];
	v[981] = 1e0 / Power(v[1085], 2);
	v[3105] = 4e0*v[981];
	v[532] = -v[260] - v[266];
	v[513] = -v[259] - v[260];
	v[2538] = -2e0*v[513] * v[981];
	v[512] = 4e0*v[410] * v[981];
	v[554] = -(v[512] * v[550]) / 2e0;
	v[511] = -4e0*v[408] * v[981];
	v[534] = (v[511] * v[532]) / 2e0;
	v[510] = 4e0*v[405] * v[981];
	v[514] = -(v[510] * v[513]) / 2e0;
	v[336] = (*a4)*alphaB[0] + (*a5)*dalphaiB[0] + (*a6)*ddalphaiB[0];
	v[342] = (*a4)*alphaB[1] + (*a5)*dalphaiB[1] + (*a6)*ddalphaiB[1];
	v[344] = (*a4)*alphaB[2] + (*a5)*dalphaiB[2] + (*a6)*ddalphaiB[2];
	v[218] = 4e0 / v[1075];
	v[3100] = -v[218] / 2e0;
	v[453] = -(v[218] * v[402]) / 2e0;
	v[454] = (v[412] * v[451]) / 2e0 + v[453];
	v[450] = -(v[218] * v[399]) / 2e0;
	v[452] = v[450] - (v[411] * v[451]) / 2e0;
	v[447] = v[218] - v[411] * v[446];
	v[444] = -v[218] + v[412] * v[442];
	v[439] = -v[218] - v[411] * v[438];
	v[436] = -(v[218] * v[404]) / 2e0;
	v[437] = -(v[413] * v[433]) / 2e0 + v[436];
	v[434] = -(v[411] * v[433]) / 2e0 + v[450];
	v[432] = v[218] - v[413] * v[429];
	v[427] = v[218] + v[412] * v[425];
	v[424] = -(v[218] * v[403]);
	v[448] = -v[424] + v[412] * v[446];
	v[493] = QAi[0][2] * v[444] + QAi[1][2] * v[448] + QAi[2][2] * v[454];
	v[490] = QAi[0][1] * v[444] + QAi[1][1] * v[448] + QAi[2][1] * v[454];
	v[487] = QAi[0][0] * v[444] + QAi[1][0] * v[448] + QAi[2][0] * v[454];
	v[508] = GAp[0] * v[487] + GAp[1] * v[490] + GAp[2] * v[493];
	v[443] = -v[424] - v[411] * v[442];
	v[492] = QAi[0][2] * v[443] + QAi[1][2] * v[447] + QAi[2][2] * v[452];
	v[489] = QAi[0][1] * v[443] + QAi[1][1] * v[447] + QAi[2][1] * v[452];
	v[486] = QAi[0][0] * v[443] + QAi[1][0] * v[447] + QAi[2][0] * v[452];
	v[507] = GAp[0] * v[486] + GAp[1] * v[489] + GAp[2] * v[492];
	v[440] = -v[424] + v[412] * v[438];
	v[426] = -v[424] - v[411] * v[425];
	v[423] = -v[218] - v[413] * v[419];
	v[421] = -(v[218] * v[401]);
	v[445] = -v[421] - v[413] * v[442];
	v[431] = -v[421] + v[412] * v[429];
	v[478] = QAi[0][2] * v[431] + QAi[1][2] * v[435] + QAi[2][2] * v[440];
	v[475] = QAi[0][1] * v[431] + QAi[1][1] * v[435] + QAi[2][1] * v[440];
	v[472] = QAi[0][0] * v[431] + QAi[1][0] * v[435] + QAi[2][0] * v[440];
	v[505] = GAp[0] * v[472] + GAp[1] * v[475] + GAp[2] * v[478];
	v[428] = -v[421] - v[413] * v[425];
	v[422] = v[412] * v[419] - v[421];
	v[418] = v[218] * v[400];
	v[449] = v[418] - v[413] * v[446];
	v[494] = QAi[0][2] * v[445] + QAi[1][2] * v[449] + QAi[2][2] * v[455];
	v[491] = QAi[0][1] * v[445] + QAi[1][1] * v[449] + QAi[2][1] * v[455];
	v[488] = QAi[0][0] * v[445] + QAi[1][0] * v[449] + QAi[2][0] * v[455];
	v[509] = GAp[0] * v[488] + GAp[1] * v[491] + GAp[2] * v[494];
	v[441] = v[418] - v[413] * v[438];
	v[479] = QAi[0][2] * v[432] + QAi[1][2] * v[437] + QAi[2][2] * v[441];
	v[476] = QAi[0][1] * v[432] + QAi[1][1] * v[437] + QAi[2][1] * v[441];
	v[473] = QAi[0][0] * v[432] + QAi[1][0] * v[437] + QAi[2][0] * v[441];
	v[506] = GAp[0] * v[473] + GAp[1] * v[476] + GAp[2] * v[479];
	v[430] = v[418] - v[411] * v[429];
	v[477] = QAi[0][2] * v[430] + QAi[1][2] * v[434] + QAi[2][2] * v[439];
	v[474] = QAi[0][1] * v[430] + QAi[1][1] * v[434] + QAi[2][1] * v[439];
	v[471] = QAi[0][0] * v[430] + QAi[1][0] * v[434] + QAi[2][0] * v[439];
	v[504] = GAp[0] * v[471] + GAp[1] * v[474] + GAp[2] * v[477];
	v[420] = v[418] - v[411] * v[419];
	v[462] = QAi[0][2] * v[415] + QAi[1][2] * v[420] + QAi[2][2] * v[426];
	v[459] = QAi[0][1] * v[415] + QAi[1][1] * v[420] + QAi[2][1] * v[426];
	v[456] = QAi[0][0] * v[415] + QAi[1][0] * v[420] + QAi[2][0] * v[426];
	v[501] = GAp[0] * v[456] + GAp[1] * v[459] + GAp[2] * v[462];
	v[417] = -(v[413] * v[414]) / 2e0 + v[436];
	v[464] = QAi[0][2] * v[417] + QAi[1][2] * v[423] + QAi[2][2] * v[428];
	v[461] = QAi[0][1] * v[417] + QAi[1][1] * v[423] + QAi[2][1] * v[428];
	v[458] = QAi[0][0] * v[417] + QAi[1][0] * v[423] + QAi[2][0] * v[428];
	v[503] = GAp[0] * v[458] + GAp[1] * v[461] + GAp[2] * v[464];
	v[416] = (v[412] * v[414]) / 2e0 + v[453];
	v[463] = QAi[0][2] * v[416] + QAi[1][2] * v[422] + QAi[2][2] * v[427];
	v[460] = QAi[0][1] * v[416] + QAi[1][1] * v[422] + QAi[2][1] * v[427];
	v[457] = QAi[0][0] * v[416] + QAi[1][0] * v[422] + QAi[2][0] * v[427];
	v[502] = GAp[0] * v[457] + GAp[1] * v[460] + GAp[2] * v[463];
	v[307] = (v[218] * v[218]);
	v[3354] = 1e0 / Power(v[307], 3);
	v[2831] = v[318] / v[307];
	v[2830] = v[316] / v[307];
	v[2829] = v[310] / v[307];
	v[221] = 1e0 + (v[218] * v[414]) / 2e0;
	v[1333] = v[221] * v[2829];
	v[222] = v[218] * v[419];
	v[1335] = v[222] * v[2830];
	v[1891] = v[1333] + v[1335];
	v[223] = v[218] * v[425];
	v[3152] = v[223] / v[307];
	v[1336] = v[223] * v[2831];
	v[1895] = v[1336] + v[1891];
	v[1886] = v[1333] + v[1336];
	v[225] = v[218] * v[429];
	v[1340] = v[225] * v[2829];
	v[227] = 1e0 + (v[218] * v[433]) / 2e0;
	v[1329] = v[227] * v[2830];
	v[1897] = v[1329] + v[1340];
	v[228] = v[218] * v[438];
	v[3153] = v[228] / v[307];
	v[1330] = v[228] * v[2831];
	v[1890] = v[1330] + v[1897];
	v[1887] = v[1329] + v[1330];
	v[230] = v[218] * v[442];
	v[1343] = v[230] * v[2829];
	v[232] = v[218] * v[446];
	v[3154] = v[232] / v[307];
	v[1325] = v[232] * v[2830];
	v[233] = 1e0 + (v[218] * v[451]) / 2e0;
	v[1326] = v[233] * v[2831];
	v[1896] = v[1326] + v[1343];
	v[1892] = v[1325] + v[1326];
	v[1885] = v[1325] + v[1896];
	v[325] = -(v[418] * v[424]);
	v[2839] = v[325] - v[411];
	v[323] = v[421] * v[424];
	v[2837] = v[323] - v[412];
	v[314] = -(v[418] * v[421]);
	v[2835] = v[314] - v[413];
	v[237] = QAi[0][0] * v[221] + QAi[1][0] * v[222] + QAi[2][0] * v[223];
	v[238] = QAi[0][1] * v[221] + QAi[1][1] * v[222] + QAi[2][1] * v[223];
	v[239] = QAi[0][2] * v[221] + QAi[1][2] * v[222] + QAi[2][2] * v[223];
	v[387] = dGAp[0][1] * v[237] + dGAp[1][1] * v[238] + dGAp[2][1] * v[239];
	v[383] = dGAp[0][0] * v[237] + dGAp[1][0] * v[238] + dGAp[2][0] * v[239];
	v[240] = QAi[0][0] * v[225] + QAi[1][0] * v[227] + QAi[2][0] * v[228];
	v[241] = QAi[0][1] * v[225] + QAi[1][1] * v[227] + QAi[2][1] * v[228];
	v[242] = QAi[0][2] * v[225] + QAi[1][2] * v[227] + QAi[2][2] * v[228];
	v[388] = dGAp[0][1] * v[240] + dGAp[1][1] * v[241] + dGAp[2][1] * v[242];
	v[384] = dGAp[0][0] * v[240] + dGAp[1][0] * v[241] + dGAp[2][0] * v[242];
	v[243] = QAi[0][0] * v[230] + QAi[1][0] * v[232] + QAi[2][0] * v[233];
	v[244] = QAi[0][1] * v[230] + QAi[1][1] * v[232] + QAi[2][1] * v[233];
	v[245] = QAi[0][2] * v[230] + QAi[1][2] * v[232] + QAi[2][2] * v[233];
	v[389] = dGAp[0][1] * v[243] + dGAp[1][1] * v[244] + dGAp[2][1] * v[245];
	v[385] = dGAp[0][0] * v[243] + dGAp[1][0] * v[244] + dGAp[2][0] * v[245];
	v[258] = 4e0 / v[1085];
	v[3103] = -v[258] / 2e0;
	v[552] = -(v[258] * v[408]) / 2e0;
	v[553] = (v[511] * v[550]) / 2e0 + v[552];
	v[549] = -(v[258] * v[405]) / 2e0;
	v[551] = v[549] - (v[510] * v[550]) / 2e0;
	v[546] = v[258] - v[510] * v[545];
	v[543] = -v[258] + v[511] * v[541];
	v[538] = -v[258] - v[510] * v[537];
	v[535] = -(v[258] * v[410]) / 2e0;
	v[536] = -(v[512] * v[532]) / 2e0 + v[535];
	v[533] = -(v[510] * v[532]) / 2e0 + v[549];
	v[531] = v[258] - v[512] * v[528];
	v[526] = v[258] + v[511] * v[524];
	v[523] = -(v[258] * v[409]);
	v[547] = -v[523] + v[511] * v[545];
	v[592] = QBi[0][2] * v[543] + QBi[1][2] * v[547] + QBi[2][2] * v[553];
	v[589] = QBi[0][1] * v[543] + QBi[1][1] * v[547] + QBi[2][1] * v[553];
	v[586] = QBi[0][0] * v[543] + QBi[1][0] * v[547] + QBi[2][0] * v[553];
	v[607] = GBp[0] * v[586] + GBp[1] * v[589] + GBp[2] * v[592];
	v[542] = -v[523] - v[510] * v[541];
	v[591] = QBi[0][2] * v[542] + QBi[1][2] * v[546] + QBi[2][2] * v[551];
	v[588] = QBi[0][1] * v[542] + QBi[1][1] * v[546] + QBi[2][1] * v[551];
	v[585] = QBi[0][0] * v[542] + QBi[1][0] * v[546] + QBi[2][0] * v[551];
	v[606] = GBp[0] * v[585] + GBp[1] * v[588] + GBp[2] * v[591];
	v[539] = -v[523] + v[511] * v[537];
	v[525] = -v[523] - v[510] * v[524];
	v[522] = -v[258] - v[512] * v[518];
	v[520] = -(v[258] * v[407]);
	v[544] = -v[520] - v[512] * v[541];
	v[530] = -v[520] + v[511] * v[528];
	v[577] = QBi[0][2] * v[530] + QBi[1][2] * v[534] + QBi[2][2] * v[539];
	v[574] = QBi[0][1] * v[530] + QBi[1][1] * v[534] + QBi[2][1] * v[539];
	v[571] = QBi[0][0] * v[530] + QBi[1][0] * v[534] + QBi[2][0] * v[539];
	v[604] = GBp[0] * v[571] + GBp[1] * v[574] + GBp[2] * v[577];
	v[527] = -v[520] - v[512] * v[524];
	v[521] = v[511] * v[518] - v[520];
	v[517] = v[258] * v[406];
	v[548] = v[517] - v[512] * v[545];
	v[593] = QBi[0][2] * v[544] + QBi[1][2] * v[548] + QBi[2][2] * v[554];
	v[590] = QBi[0][1] * v[544] + QBi[1][1] * v[548] + QBi[2][1] * v[554];
	v[587] = QBi[0][0] * v[544] + QBi[1][0] * v[548] + QBi[2][0] * v[554];
	v[608] = GBp[0] * v[587] + GBp[1] * v[590] + GBp[2] * v[593];
	v[540] = v[517] - v[512] * v[537];
	v[578] = QBi[0][2] * v[531] + QBi[1][2] * v[536] + QBi[2][2] * v[540];
	v[575] = QBi[0][1] * v[531] + QBi[1][1] * v[536] + QBi[2][1] * v[540];
	v[572] = QBi[0][0] * v[531] + QBi[1][0] * v[536] + QBi[2][0] * v[540];
	v[605] = GBp[0] * v[572] + GBp[1] * v[575] + GBp[2] * v[578];
	v[529] = v[517] - v[510] * v[528];
	v[576] = QBi[0][2] * v[529] + QBi[1][2] * v[533] + QBi[2][2] * v[538];
	v[573] = QBi[0][1] * v[529] + QBi[1][1] * v[533] + QBi[2][1] * v[538];
	v[570] = QBi[0][0] * v[529] + QBi[1][0] * v[533] + QBi[2][0] * v[538];
	v[603] = GBp[0] * v[570] + GBp[1] * v[573] + GBp[2] * v[576];
	v[519] = v[517] - v[510] * v[518];
	v[561] = QBi[0][2] * v[514] + QBi[1][2] * v[519] + QBi[2][2] * v[525];
	v[558] = QBi[0][1] * v[514] + QBi[1][1] * v[519] + QBi[2][1] * v[525];
	v[555] = QBi[0][0] * v[514] + QBi[1][0] * v[519] + QBi[2][0] * v[525];
	v[600] = GBp[0] * v[555] + GBp[1] * v[558] + GBp[2] * v[561];
	v[618] = -(v[387] * v[600]) - v[388] * v[603] - v[389] * v[606];
	v[612] = -(v[383] * v[600]) - v[384] * v[603] - v[385] * v[606];
	v[516] = -(v[512] * v[513]) / 2e0 + v[535];
	v[563] = QBi[0][2] * v[516] + QBi[1][2] * v[522] + QBi[2][2] * v[527];
	v[560] = QBi[0][1] * v[516] + QBi[1][1] * v[522] + QBi[2][1] * v[527];
	v[557] = QBi[0][0] * v[516] + QBi[1][0] * v[522] + QBi[2][0] * v[527];
	v[602] = GBp[0] * v[557] + GBp[1] * v[560] + GBp[2] * v[563];
	v[620] = -(v[387] * v[602]) - v[388] * v[605] - v[389] * v[608];
	v[614] = -(v[383] * v[602]) - v[384] * v[605] - v[385] * v[608];
	v[515] = (v[511] * v[513]) / 2e0 + v[552];
	v[562] = QBi[0][2] * v[515] + QBi[1][2] * v[521] + QBi[2][2] * v[526];
	v[559] = QBi[0][1] * v[515] + QBi[1][1] * v[521] + QBi[2][1] * v[526];
	v[556] = QBi[0][0] * v[515] + QBi[1][0] * v[521] + QBi[2][0] * v[526];
	v[601] = GBp[0] * v[556] + GBp[1] * v[559] + GBp[2] * v[562];
	v[619] = -(v[387] * v[601]) - v[388] * v[604] - v[389] * v[607];
	v[613] = -(v[383] * v[601]) - v[384] * v[604] - v[385] * v[607];
	v[333] = (v[258] * v[258]);
	v[3348] = 1e0 / Power(v[333], 3);
	v[2834] = v[344] / v[333];
	v[2833] = v[342] / v[333];
	v[2832] = v[336] / v[333];
	v[261] = 1e0 + (v[258] * v[513]) / 2e0;
	v[1309] = v[261] * v[2832];
	v[262] = v[258] * v[518];
	v[1311] = v[262] * v[2833];
	v[1876] = v[1309] + v[1311];
	v[263] = v[258] * v[524];
	v[3149] = v[263] / v[333];
	v[1312] = v[263] * v[2834];
	v[1880] = v[1312] + v[1876];
	v[1871] = v[1309] + v[1312];
	v[265] = v[258] * v[528];
	v[1316] = v[265] * v[2832];
	v[267] = 1e0 + (v[258] * v[532]) / 2e0;
	v[1305] = v[267] * v[2833];
	v[1882] = v[1305] + v[1316];
	v[268] = v[258] * v[537];
	v[3150] = v[268] / v[333];
	v[1306] = v[268] * v[2834];
	v[1875] = v[1306] + v[1882];
	v[1872] = v[1305] + v[1306];
	v[270] = v[258] * v[541];
	v[1319] = v[270] * v[2832];
	v[272] = v[258] * v[545];
	v[3151] = v[272] / v[333];
	v[1301] = v[272] * v[2833];
	v[273] = 1e0 + (v[258] * v[550]) / 2e0;
	v[1302] = v[273] * v[2834];
	v[1881] = v[1302] + v[1319];
	v[1877] = v[1301] + v[1302];
	v[1870] = v[1301] + v[1881];
	v[351] = -(v[517] * v[523]);
	v[2844] = v[351] - v[510];
	v[349] = v[520] * v[523];
	v[2842] = v[349] - v[511];
	v[340] = -(v[517] * v[520]);
	v[2840] = v[340] - v[512];
	v[277] = QBi[0][0] * v[261] + QBi[1][0] * v[262] + QBi[2][0] * v[263];
	v[278] = QBi[0][1] * v[261] + QBi[1][1] * v[262] + QBi[2][1] * v[263];
	v[279] = QBi[0][2] * v[261] + QBi[1][2] * v[262] + QBi[2][2] * v[263];
	v[395] = dGBp[0][1] * v[277] + dGBp[1][1] * v[278] + dGBp[2][1] * v[279];
	v[391] = dGBp[0][0] * v[277] + dGBp[1][0] * v[278] + dGBp[2][0] * v[279];
	v[700] = -(invH[3][0] * v[383]) - invH[3][1] * v[387] + invH[3][2] * v[391] + invH[3][3] * v[395];
	v[685] = -(invH[2][0] * v[383]) - invH[2][1] * v[387] + invH[2][2] * v[391] + invH[2][3] * v[395];
	v[670] = -(invH[1][0] * v[383]) - invH[1][1] * v[387] + invH[1][2] * v[391] + invH[1][3] * v[395];
	v[655] = -(invH[0][0] * v[383]) - invH[0][1] * v[387] + invH[0][2] * v[391] + invH[0][3] * v[395];
	v[280] = QBi[0][0] * v[265] + QBi[1][0] * v[267] + QBi[2][0] * v[268];
	v[281] = QBi[0][1] * v[265] + QBi[1][1] * v[267] + QBi[2][1] * v[268];
	v[282] = QBi[0][2] * v[265] + QBi[1][2] * v[267] + QBi[2][2] * v[268];
	v[396] = dGBp[0][1] * v[280] + dGBp[1][1] * v[281] + dGBp[2][1] * v[282];
	v[392] = dGBp[0][0] * v[280] + dGBp[1][0] * v[281] + dGBp[2][0] * v[282];
	v[702] = -(invH[3][0] * v[384]) - invH[3][1] * v[388] + invH[3][2] * v[392] + invH[3][3] * v[396];
	v[687] = -(invH[2][0] * v[384]) - invH[2][1] * v[388] + invH[2][2] * v[392] + invH[2][3] * v[396];
	v[672] = -(invH[1][0] * v[384]) - invH[1][1] * v[388] + invH[1][2] * v[392] + invH[1][3] * v[396];
	v[657] = -(invH[0][0] * v[384]) - invH[0][1] * v[388] + invH[0][2] * v[392] + invH[0][3] * v[396];
	v[283] = QBi[0][0] * v[270] + QBi[1][0] * v[272] + QBi[2][0] * v[273];
	v[284] = QBi[0][1] * v[270] + QBi[1][1] * v[272] + QBi[2][1] * v[273];
	v[285] = QBi[0][2] * v[270] + QBi[1][2] * v[272] + QBi[2][2] * v[273];
	v[397] = dGBp[0][1] * v[283] + dGBp[1][1] * v[284] + dGBp[2][1] * v[285];
	v[629] = -(v[395] * v[503]) - v[396] * v[506] - v[397] * v[509];
	v[628] = -(v[395] * v[502]) - v[396] * v[505] - v[397] * v[508];
	v[627] = -(v[395] * v[501]) - v[396] * v[504] - v[397] * v[507];
	v[393] = dGBp[0][0] * v[283] + dGBp[1][0] * v[284] + dGBp[2][0] * v[285];
	v[704] = -(invH[3][0] * v[385]) - invH[3][1] * v[389] + invH[3][2] * v[393] + invH[3][3] * v[397];
	v[689] = -(invH[2][0] * v[385]) - invH[2][1] * v[389] + invH[2][2] * v[393] + invH[2][3] * v[397];
	v[674] = -(invH[1][0] * v[385]) - invH[1][1] * v[389] + invH[1][2] * v[393] + invH[1][3] * v[397];
	v[659] = -(invH[0][0] * v[385]) - invH[0][1] * v[389] + invH[0][2] * v[393] + invH[0][3] * v[397];
	v[623] = -(v[391] * v[503]) - v[392] * v[506] - v[393] * v[509];
	v[622] = -(v[391] * v[502]) - v[392] * v[505] - v[393] * v[508];
	v[621] = -(v[391] * v[501]) - v[392] * v[504] - v[393] * v[507];
	v[2891] = uA[0] - uB[0] + xAi[0] - xBi[0];
	v[2890] = uA[1] - uB[1] + xAi[1] - xBi[1];
	v[2889] = uA[2] - uB[2] + xAi[2] - xBi[2];
	v[298] = (*a6)*dduiA[0] + (*a5)*duiA[0] + (*a4)*uA[0];
	v[299] = (*a6)*dduiA[1] + (*a5)*duiA[1] + (*a4)*uA[1];
	v[300] = (*a6)*dduiA[2] + (*a5)*duiA[2] + (*a4)*uA[2];
	v[301] = (*a6)*dduiB[0] + (*a5)*duiB[0] + (*a4)*uB[0];
	v[2885] = -v[298] + v[301];
	v[302] = (*a6)*dduiB[1] + (*a5)*duiB[1] + (*a4)*uB[1];
	v[2886] = -v[299] + v[302];
	v[303] = (*a6)*dduiB[2] + (*a5)*duiB[2] + (*a4)*uB[2];
	v[2887] = -v[300] + v[303];
	v[305] = v[323] + v[412];
	v[3095] = v[233] * v[305];
	v[2838] = v[305] / v[307];
	v[306] = v[314] + v[413];
	v[3091] = v[227] * v[306];
	v[2836] = v[306] / v[307];
	v[308] = v[307] + (v[421] * v[421]);
	v[2406] = v[308] / v[307];
	v[1509] = v[2837] / v[307];
	v[1507] = v[2835] / v[307];
	v[5160] = 0e0;
	v[5161] = 0e0;
	v[5162] = 0e0;
	v[5163] = 0e0;
	v[5164] = v[1507];
	v[5165] = v[1509];
	v[5166] = 0e0;
	v[5167] = 0e0;
	v[5168] = 0e0;
	v[5169] = 0e0;
	v[5170] = 0e0;
	v[5171] = 0e0;
	v[309] = v[2406] * v[310] + v[1507] * v[316] + v[1509] * v[318];
	v[311] = v[307] + (v[418] * v[418]);
	v[3094] = v[228] * v[311];
	v[3093] = v[225] * v[311];
	v[3089] = v[221] * v[2835];
	v[317] = v[325] + v[411];
	v[3096] = v[233] * v[317];
	v[2407] = v[311] / v[307];
	v[1508] = v[2839] / v[307];
	v[5148] = 0e0;
	v[5149] = 0e0;
	v[5150] = 0e0;
	v[5151] = v[2836];
	v[5152] = 0e0;
	v[5153] = v[1508];
	v[5154] = 0e0;
	v[5155] = 0e0;
	v[5156] = 0e0;
	v[5157] = 0e0;
	v[5158] = 0e0;
	v[5159] = 0e0;
	v[319] = v[2836] * v[310] + v[2407] * v[316] + v[1508] * v[318];
	v[320] = v[307] + (v[424] * v[424]);
	v[3088] = v[232] * v[320];
	v[3087] = v[230] * v[320];
	v[3090] = v[221] * v[2837];
	v[3092] = v[227] * v[2839];
	v[2408] = v[320] / v[307];
	v[1506] = v[317] / v[307];
	v[5136] = 0e0;
	v[5137] = 0e0;
	v[5138] = 0e0;
	v[5139] = v[2838];
	v[5140] = v[1506];
	v[5141] = 0e0;
	v[5142] = 0e0;
	v[5143] = 0e0;
	v[5144] = 0e0;
	v[5145] = 0e0;
	v[5146] = 0e0;
	v[5147] = 0e0;
	v[329] = v[2838] * v[310] + v[1506] * v[316] + v[2408] * v[318];
	v[331] = v[349] + v[511];
	v[3082] = v[273] * v[331];
	v[2843] = v[331] / v[333];
	v[332] = v[340] + v[512];
	v[3078] = v[267] * v[332];
	v[2841] = v[332] / v[333];
	v[334] = v[333] + (v[520] * v[520]);
	v[2409] = v[334] / v[333];
	v[1515] = v[2842] / v[333];
	v[1513] = v[2840] / v[333];
	v[5124] = 0e0;
	v[5125] = 0e0;
	v[5126] = 0e0;
	v[5127] = 0e0;
	v[5128] = 0e0;
	v[5129] = 0e0;
	v[5130] = 0e0;
	v[5131] = 0e0;
	v[5132] = 0e0;
	v[5133] = 0e0;
	v[5134] = v[1513];
	v[5135] = v[1515];
	v[335] = v[2409] * v[336] + v[1513] * v[342] + v[1515] * v[344];
	v[337] = v[333] + (v[517] * v[517]);
	v[3081] = v[268] * v[337];
	v[3080] = v[265] * v[337];
	v[3076] = v[261] * v[2840];
	v[343] = v[351] + v[510];
	v[3083] = v[273] * v[343];
	v[2410] = v[337] / v[333];
	v[1514] = v[2844] / v[333];
	v[5112] = 0e0;
	v[5113] = 0e0;
	v[5114] = 0e0;
	v[5115] = 0e0;
	v[5116] = 0e0;
	v[5117] = 0e0;
	v[5118] = 0e0;
	v[5119] = 0e0;
	v[5120] = 0e0;
	v[5121] = v[2841];
	v[5122] = 0e0;
	v[5123] = v[1514];
	v[345] = v[2841] * v[336] + v[2410] * v[342] + v[1514] * v[344];
	v[346] = v[333] + (v[523] * v[523]);
	v[3075] = v[272] * v[346];
	v[3074] = v[270] * v[346];
	v[3077] = v[261] * v[2842];
	v[3079] = v[267] * v[2844];
	v[2411] = v[346] / v[333];
	v[1512] = v[343] / v[333];
	v[5100] = 0e0;
	v[5101] = 0e0;
	v[5102] = 0e0;
	v[5103] = 0e0;
	v[5104] = 0e0;
	v[5105] = 0e0;
	v[5106] = 0e0;
	v[5107] = 0e0;
	v[5108] = 0e0;
	v[5109] = v[2843];
	v[5110] = v[1512];
	v[5111] = 0e0;
	v[355] = v[2843] * v[336] + v[1512] * v[342] + v[2411] * v[344];
	v[2577] = v[298] - v[301] + v[309] * v[501] + v[319] * v[502] + v[329] * v[503] - v[335] * v[600] - v[345] * v[601]
		- v[355] * v[602];
	v[2567] = v[299] - v[302] + v[309] * v[504] + v[319] * v[505] + v[329] * v[506] - v[335] * v[603] - v[345] * v[604]
		- v[355] * v[605];
	v[2565] = v[300] - v[303] + v[309] * v[507] + v[319] * v[508] + v[329] * v[509] - v[335] * v[606] - v[345] * v[607]
		- v[355] * v[608];
	v[356] = GAp[0] * v[237] + GAp[1] * v[238] + GAp[2] * v[239] - GBp[0] * v[277] - GBp[1] * v[278] - GBp[2] * v[279] + v[2891];
	v[2850] = dGAp[2][0] * v[356];
	v[2845] = dGAp[2][1] * v[356];
	v[357] = GAp[0] * v[240] + GAp[1] * v[241] + GAp[2] * v[242] - GBp[0] * v[280] - GBp[1] * v[281] - GBp[2] * v[282] + v[2890];
	v[2851] = dGAp[2][0] * v[357];
	v[2846] = dGAp[2][1] * v[357];
	v[358] = GAp[0] * v[243] + GAp[1] * v[244] + GAp[2] * v[245] - GBp[0] * v[283] - GBp[1] * v[284] - GBp[2] * v[285] + v[2889];
	v[2856] = v[356] * v[459] + v[357] * v[474] + v[358] * v[489];
	v[2855] = v[356] * v[456] + v[357] * v[471] + v[358] * v[486];
	v[2854] = dGAp[2][0] * v[358];
	v[2853] = v[356] * v[460] + v[357] * v[475] + v[358] * v[490];
	v[2852] = v[356] * v[457] + v[357] * v[472] + v[358] * v[487];
	v[2849] = v[356] * v[461] + v[357] * v[476] + v[358] * v[491];
	v[2848] = v[356] * v[458] + v[357] * v[473] + v[358] * v[488];
	v[2847] = dGAp[2][1] * v[358];
	v[1293] = sqrt((v[356] * v[356]) + (v[357] * v[357]) + (v[358] * v[358]));
	v[2125] = 1e0 / Power(v[1293], 2);
	v[632] = -(v[356] * (dGBp[0][1] * v[557] + dGBp[1][1] * v[560] + dGBp[2][1] * v[563])) - v[357] * (dGBp[0][1] * v[572]
		+ dGBp[1][1] * v[575] + dGBp[2][1] * v[578]) - v[358] * (dGBp[0][1] * v[587] + dGBp[1][1] * v[590] + dGBp[2][1] * v[593]
			) + v[395] * v[602] + v[396] * v[605] + v[397] * v[608];
	v[631] = -(v[356] * (dGBp[0][1] * v[556] + dGBp[1][1] * v[559] + dGBp[2][1] * v[562])) - v[357] * (dGBp[0][1] * v[571]
		+ dGBp[1][1] * v[574] + dGBp[2][1] * v[577]) - v[358] * (dGBp[0][1] * v[586] + dGBp[1][1] * v[589] + dGBp[2][1] * v[592]
			) + v[395] * v[601] + v[396] * v[604] + v[397] * v[607];
	v[630] = -(v[356] * (dGBp[0][1] * v[555] + dGBp[1][1] * v[558] + dGBp[2][1] * v[561])) - v[357] * (dGBp[0][1] * v[570]
		+ dGBp[1][1] * v[573] + dGBp[2][1] * v[576]) - v[358] * (dGBp[0][1] * v[585] + dGBp[1][1] * v[588] + dGBp[2][1] * v[591]
			) + v[395] * v[600] + v[396] * v[603] + v[397] * v[606];
	v[626] = -(v[356] * (dGBp[0][0] * v[557] + dGBp[1][0] * v[560] + dGBp[2][0] * v[563])) - v[357] * (dGBp[0][0] * v[572]
		+ dGBp[1][0] * v[575] + dGBp[2][0] * v[578]) - v[358] * (dGBp[0][0] * v[587] + dGBp[1][0] * v[590] + dGBp[2][0] * v[593]
			) + v[391] * v[602] + v[392] * v[605] + v[393] * v[608];
	v[625] = -(v[356] * (dGBp[0][0] * v[556] + dGBp[1][0] * v[559] + dGBp[2][0] * v[562])) - v[357] * (dGBp[0][0] * v[571]
		+ dGBp[1][0] * v[574] + dGBp[2][0] * v[577]) - v[358] * (dGBp[0][0] * v[586] + dGBp[1][0] * v[589] + dGBp[2][0] * v[592]
			) + v[391] * v[601] + v[392] * v[604] + v[393] * v[607];
	v[624] = -(v[356] * (dGBp[0][0] * v[555] + dGBp[1][0] * v[558] + dGBp[2][0] * v[561])) - v[357] * (dGBp[0][0] * v[570]
		+ dGBp[1][0] * v[573] + dGBp[2][0] * v[576]) - v[358] * (dGBp[0][0] * v[585] + dGBp[1][0] * v[588] + dGBp[2][0] * v[591]
			) + v[391] * v[600] + v[392] * v[603] + v[393] * v[606];
	v[617] = dGAp[0][1] * v[2848] + dGAp[1][1] * v[2849] + v[2845] * v[464] + v[2846] * v[479] + v[2847] * v[494]
		+ v[387] * v[503] + v[388] * v[506] + v[389] * v[509];
	v[616] = dGAp[0][1] * v[2852] + dGAp[1][1] * v[2853] + v[2845] * v[463] + v[2846] * v[478] + v[2847] * v[493]
		+ v[387] * v[502] + v[388] * v[505] + v[389] * v[508];
	v[615] = dGAp[0][1] * v[2855] + dGAp[1][1] * v[2856] + v[2845] * v[462] + v[2846] * v[477] + v[2847] * v[492]
		+ v[387] * v[501] + v[388] * v[504] + v[389] * v[507];
	v[611] = dGAp[0][0] * v[2848] + dGAp[1][0] * v[2849] + v[2850] * v[464] + v[2851] * v[479] + v[2854] * v[494]
		+ v[383] * v[503] + v[384] * v[506] + v[385] * v[509];
	v[610] = dGAp[0][0] * v[2852] + dGAp[1][0] * v[2853] + v[2850] * v[463] + v[2851] * v[478] + v[2854] * v[493]
		+ v[383] * v[502] + v[384] * v[505] + v[385] * v[508];
	v[609] = dGAp[0][0] * v[2855] + dGAp[1][0] * v[2856] + v[2850] * v[462] + v[2851] * v[477] + v[2854] * v[492]
		+ v[383] * v[501] + v[384] * v[504] + v[385] * v[507];
	v[359] = GAi[0] * QAi[0][0] + GAi[1] * QAi[0][1] + GAi[2] * QAi[0][2] - GBi[0] * QBi[0][0] - GBi[1] * QBi[0][1]
		- GBi[2] * QBi[0][2] + xAi[0] - xBi[0];
	v[360] = GAi[0] * QAi[1][0] + GAi[1] * QAi[1][1] + GAi[2] * QAi[1][2] - GBi[0] * QBi[1][0] - GBi[1] * QBi[1][1]
		- GBi[2] * QBi[1][2] + xAi[1] - xBi[1];
	v[361] = GAi[0] * QAi[2][0] + GAi[1] * QAi[2][1] + GAi[2] * QAi[2][2] - GBi[0] * QBi[2][0] - GBi[1] * QBi[2][1]
		- GBi[2] * QBi[2][2] + xAi[2] - xBi[2];
	if (v[1293] > 0.1e-7) { v01 = 1e0 / v[1293]; v02 = (-(v01 / v[1293])); v03 = (2e0*v01) / Power(v[1293], 2); }
	else {
		v01 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[1293])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[1293])*
			(0.2399999997e10 - 0.1199999994e18*v[1293] - 0.3e17*(v[1293] * v[1293]))));
		v02 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[1293] + 0.6e25*Power(v[1293], 3)
			+ 0.1799999982e26*(v[1293] * v[1293]));
		v03 = 0.1e17*(799999997e0 - 0.599999994e17*v[1293] - 0.3e17*(v[1293] * v[1293]));
	};
	v[368] = v03;
	v[369] = v02;
	v[370] = v01;
	v[371] = v[356] * v[370];
	v[2857] = -((*cn)*v[371]);
	v[2573] = v[2567] * v[371];
	v[2569] = v[2565] * v[371];
	v[2007] = -(v[371] * v[602]);
	v[2006] = -(v[371] * v[601]);
	v[2005] = -(v[371] * v[600]);
	v[2004] = v[371] * v[503];
	v[2003] = v[371] * v[502];
	v[2002] = v[371] * v[501];
	v[2872] = (v[298] - v[301])*v[371];
	v[749] = (v[371] * v[371]);
	v[372] = v[357] * v[370];
	v[2591] = v[2857] * v[372];
	v[2580] = v[2577] * v[372];
	v[2570] = v[2565] * v[372];
	v[2022] = -(v[372] * v[605]);
	v[2884] = v[2007] + v[2022];
	v[2020] = -(v[372] * v[604]);
	v[2883] = v[2006] + v[2020];
	v[2018] = -(v[372] * v[603]);
	v[2882] = v[2005] + v[2018];
	v[2016] = v[372] * v[506];
	v[2881] = v[2004] + v[2016];
	v[2014] = v[372] * v[505];
	v[2880] = v[2003] + v[2014];
	v[2012] = v[372] * v[504];
	v[2879] = v[2002] + v[2012];
	v[2864] = (v[299] - v[302])*v[372];
	v[2897] = v[2864] + v[2872];
	v[2571] = v[2897] + v[2879] * v[309] + v[2880] * v[319] + v[2881] * v[329] + v[2882] * v[335] + v[2883] * v[345]
		+ v[2884] * v[355];
	v[751] = (v[372] * v[372]);
	v[373] = v[358] * v[370];
	v[2863] = -(v[373] * v[608]);
	v[2878] = v[2007] + v[2863];
	v[2870] = -v[2022] - v[2863];
	v[2862] = -(v[373] * v[607]);
	v[2877] = v[2006] + v[2862];
	v[2869] = -v[2020] - v[2862];
	v[2861] = -(v[373] * v[606]);
	v[2876] = v[2005] + v[2861];
	v[2868] = -v[2018] - v[2861];
	v[2860] = v[373] * v[509];
	v[2875] = v[2004] + v[2860];
	v[2867] = v[2016] + v[2860];
	v[2859] = v[373] * v[508];
	v[2874] = v[2003] + v[2859];
	v[2866] = v[2014] + v[2859];
	v[2858] = v[373] * v[507];
	v[2873] = v[2002] + v[2858];
	v[2865] = v[2012] + v[2858];
	v[2589] = v[2857] * v[373];
	v[2581] = v[2577] * v[373];
	v[2575] = v[2567] * v[373];
	v[2043] = -((*cn)*v[372] * v[373]);
	v[2040] = v[2873] * v[372] + v[504] * v[751];
	v[2039] = v[2865] * v[371] + v[501] * v[749];
	v[2037] = v[2874] * v[372] + v[505] * v[751];
	v[2036] = v[2866] * v[371] + v[502] * v[749];
	v[2034] = v[2875] * v[372] + v[506] * v[751];
	v[2033] = v[2867] * v[371] + v[503] * v[749];
	v[2031] = v[2876] * v[372] - v[603] * v[751];
	v[2030] = -(v[2868] * v[371]) - v[600] * v[749];
	v[2028] = v[2877] * v[372] - v[604] * v[751];
	v[2027] = -(v[2869] * v[371]) - v[601] * v[749];
	v[2025] = v[2878] * v[372] - v[605] * v[751];
	v[2024] = -(v[2870] * v[371]) - v[602] * v[749];
	v[2871] = (v[300] - v[303])*v[373];
	v[2896] = v[2871] + v[2872];
	v[2895] = v[2864] + v[2871];
	v[2579] = v[2895] + v[2865] * v[309] + v[2866] * v[319] + v[2867] * v[329] - v[2868] * v[335] - v[2869] * v[345]
		- v[2870] * v[355];
	v[2574] = v[2896] + v[2873] * v[309] + v[2874] * v[319] + v[2875] * v[329] + v[2876] * v[335] + v[2877] * v[345]
		+ v[2878] * v[355];
	v[753] = (v[373] * v[373]);
	v[2041] = v[2879] * v[373] + v[507] * v[753];
	v[2038] = v[2880] * v[373] + v[508] * v[753];
	v[2035] = v[2881] * v[373] + v[509] * v[753];
	v[2032] = v[2882] * v[373] - v[606] * v[753];
	v[2029] = v[2883] * v[373] - v[607] * v[753];
	v[2026] = v[2884] * v[373] - v[608] * v[753];
	v[374] = sqrt((v[359] * v[359]) + (v[360] * v[360]) + (v[361] * v[361]));
	if (v[374] > 0.1e-7) { v04 = 1e0 / v[374]; v05 = (-(v04 / v[374])); v06 = (2e0*v04) / Power(v[374], 2); }
	else {
		v04 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[374])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[374])*(0.2399999997e10
			- 0.1199999994e18*v[374] - 0.3e17*(v[374] * v[374]))));
		v05 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[374] + 0.6e25*Power(v[374], 3)
			+ 0.1799999982e26*(v[374] * v[374]));
		v06 = 0.1e17*(799999997e0 - 0.599999994e17*v[374] - 0.3e17*(v[374] * v[374]));
	};
	v[379] = v04;
	v[380] = v[359] * v[379];
	v[381] = v[360] * v[379];
	v[382] = v[361] * v[379];
	v[652] = -(invH[0][0] * v[609]) - invH[0][1] * v[615] - invH[0][2] * v[621] - invH[0][3] * v[627];
	v[653] = -(invH[0][0] * v[610]) - invH[0][1] * v[616] - invH[0][2] * v[622] - invH[0][3] * v[628];
	v[654] = -(invH[0][0] * v[611]) - invH[0][1] * v[617] - invH[0][2] * v[623] - invH[0][3] * v[629];
	v[661] = -(invH[0][0] * v[612]) - invH[0][1] * v[618] - invH[0][2] * v[624] - invH[0][3] * v[630];
	v[662] = -(invH[0][0] * v[613]) - invH[0][1] * v[619] - invH[0][2] * v[625] - invH[0][3] * v[631];
	v[663] = -(invH[0][0] * v[614]) - invH[0][1] * v[620] - invH[0][2] * v[626] - invH[0][3] * v[632];
	v[1166] = -(v[309] * v[652]) - v[319] * v[653] - v[329] * v[654] + v[2885] * v[655] + v[2886] * v[657] + v[2887] * v[659]
		- v[335] * v[661] - v[345] * v[662] - v[355] * v[663];
	v[4236] = v[655];
	v[4237] = v[657];
	v[4238] = v[659];
	v[4239] = v[652];
	v[4240] = v[653];
	v[4241] = v[654];
	v[4242] = -v[655];
	v[4243] = -v[657];
	v[4244] = -v[659];
	v[4245] = v[661];
	v[4246] = v[662];
	v[4247] = v[663];
	v[667] = -(invH[1][0] * v[609]) - invH[1][1] * v[615] - invH[1][2] * v[621] - invH[1][3] * v[627];
	v[668] = -(invH[1][0] * v[610]) - invH[1][1] * v[616] - invH[1][2] * v[622] - invH[1][3] * v[628];
	v[669] = -(invH[1][0] * v[611]) - invH[1][1] * v[617] - invH[1][2] * v[623] - invH[1][3] * v[629];
	v[676] = -(invH[1][0] * v[612]) - invH[1][1] * v[618] - invH[1][2] * v[624] - invH[1][3] * v[630];
	v[677] = -(invH[1][0] * v[613]) - invH[1][1] * v[619] - invH[1][2] * v[625] - invH[1][3] * v[631];
	v[678] = -(invH[1][0] * v[614]) - invH[1][1] * v[620] - invH[1][2] * v[626] - invH[1][3] * v[632];
	v[1168] = -(v[309] * v[667]) - v[319] * v[668] - v[329] * v[669] + v[2885] * v[670] + v[2886] * v[672] + v[2887] * v[674]
		- v[335] * v[676] - v[345] * v[677] - v[355] * v[678];
	v[4248] = v[670];
	v[4249] = v[672];
	v[4250] = v[674];
	v[4251] = v[667];
	v[4252] = v[668];
	v[4253] = v[669];
	v[4254] = -v[670];
	v[4255] = -v[672];
	v[4256] = -v[674];
	v[4257] = v[676];
	v[4258] = v[677];
	v[4259] = v[678];
	v[682] = -(invH[2][0] * v[609]) - invH[2][1] * v[615] - invH[2][2] * v[621] - invH[2][3] * v[627];
	v[683] = -(invH[2][0] * v[610]) - invH[2][1] * v[616] - invH[2][2] * v[622] - invH[2][3] * v[628];
	v[684] = -(invH[2][0] * v[611]) - invH[2][1] * v[617] - invH[2][2] * v[623] - invH[2][3] * v[629];
	v[691] = -(invH[2][0] * v[612]) - invH[2][1] * v[618] - invH[2][2] * v[624] - invH[2][3] * v[630];
	v[692] = -(invH[2][0] * v[613]) - invH[2][1] * v[619] - invH[2][2] * v[625] - invH[2][3] * v[631];
	v[693] = -(invH[2][0] * v[614]) - invH[2][1] * v[620] - invH[2][2] * v[626] - invH[2][3] * v[632];
	v[1162] = v[309] * v[682] + v[319] * v[683] + v[329] * v[684] - v[2885] * v[685] - v[2886] * v[687] - v[2887] * v[689]
		+ v[335] * v[691] + v[345] * v[692] + v[355] * v[693];
	v[4224] = v[685];
	v[4225] = v[687];
	v[4226] = v[689];
	v[4227] = v[682];
	v[4228] = v[683];
	v[4229] = v[684];
	v[4230] = -v[685];
	v[4231] = -v[687];
	v[4232] = -v[689];
	v[4233] = v[691];
	v[4234] = v[692];
	v[4235] = v[693];
	v[1100] = v[385] * v[655] + v[389] * v[670] - v[393] * v[685] - v[397] * v[700];
	v[1099] = v[384] * v[655] + v[388] * v[670] - v[392] * v[685] - v[396] * v[700];
	v[1098] = v[383] * v[655] + v[387] * v[670] - v[391] * v[685] - v[395] * v[700];
	v[1104] = v[385] * v[657] + v[389] * v[672] - v[393] * v[687] - v[397] * v[702];
	v[1103] = v[384] * v[657] + v[388] * v[672] - v[392] * v[687] - v[396] * v[702];
	v[1102] = v[383] * v[657] + v[387] * v[672] - v[391] * v[687] - v[395] * v[702];
	v[1108] = v[385] * v[659] + v[389] * v[674] - v[393] * v[689] - v[397] * v[704];
	v[1107] = v[384] * v[659] + v[388] * v[674] - v[392] * v[689] - v[396] * v[704];
	v[1106] = v[383] * v[659] + v[387] * v[674] - v[391] * v[689] - v[395] * v[704];
	v[697] = -(invH[3][0] * v[609]) - invH[3][1] * v[615] - invH[3][2] * v[621] - invH[3][3] * v[627];
	v[1112] = v[385] * v[652] + v[389] * v[667] - v[393] * v[682] - v[397] * v[697];
	v[1111] = v[384] * v[652] + v[388] * v[667] - v[392] * v[682] - v[396] * v[697];
	v[1110] = v[383] * v[652] + v[387] * v[667] - v[391] * v[682] - v[395] * v[697];
	v[698] = -(invH[3][0] * v[610]) - invH[3][1] * v[616] - invH[3][2] * v[622] - invH[3][3] * v[628];
	v[1116] = v[385] * v[653] + v[389] * v[668] - v[393] * v[683] - v[397] * v[698];
	v[1115] = v[384] * v[653] + v[388] * v[668] - v[392] * v[683] - v[396] * v[698];
	v[1114] = v[383] * v[653] + v[387] * v[668] - v[391] * v[683] - v[395] * v[698];
	v[699] = -(invH[3][0] * v[611]) - invH[3][1] * v[617] - invH[3][2] * v[623] - invH[3][3] * v[629];
	v[1120] = v[385] * v[654] + v[389] * v[669] - v[393] * v[684] - v[397] * v[699];
	v[1119] = v[384] * v[654] + v[388] * v[669] - v[392] * v[684] - v[396] * v[699];
	v[1118] = v[383] * v[654] + v[387] * v[669] - v[391] * v[684] - v[395] * v[699];
	v[706] = -(invH[3][0] * v[612]) - invH[3][1] * v[618] - invH[3][2] * v[624] - invH[3][3] * v[630];
	v[1136] = v[385] * v[661] + v[389] * v[676] - v[393] * v[691] - v[397] * v[706];
	v[1135] = v[384] * v[661] + v[388] * v[676] - v[392] * v[691] - v[396] * v[706];
	v[1134] = v[383] * v[661] + v[387] * v[676] - v[391] * v[691] - v[395] * v[706];
	v[707] = -(invH[3][0] * v[613]) - invH[3][1] * v[619] - invH[3][2] * v[625] - invH[3][3] * v[631];
	v[1140] = v[385] * v[662] + v[389] * v[677] - v[393] * v[692] - v[397] * v[707];
	v[1139] = v[384] * v[662] + v[388] * v[677] - v[392] * v[692] - v[396] * v[707];
	v[1138] = v[383] * v[662] + v[387] * v[677] - v[391] * v[692] - v[395] * v[707];
	v[708] = -(invH[3][0] * v[614]) - invH[3][1] * v[620] - invH[3][2] * v[626] - invH[3][3] * v[632];
	v[1164] = v[309] * v[697] + v[319] * v[698] + v[329] * v[699] - v[2885] * v[700] - v[2886] * v[702] - v[2887] * v[704]
		+ v[335] * v[706] + v[345] * v[707] + v[355] * v[708];
	v[1144] = v[385] * v[663] + v[389] * v[678] - v[393] * v[693] - v[397] * v[708];
	v[1143] = v[384] * v[663] + v[388] * v[678] - v[392] * v[693] - v[396] * v[708];
	v[1142] = v[383] * v[663] + v[387] * v[678] - v[391] * v[693] - v[395] * v[708];
	v[4212] = v[700];
	v[4213] = v[702];
	v[4214] = v[704];
	v[4215] = v[697];
	v[4216] = v[698];
	v[4217] = v[699];
	v[4218] = -v[700];
	v[4219] = -v[702];
	v[4220] = -v[704];
	v[4221] = v[706];
	v[4222] = v[707];
	v[4223] = v[708];
	b709 = sqrt(Power(v[372] * v[380] - v[371] * v[381], 2) + Power(-(v[373] * v[380]) + v[371] * v[382], 2) + Power
	(v[373] * v[381] - v[372] * v[382], 2)) > 0.1e-7;
	if (b709) {
		v[711] = v[373] * v[381] - v[372] * v[382];
		v[712] = -(v[373] * v[380]) + v[371] * v[382];
		v[713] = v[372] * v[380] - v[371] * v[381];
		v[714] = sqrt((v[711] * v[711]) + (v[712] * v[712]) + (v[713] * v[713]));
		v[1803] = 1e0 / Power(v[714], 2);
		v[1286] = v[714];
		v[1814] = 1e0 - (v[1286] * v[1286]);
		v[3215] = 1e0 / Power(v[1814], 0.15e1);
		v[1809] = 1e0 / sqrt(v[1814]);
		v[1285] = asin(v[1286]) / 2e0;
		v[3214] = tan(v[1285]);
		v[1808] = 1e0 / Power(cos(v[1285]), 2);
		v[2982] = v[1808] * v[1809];
		v[716] = 2e0*tan(v[1285]);
		if (v[714] > 0.1e-7) { v07 = 1e0 / v[714]; v08 = (-(v07 / v[714])); v09 = (2e0*v07) / Power(v[714], 2); }
		else {
			v07 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[714])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[714])*
				(0.2399999997e10 - 0.1199999994e18*v[714] - 0.3e17*(v[714] * v[714]))));
			v08 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[714] + 0.6e25*Power(v[714], 3)
				+ 0.1799999982e26*(v[714] * v[714]));
			v09 = 0.1e17*(799999997e0 - 0.599999994e17*v[714] - 0.3e17*(v[714] * v[714]));
		};
		v[720] = v09;
		v[721] = v08;
		v[722] = v07;
		v[3213] = v[716] * v[721] + v[2982] * v[722];
		v[2888] = v[716] * v[722];
		v[723] = v[2888] * v[711];
		v[734] = (v[723] * v[723]);
		v[724] = v[2888] * v[712];
		v[732] = (v[723] * v[724]) / 2e0;
		v[727] = (v[724] * v[724]);
		v[1269] = -v[727] - v[734];
		v[725] = v[2888] * v[713];
		v[1264] = v[725] + v[732];
		v[1262] = -v[725] + v[732];
		v[739] = (v[724] * v[725]) / 2e0;
		v[1268] = v[723] + v[739];
		v[1266] = -v[723] + v[739];
		v[737] = (v[723] * v[725]) / 2e0;
		v[1267] = -v[724] + v[737];
		v[1263] = v[724] + v[737];
		v[728] = (v[725] * v[725]);
		v[1273] = 4e0 + v[727] + v[728] + v[734];
		v[3216] = 1e0 / Power(v[1273], 3);
		v[2106] = 1e0 / Power(v[1273], 2);
		v[1265] = -v[728] - v[734];
		v[1261] = -v[727] - v[728];
		v[726] = 4e0 / v[1273];
		v[729] = 1e0 + (v[1261] * v[726]) / 2e0;
		v[730] = v[1262] * v[726];
		v[731] = v[1263] * v[726];
		v[733] = v[1264] * v[726];
		v[735] = 1e0 + (v[1265] * v[726]) / 2e0;
		v[736] = v[1266] * v[726];
		v[738] = v[1267] * v[726];
		v[740] = v[1268] * v[726];
		v[741] = 1e0 + (v[1269] * v[726]) / 2e0;
	}
	else {
		v[729] = 1e0;
		v[730] = 0e0;
		v[731] = 0e0;
		v[733] = 0e0;
		v[735] = 1e0;
		v[736] = 0e0;
		v[738] = 0e0;
		v[740] = 0e0;
		v[741] = 1e0;
	};
	if ((previouscontact)) {
		v[1228] = 1e0 - v[753];
		v[1226] = 1e0 - v[751];
		v[1224] = 1e0 - v[749];
		v[746] = GAi[0] * v[243] + GAi[1] * v[244] + GAi[2] * v[245] - GBi[0] * v[283] - GBi[1] * v[284] - GBi[2] * v[285] + v[2889]
			+ gti[0] * v[738] + gti[1] * v[740] + gti[2] * v[741];
		v[2892] = v[373] * v[746];
		v[745] = GAi[0] * v[240] + GAi[1] * v[241] + GAi[2] * v[242] - GBi[0] * v[280] - GBi[1] * v[281] - GBi[2] * v[282] + v[2890]
			+ gti[0] * v[733] + gti[1] * v[735] + gti[2] * v[736];
		v[2894] = v[372] * v[745];
		v[2917] = v[2892] + v[2894];
		v[744] = GAi[0] * v[237] + GAi[1] * v[238] + GAi[2] * v[239] - GBi[0] * v[277] - GBi[1] * v[278] - GBi[2] * v[279] + v[2891]
			+ gti[0] * v[729] + gti[1] * v[730] + gti[2] * v[731];
		v[2893] = -(v[371] * v[744]);
		v[2916] = -v[2892] + v[2893];
		v[2915] = v[2893] - v[2894];
		v[743] = -(v[2917] * v[371]) + v[1224] * v[744];
		v[747] = v[2916] * v[372] + v[1226] * v[745];
		v[748] = v[2915] * v[373] + v[1228] * v[746];
	}
	else {
		v[743] = 0e0;
		v[747] = 0e0;
		v[748] = 0e0;
	};
	v[758] = (*epsn)*v[356];
	v[759] = (*epsn)*v[357];
	v[760] = (*epsn)*v[358];
	v[761] = (*cn)*(v[2039] * v[309] + v[2036] * v[319] + v[2033] * v[329] + v[2030] * v[335] + v[2027] * v[345]
		+ v[2024] * v[355] + v[2895] * v[371] - v[2885] * v[749]);
	v[762] = (*cn)*(v[2040] * v[309] + v[2037] * v[319] + v[2034] * v[329] + v[2031] * v[335] + v[2028] * v[345]
		+ v[2025] * v[355] + v[2896] * v[372] - v[2886] * v[751]);
	v[763] = (*cn)*(v[2041] * v[309] + v[2038] * v[319] + v[2035] * v[329] + v[2032] * v[335] + v[2029] * v[345]
		+ v[2026] * v[355] + v[2897] * v[373] - v[2887] * v[753]);
	b764 = v[371] * (v[758] + v[761]) + v[372] * (v[759] + v[762]) + v[373] * (v[760] + v[763]) > 0e0;
	if (b764) {
		v[766] = v[761];
		v[767] = v[762];
		v[768] = v[763];
	}
	else {
		v[766] = -v[758];
		v[767] = -v[759];
		v[768] = -v[760];
	};
	//if (index1 == 48 && index2 == 131 /*&& sub_index1 == 5 && sub_index2 == 2*/ && (db.last_converged_time + db.current_time_step) > 1.035) {
		/*db.myprintf("\n");
		db.myprintf("a = %f\n", v[2041]);
		db.myprintf("b = %f\n", v[309]);
		db.myprintf("c = %f\n", v[2038]);
		db.myprintf("d = %f\n", v[319]);
		db.myprintf("e = %f\n", v[2035]);
		db.myprintf("f = %f\n", v[329]);
		db.myprintf("g = %f\n", v[2032]);
		db.myprintf("h = %f\n", v[335]);
		db.myprintf("i = %f\n", v[2029]);
		db.myprintf("j = %f\n", v[345]);
		db.myprintf("k = %f\n", v[2026]);
		db.myprintf("l = %f\n", v[355]);
		db.myprintf("m = %f\n", v[2897]);
		db.myprintf("n = %f\n", v[373]);
		db.myprintf("m = %f\n", v[2887]);
		db.myprintf("n = %f\n\n", v[753]);
		db.myprintf("o1 = %f\n", uA[0]);
		db.myprintf("o2 = %f\n", uA[1]);
		db.myprintf("o3 = %f\n\n", uA[2]);
		db.myprintf("p1 = %f\n", uB[0]);
		db.myprintf("p2 = %f\n", uB[1]);
		db.myprintf("p3 = %f\n\n", uB[2]); 
		db.myprintf("q1 = %f\n", alphaA[0]);
		db.myprintf("q2 = %f\n", alphaA[1]);
		db.myprintf("q3 = %f\n\n", alphaA[2]);
		db.myprintf("r1 = %f\n", alphaB[0]);
		db.myprintf("r2 = %f\n", alphaB[1]);
		db.myprintf("r3 = %f\n\n", alphaB[2]);
		db.myprintf("s1 = %f\n", duiA[0]);
		db.myprintf("s2 = %f\n", duiA[1]);
		db.myprintf("s3 = %f\n\n", duiA[2]);
		db.myprintf("t1 = %f\n", duiB[0]);
		db.myprintf("t2 = %f\n", duiB[1]);
		db.myprintf("t3 = %f\n\n", duiB[2]);
		db.myprintf("u1 = %f\n", dduiA[0]);
		db.myprintf("u2 = %f\n", dduiA[1]);
		db.myprintf("u3 = %f\n\n", dduiA[2]);
		db.myprintf("v1 = %f\n", dduiB[0]);
		db.myprintf("v2 = %f\n", dduiB[1]);
		db.myprintf("v3 = %f\n\n", dduiB[2]);
		db.myprintf("x1 = %f\n", dalphaiA[0]);
		db.myprintf("x2 = %f\n", dalphaiA[1]);
		db.myprintf("x3 = %f\n\n", dalphaiA[2]);
		db.myprintf("y1 = %f\n", dalphaiB[0]);
		db.myprintf("y2 = %f\n", dalphaiB[1]);
		db.myprintf("y3 = %f\n\n", dalphaiB[2]);
		db.myprintf("w1 = %f\n", ddalphaiA[0]);
		db.myprintf("w2 = %f\n", ddalphaiA[1]);
		db.myprintf("w3 = %f\n\n", ddalphaiA[2]);
		db.myprintf("z1 = %f\n", ddalphaiB[0]);
		db.myprintf("z2 = %f\n", ddalphaiB[1]);
		db.myprintf("z3 = %f\n\n", ddalphaiB[2]);
		db.myprintf("fn[0]g = %f\n", v[758]);
		db.myprintf("fn[1]g = %f\n", v[759]);
		db.myprintf("fn[2]g = %f\n\n", v[760]);
		db.myprintf("fn[0]d = %f\n", v[766]);
		db.myprintf("fn[1]d = %f\n", v[767]); 
		db.myprintf("fn[2]d = %f\n", v[768]);
	}*/
	v[769] = v[758] + v[766];
	v[770] = v[759] + v[767];
	v[771] = v[760] + v[768];
	v[1929] = (v[769] * v[769]) + (v[770] * v[770]) + (v[771] * v[771]);
	v[772] = (*epst)*v[743];
	v[773] = (*epst)*v[747];
	v[774] = (*epst)*v[748];
	v[778] = -((*ct)*(v[1098] * v[298] + v[1102] * v[299] + v[1106] * v[300] - v[1098] * v[301] - v[1102] * v[302]
		- v[1106] * v[303] + v[1110] * v[309] + v[1114] * v[319] + v[1118] * v[329] + v[1134] * v[335] + v[1138] * v[345]
		+ v[1142] * v[355])) + v[772];
	v[779] = -((*ct)*(v[1099] * v[298] + v[1103] * v[299] + v[1107] * v[300] - v[1099] * v[301] - v[1103] * v[302]
		- v[1107] * v[303] + v[1111] * v[309] + v[1115] * v[319] + v[1119] * v[329] + v[1135] * v[335] + v[1139] * v[345]
		+ v[1143] * v[355])) + v[773];
	v[780] = -((*ct)*(v[1100] * v[298] + v[1104] * v[299] + v[1108] * v[300] - v[1100] * v[301] - v[1104] * v[302]
		- v[1108] * v[303] + v[1112] * v[309] + v[1116] * v[319] + v[1120] * v[329] + v[1136] * v[335] + v[1140] * v[345]
		+ v[1144] * v[355])) + v[774];
	v[1926] = (v[778] * v[778]) + (v[779] * v[779]) + (v[780] * v[780]);
	if ((*stick)) {
		b782 = sqrt((v[778] * v[778]) + (v[779] * v[779]) + (v[780] * v[780])) <= (*mus)*sqrt((v[769] * v[769]) +
			(v[770] * v[770]) + (v[771] * v[771]));
		if (b782) {
			v[784] = v[778];
			v[785] = v[779];
			v[786] = v[780];
			v[787] = 1e0;
		}
		else {
			v[1928] = 1e0 / sqrt(v[1926]);
			v[1930] = 1e0 / sqrt(v[1929]);
			v[797] = sqrt(v[1929]);
			v[788] = sqrt(v[1926]);
			if (v[788] > 0.1e-5) { v010 = 1e0 / v[788]; v011 = (-(v010 / v[788])); v012 = (2e0*v010) / Power(v[788], 2); }
			else {
				v010 = (24000000e0 - (-1e0 + 1000000e0*v[788])*(71999994e0 - 0.71999982e14*v[788] + 0.6e19*Power(v[788], 3)
					+ 0.23999982e20*(v[788] * v[788]))) / 24e0;
				v011 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[788] + 0.6e19*Power(v[788], 3) + 0.17999982e20*
					(v[788] * v[788]));
				v012 = 0.1e13*(7999997e0 - 0.5999994e13*v[788] - 0.3e13*(v[788] * v[788]));
			};
			v[792] = v011;
			v[793] = v010;
			v[1927] = (*mud)*v[793] * v[797];
			v[784] = v[1927] * v[778];
			v[785] = v[1927] * v[779];
			v[786] = v[1927] * v[780];
			v[787] = 0e0;
		};
		if (sqrt((v[772] * v[772]) + (v[773] * v[773]) + (v[774] * v[774])) > (*mus)*sqrt((v[769] * v[769]) +
			(v[770] * v[770]) + (v[771] * v[771]))) {
			if ((*epst) > 0.1e-5) {
				v013 = 1e0 / (*epst); v014 = (-(v013 / (*epst))); v015 = (2e0*v013) / Power((*epst), 2
				);
			}
			else {
				v013 = (24000000e0 - (-1e0 + 1000000e0*(*epst))*(71999994e0 - 0.71999982e14*(*epst) + 0.23999982e20*Power(
					(*epst), 2) + 0.6e19*Power((*epst), 3))) / 24e0;
				v014 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*(*epst) + 0.17999982e20*Power((*epst), 2)
					+ 0.6e19*Power((*epst), 3));
				v015 = 0.1e13*(7999997e0 - 0.5999994e13*(*epst) - 0.3e13*Power((*epst), 2));
			};
			v[806] = sqrt((v[772] * v[772]) + (v[773] * v[773]) + (v[774] * v[774]));
			if (v[806] > 0.1e-5) { v016 = 1e0 / v[806]; v017 = (-(v016 / v[806])); v018 = (2e0*v016) / Power(v[806], 2); }
			else {
				v016 = (24000000e0 - (-1e0 + 1000000e0*v[806])*(71999994e0 - 0.71999982e14*v[806] + 0.6e19*Power(v[806], 3)
					+ 0.23999982e20*(v[806] * v[806]))) / 24e0;
				v017 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[806] + 0.6e19*Power(v[806], 3) + 0.17999982e20*
					(v[806] * v[806]));
				v018 = 0.1e13*(7999997e0 - 0.5999994e13*v[806] - 0.3e13*(v[806] * v[806]));
			};
			v[813] = -((*mud)*v013*v016*sqrt(v[1929]));
			v[812] = v[743] + v[772] * v[813];
			v[814] = v[747] + v[773] * v[813];
			v[815] = v[748] + v[774] * v[813];
		}
		else {
			v[812] = 0e0;
			v[814] = 0e0;
			v[815] = 0e0;
		};
	}
	else {
		b816 = sqrt((v[778] * v[778]) + (v[779] * v[779]) + (v[780] * v[780])) <= (*mud)*sqrt((v[769] * v[769]) +
			(v[770] * v[770]) + (v[771] * v[771]));
		if (b816) {
			v[784] = v[778];
			v[785] = v[779];
			v[786] = v[780];
			v[787] = 1e0;
		}
		else {
			v[1936] = 1e0 / sqrt(v[1926]);
			v[1940] = 1e0 / sqrt(v[1929]);
			v[827] = sqrt(v[1929]);
			v[3002] = (*mud)*v[827];
			v[818] = sqrt(v[1926]);
			if (v[818] > 0.1e-5) { v019 = 1e0 / v[818]; v020 = (-(v019 / v[818])); v021 = (2e0*v019) / Power(v[818], 2); }
			else {
				v019 = (24000000e0 - (-1e0 + 1000000e0*v[818])*(71999994e0 - 0.71999982e14*v[818] + 0.6e19*Power(v[818], 3)
					+ 0.23999982e20*(v[818] * v[818]))) / 24e0;
				v020 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[818] + 0.6e19*Power(v[818], 3) + 0.17999982e20*
					(v[818] * v[818]));
				v021 = 0.1e13*(7999997e0 - 0.5999994e13*v[818] - 0.3e13*(v[818] * v[818]));
			};
			v[822] = v020;
			v[823] = v019;
			v[2898] = (*mud)*v[823] * v[827];
			v[784] = v[2898] * v[778];
			v[785] = v[2898] * v[779];
			v[786] = v[2898] * v[780];
			v[787] = 0e0;
		};
		if (sqrt((v[772] * v[772]) + (v[773] * v[773]) + (v[774] * v[774])) > (*mud)*sqrt((v[769] * v[769]) +
			(v[770] * v[770]) + (v[771] * v[771]))) {
			if ((*epst) > 0.1e-5) {
				v022 = 1e0 / (*epst); v023 = (-(v022 / (*epst))); v024 = (2e0*v022) / Power((*epst), 2
				);
			}
			else {
				v022 = (24000000e0 - (-1e0 + 1000000e0*(*epst))*(71999994e0 - 0.71999982e14*(*epst) + 0.23999982e20*Power(
					(*epst), 2) + 0.6e19*Power((*epst), 3))) / 24e0;
				v023 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*(*epst) + 0.17999982e20*Power((*epst), 2)
					+ 0.6e19*Power((*epst), 3));
				v024 = 0.1e13*(7999997e0 - 0.5999994e13*(*epst) - 0.3e13*Power((*epst), 2));
			};
			v[836] = sqrt((v[772] * v[772]) + (v[773] * v[773]) + (v[774] * v[774]));
			if (v[836] > 0.1e-5) { v025 = 1e0 / v[836]; v026 = (-(v025 / v[836])); v027 = (2e0*v025) / Power(v[836], 2); }
			else {
				v025 = (24000000e0 - (-1e0 + 1000000e0*v[836])*(71999994e0 - 0.71999982e14*v[836] + 0.6e19*Power(v[836], 3)
					+ 0.23999982e20*(v[836] * v[836]))) / 24e0;
				v026 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[836] + 0.6e19*Power(v[836], 3) + 0.17999982e20*
					(v[836] * v[836]));
				v027 = 0.1e13*(7999997e0 - 0.5999994e13*v[836] - 0.3e13*(v[836] * v[836]));
			};
			v[842] = -((*mud)*v022*v025*sqrt(v[1929]));
			v[812] = v[743] + v[772] * v[842];
			v[814] = v[747] + v[773] * v[842];
			v[815] = v[748] + v[774] * v[842];
		}
		else {
			v[812] = 0e0;
			v[814] = 0e0;
			v[815] = 0e0;
		};
	};
	fn[0] = v[769];
	fn[1] = v[770];
	fn[2] = v[771];
	ft[0] = v[784];
	ft[1] = v[785];
	ft[2] = v[786];
	(*stickupdated) = v[787];
	gtpupdated[0] = v[743] - v[812];
	gtpupdated[1] = v[747] - v[814];
	gtpupdated[2] = v[748] - v[815];
	v[853] = v[760] * v[856];
	v[854] = v[760] * v[858];
	v[906] = v[258] * v[854];
	v[855] = v[760] * v[860];
	v[912] = v[258] * v[855];
	v[857] = v[759] * v[856];
	v[907] = v[258] * v[857];
	v[859] = v[759] * v[858];
	v[909] = -(v[258] * v[859]) / 2e0;
	v[861] = v[759] * v[860];
	v[915] = v[258] * v[861];
	v[862] = v[758] * v[856];
	v[913] = v[258] * v[862];
	v[863] = v[758] * v[858];
	v[916] = v[258] * v[863];
	v[864] = v[758] * v[860];
	v[914] = -(v[258] * v[864]) / 2e0;
	v[865] = v[760] * v[868];
	v[866] = v[760] * v[870];
	v[895] = v[218] * v[866];
	v[867] = v[760] * v[872];
	v[901] = v[218] * v[867];
	v[869] = v[759] * v[868];
	v[896] = v[218] * v[869];
	v[871] = v[759] * v[870];
	v[898] = -(v[218] * v[871]) / 2e0;
	v[873] = v[759] * v[872];
	v[904] = v[218] * v[873];
	v[874] = v[758] * v[868];
	v[902] = v[218] * v[874];
	v[875] = v[758] * v[870];
	v[905] = v[218] * v[875];
	v[876] = v[758] * v[872];
	v[903] = -(v[218] * v[876]) / 2e0;
	v[877] = v[237] * v[758] + v[240] * v[759] + v[243] * v[760];
	v[878] = v[238] * v[758] + v[241] * v[759] + v[244] * v[760];
	v[879] = v[239] * v[758] + v[242] * v[759] + v[245] * v[760];
	v[3178] = ddGAp[0][1][0] * v[877] + ddGAp[1][1][0] * v[878] + ddGAp[2][1][0] * v[879];
	v[3177] = ddGAp[0][0][0] * v[877] + ddGAp[1][0][0] * v[878] + ddGAp[2][0][0] * v[879];
	v[3176] = ddGAp[0][1][1] * v[877] + ddGAp[1][1][1] * v[878] + ddGAp[2][1][1] * v[879];
	v[3175] = ddGAp[0][0][1] * v[877] + ddGAp[1][0][1] * v[878] + ddGAp[2][0][1] * v[879];
	v[880] = -(v[277] * v[758]) - v[280] * v[759] - v[283] * v[760];
	v[881] = -(v[279] * v[758]) - v[282] * v[759] - v[285] * v[760];
	v[882] = -(v[278] * v[758]) - v[281] * v[759] - v[284] * v[760];
	v[3174] = ddGBp[0][1][0] * v[880] + ddGBp[2][1][0] * v[881] + ddGBp[1][1][0] * v[882];
	v[3173] = ddGBp[0][0][0] * v[880] + ddGBp[2][0][0] * v[881] + ddGBp[1][0][0] * v[882];
	v[3172] = ddGBp[0][1][1] * v[880] + ddGBp[2][1][1] * v[881] + ddGBp[1][1][1] * v[882];
	v[3171] = ddGBp[0][0][1] * v[880] + ddGBp[2][0][1] * v[881] + ddGBp[1][0][1] * v[882];
	v[883] = v[906] + v[907];
	v[1088] = v[883] / 2e0;
	v[1084] = (v[912] + v[913]) / 2e0;
	v[885] = v[915] + v[916];
	v[1083] = v[885] / 2e0;
	v[886] = (v[550] * v[853]) / 2e0 + v[545] * v[854] + v[541] * v[855] + v[537] * v[857] + (v[532] * v[859]) / 2e0
		+ v[528] * v[861] + v[524] * v[862] + v[518] * v[863] + (v[513] * v[864]) / 2e0;
	v[1091] = v[909] + v[914] - 4e0*v[886] * v[981];
	v[1087] = v[1091] - (v[258] * v[853]) / 2e0 - v[909];
	v[1082] = v[1087] + v[909] - v[914];
	v[887] = v[895] + v[896];
	v[1078] = v[887] / 2e0;
	v[1074] = (v[901] + v[902]) / 2e0;
	v[889] = v[904] + v[905];
	v[1073] = v[889] / 2e0;
	v[890] = (v[451] * v[865]) / 2e0 + v[446] * v[866] + v[442] * v[867] + v[438] * v[869] + (v[433] * v[871]) / 2e0
		+ v[429] * v[873] + v[425] * v[874] + v[419] * v[875] + (v[414] * v[876]) / 2e0;
	v[1081] = v[898] + v[903] - 4e0*v[890] * v[966];
	v[1077] = v[1081] - (v[218] * v[865]) / 2e0 - v[898];
	v[1072] = v[1077] + v[898] - v[903];
	v[4200] = v[758];
	v[4201] = v[759];
	v[4202] = v[760];
	v[4203] = 2e0*alphaA[0] * v[1072] + alphaA[2] * v[1074] + v[400] * v[889] + v[895] - v[896];
	v[4204] = 2e0*alphaA[1] * v[1077] + (alphaA[2] * v[887]) / 2e0 + (alphaA[0] * v[889]) / 2e0 - v[901] + v[902];
	v[4205] = alphaA[0] * v[1074] + 2e0*alphaA[2] * v[1081] + v[400] * v[887] + v[904] - v[905];
	v[4206] = -v[758];
	v[4207] = -v[759];
	v[4208] = -v[760];
	v[4209] = 2e0*alphaB[0] * v[1082] + alphaB[2] * v[1084] + v[406] * v[885] + v[906] - v[907];
	v[4210] = 2e0*alphaB[1] * v[1087] + (alphaB[2] * v[883]) / 2e0 + (alphaB[0] * v[885]) / 2e0 - v[912] + v[913];
	v[4211] = alphaB[0] * v[1084] + 2e0*alphaB[2] * v[1091] + v[406] * v[883] + v[915] - v[916];
	v[891] = dGAp[0][1] * v[877] + dGAp[1][1] * v[878] + dGAp[2][1] * v[879];
	v[892] = dGAp[0][0] * v[877] + dGAp[1][0] * v[878] + dGAp[2][0] * v[879];
	v[893] = dGBp[0][0] * v[880] + dGBp[2][0] * v[881] + dGBp[1][0] * v[882];
	v[894] = dGBp[0][1] * v[880] + dGBp[2][1] * v[881] + dGBp[1][1] * v[882];
	for (i851 = 1; i851 <= 12; i851++) {
		i2904 = (i851 == 10 ? 1 : 0);
		i2903 = (i851 == 11 ? 1 : 0);
		i2902 = (i851 == 12 ? 1 : 0);
		i2901 = (i851 == 4 ? 1 : 0);
		i2900 = (i851 == 5 ? 1 : 0);
		i2899 = (i851 == 6 ? 1 : 0);
		v[936] = v[4247 + i851];
		v[935] = v[4235 + i851];
		v[931] = v[4211 + i851];
		v[930] = v[4223 + i851];
		v[922] = v[4275 + i851];
		v[968] = -4e0*v[922] * v[966];
		v[923] = v[4287 + i851];
		v[924] = v[4299 + i851];
		v[925] = v[4311 + i851];
		v[926] = v[4323 + i851];
		v[983] = -4e0*v[926] * v[981];
		v[927] = v[4335 + i851];
		v[928] = v[4347 + i851];
		v[929] = v[4359 + i851];
		v[932] = dGBp[1][0] * v[930] + dGBp[1][1] * v[931];
		v[933] = dGBp[2][0] * v[930] + dGBp[2][1] * v[931];
		v[934] = dGBp[0][0] * v[930] + dGBp[0][1] * v[931];
		v[937] = dGAp[2][0] * v[935] + dGAp[2][1] * v[936];
		v[938] = dGAp[1][0] * v[935] + dGAp[1][1] * v[936];
		v[939] = dGAp[0][0] * v[935] + dGAp[0][1] * v[936];
		v[940] = v[4371 + i851];
		v[941] = v[4419 + i851];
		v[942] = v[4467 + i851];
		v[943] = v[4479 + i851];
		v[944] = v[4527 + i851];
		v[945] = v[4575 + i851];
		v[946] = -i2899 + v[923];
		v[948] = i2899 + v[923];
		v[949] = i2900 + v[924];
		v[951] = -i2900 + v[924];
		v[952] = -i2901 + v[925];
		v[954] = i2901 + v[925];
		v[955] = -i2902 + v[927];
		v[957] = i2902 + v[927];
		v[958] = i2903 + v[928];
		v[960] = -i2903 + v[928];
		v[961] = -i2904 + v[929];
		v[963] = i2904 + v[929];
		v[965] = v[2527] * v[922] - (v[218] * v[940]) / 2e0;
		v[967] = v[218] * v[946] + v[419] * v[968];
		v[969] = v[218] * v[949] + v[425] * v[968];
		v[970] = v[218] * v[948] + v[429] * v[968];
		v[971] = (-(v[218] * v[941]) + v[433] * v[968]) / 2e0;
		v[972] = v[218] * v[952] + v[438] * v[968];
		v[973] = v[218] * v[951] + v[442] * v[968];
		v[974] = v[758] * v[965] + v[759] * v[970] + v[760] * v[973];
		v[975] = v[218] * v[954] + v[446] * v[968];
		v[976] = v[758] * v[967] + v[759] * v[971] + v[760] * v[975];
		v[977] = (-(v[218] * v[942]) + v[451] * v[968]) / 2e0;
		v[978] = v[758] * v[969] + v[759] * v[972] + v[760] * v[977];
		v[980] = v[2538] * v[926] - (v[258] * v[943]) / 2e0;
		v[982] = v[258] * v[955] + v[518] * v[983];
		v[984] = v[258] * v[958] + v[524] * v[983];
		v[985] = v[4611 + i851] - v[278] * v[932] - v[279] * v[933] - v[277] * v[934] + v[239] * v[937] + v[238] * v[938]
			+ v[237] * v[939] + v[872] * v[965] + v[870] * v[967] + v[868] * v[969] + v[860] * v[980] + v[858] * v[982]
			+ v[856] * v[984];
		v[1069] = (*epsn)*v[985];
		v[986] = v[258] * v[957] + v[528] * v[983];
		v[987] = (-(v[258] * v[944]) + v[532] * v[983]) / 2e0;
		v[988] = v[258] * v[961] + v[537] * v[983];
		v[989] = v[4599 + i851] - v[281] * v[932] - v[282] * v[933] - v[280] * v[934] + v[242] * v[937] + v[241] * v[938]
			+ v[240] * v[939] + v[872] * v[970] + v[870] * v[971] + v[868] * v[972] + v[860] * v[986] + v[858] * v[987]
			+ v[856] * v[988];
		v[1070] = (*epsn)*v[989];
		v[990] = v[258] * v[960] + v[541] * v[983];
		v[991] = v[758] * v[980] + v[759] * v[986] + v[760] * v[990];
		v[992] = v[258] * v[963] + v[545] * v[983];
		v[993] = v[758] * v[982] + v[759] * v[987] + v[760] * v[992];
		v[994] = (-(v[258] * v[945]) + v[550] * v[983]) / 2e0;
		v[995] = v[4587 + i851] - v[284] * v[932] - v[285] * v[933] - v[283] * v[934] + v[245] * v[937] + v[244] * v[938]
			+ v[243] * v[939] + v[872] * v[973] + v[870] * v[975] + v[868] * v[977] + v[860] * v[990] + v[858] * v[992]
			+ v[856] * v[994];
		v[1071] = (*epsn)*v[995];
		v[996] = v[758] * v[984] + v[759] * v[988] + v[760] * v[994];
		v[997] = -(GBp[2] * v[1071]) - v[760] * v[933];
		v[998] = -(GBp[1] * v[1071]) - v[760] * v[932];
		v[999] = -(GBp[0] * v[1071]) - v[760] * v[934];
		v[1000] = GAp[2] * v[1071] + v[760] * v[937];
		v[1001] = GAp[1] * v[1071] + v[760] * v[938];
		v[1002] = GAp[0] * v[1071] + v[760] * v[939];
		v[1003] = -(GBp[2] * v[1070]) - v[759] * v[933];
		v[1004] = -(GBp[1] * v[1070]) - v[759] * v[932];
		v[1005] = -(GBp[0] * v[1070]) - v[759] * v[934];
		v[1006] = GAp[2] * v[1070] + v[759] * v[937];
		v[1007] = GAp[1] * v[1070] + v[759] * v[938];
		v[1008] = GAp[0] * v[1070] + v[759] * v[939];
		v[1009] = -(GBp[2] * v[1069]) - v[758] * v[933];
		v[1010] = -(GBp[1] * v[1069]) - v[758] * v[932];
		v[1011] = -(GBp[0] * v[1069]) - v[758] * v[934];
		v[1012] = GAp[2] * v[1069] + v[758] * v[937];
		v[1013] = GAp[1] * v[1069] + v[758] * v[938];
		v[1014] = GAp[0] * v[1069] + v[758] * v[939];
		v[1015] = QBi[2][2] * v[997] + QBi[2][1] * v[998] + QBi[2][0] * v[999];
		v[1016] = QBi[1][2] * v[997] + QBi[1][1] * v[998] + QBi[1][0] * v[999];
		v[1017] = QBi[0][2] * v[997] + QBi[0][1] * v[998] + QBi[0][0] * v[999];
		v[1018] = QBi[2][2] * v[1003] + QBi[2][1] * v[1004] + QBi[2][0] * v[1005];
		v[1019] = QBi[1][2] * v[1003] + QBi[1][1] * v[1004] + QBi[1][0] * v[1005];
		v[1020] = QBi[0][2] * v[1003] + QBi[0][1] * v[1004] + QBi[0][0] * v[1005];
		v[1021] = QBi[2][2] * v[1009] + QBi[2][1] * v[1010] + QBi[2][0] * v[1011];
		v[1022] = QBi[1][2] * v[1009] + QBi[1][1] * v[1010] + QBi[1][0] * v[1011];
		v[1023] = QBi[0][2] * v[1009] + QBi[0][1] * v[1010] + QBi[0][0] * v[1011];
		v[1024] = (v[1015] * v[258] + v[853] * v[983]) / 2e0;
		v[1025] = v[1016] * v[258] + v[854] * v[983];
		v[1026] = v[1017] * v[258] + v[855] * v[983];
		v[1027] = v[1018] * v[258] + v[857] * v[983];
		v[1029] = v[1020] * v[258] + v[861] * v[983];
		v[1030] = v[1021] * v[258] + v[862] * v[983];
		v[1031] = v[1022] * v[258] + v[863] * v[983];
		v[2908] = 8e0*v[1502] * v[886] * v[926] - 4e0*((v[1023] * v[513]) / 2e0 + v[1022] * v[518] + v[1021] * v[524]
			+ v[1020] * v[528] + (v[1019] * v[532]) / 2e0 + v[1018] * v[537] + v[1017] * v[541] + v[1016] * v[545] + (v[1015] * v[550])
			/ 2e0 - (v[864] * v[943]) / 2e0 - (v[859] * v[944]) / 2e0 - (v[853] * v[945]) / 2e0 + v[863] * v[955] + v[861] * v[957]
			+ v[862] * v[958] + v[855] * v[960] + v[857] * v[961] + v[854] * v[963])*v[981];
		v[1086] = -(v[1019] * v[258]) / 2e0 + v[2908] - (v[859] * v[983]) / 2e0;
		v[1033] = (v[1023] * v[258] + v[864] * v[983]) / 2e0;
		v[1034] = QAi[2][2] * v[1000] + QAi[2][1] * v[1001] + QAi[2][0] * v[1002];
		v[1035] = QAi[1][2] * v[1000] + QAi[1][1] * v[1001] + QAi[1][0] * v[1002];
		v[1036] = QAi[0][2] * v[1000] + QAi[0][1] * v[1001] + QAi[0][0] * v[1002];
		v[1037] = QAi[2][2] * v[1006] + QAi[2][1] * v[1007] + QAi[2][0] * v[1008];
		v[1038] = QAi[1][2] * v[1006] + QAi[1][1] * v[1007] + QAi[1][0] * v[1008];
		v[1039] = QAi[0][2] * v[1006] + QAi[0][1] * v[1007] + QAi[0][0] * v[1008];
		v[1040] = QAi[2][2] * v[1012] + QAi[2][1] * v[1013] + QAi[2][0] * v[1014];
		v[1041] = QAi[1][2] * v[1012] + QAi[1][1] * v[1013] + QAi[1][0] * v[1014];
		v[1042] = QAi[0][2] * v[1012] + QAi[0][1] * v[1013] + QAi[0][0] * v[1014];
		v[1043] = (v[1034] * v[218] + v[865] * v[968]) / 2e0;
		v[1044] = v[1035] * v[218] + v[866] * v[968];
		v[1045] = v[1036] * v[218] + v[867] * v[968];
		v[1046] = v[1037] * v[218] + v[869] * v[968];
		v[1048] = v[1039] * v[218] + v[873] * v[968];
		v[1049] = v[1040] * v[218] + v[874] * v[968];
		v[1050] = v[1041] * v[218] + v[875] * v[968];
		v[2906] = 8e0*v[1500] * v[890] * v[922] - 4e0*((v[1042] * v[414]) / 2e0 + v[1041] * v[419] + v[1040] * v[425]
			+ v[1039] * v[429] + (v[1038] * v[433]) / 2e0 + v[1037] * v[438] + v[1036] * v[442] + v[1035] * v[446] + (v[1034] * v[451])
			/ 2e0 - (v[876] * v[940]) / 2e0 - (v[871] * v[941]) / 2e0 - (v[865] * v[942]) / 2e0 + v[875] * v[946] + v[873] * v[948]
			+ v[874] * v[949] + v[867] * v[951] + v[869] * v[952] + v[866] * v[954])*v[966];
		v[1076] = -(v[1038] * v[218]) / 2e0 + v[2906] - (v[871] * v[968]) / 2e0;
		v[1052] = (v[1042] * v[218] + v[876] * v[968]) / 2e0;
		v[2907] = (v[1026] + v[1030]) / 2e0;
		v[1054] = v[1025] + v[1027];
		v[1055] = v[1029] + v[1031];
		v[1056] = -(QBi[0][2] * v[991]) - QBi[1][2] * v[993] - (*epsn)*(v[279] * v[985] + v[282] * v[989] + v[285] * v[995])
			- QBi[2][2] * v[996];
		v[1057] = -(QBi[0][1] * v[991]) - QBi[1][1] * v[993] - (*epsn)*(v[278] * v[985] + v[281] * v[989] + v[284] * v[995])
			- QBi[2][1] * v[996];
		v[1058] = -(QBi[0][0] * v[991]) - QBi[1][0] * v[993] - (*epsn)*(v[277] * v[985] + v[280] * v[989] + v[283] * v[995])
			- QBi[2][0] * v[996];
		v[1059] = dGBp[2][1] * v[1056] + dGBp[1][1] * v[1057] + dGBp[0][1] * v[1058] + v[3171] * v[930] + v[3172] * v[931];
		v[1060] = dGBp[2][0] * v[1056] + dGBp[1][0] * v[1057] + dGBp[0][0] * v[1058] + v[3173] * v[930] + v[3174] * v[931];
		v[2905] = (v[1045] + v[1049]) / 2e0;
		v[1062] = v[1044] + v[1046];
		v[1063] = v[1048] + v[1050];
		v[4624] = 0e0;
		v[4625] = 0e0;
		v[4626] = 0e0;
		v[4627] = 2e0*v[1072];
		v[4628] = v[1073];
		v[4629] = v[1074];
		v[4630] = 0e0;
		v[4631] = 0e0;
		v[4632] = 0e0;
		v[4633] = 0e0;
		v[4634] = 0e0;
		v[4635] = 0e0;
		v[4636] = 0e0;
		v[4637] = 0e0;
		v[4638] = 0e0;
		v[4639] = v[1073];
		v[4640] = 2e0*v[1077];
		v[4641] = v[1078];
		v[4642] = 0e0;
		v[4643] = 0e0;
		v[4644] = 0e0;
		v[4645] = 0e0;
		v[4646] = 0e0;
		v[4647] = 0e0;
		v[4648] = 0e0;
		v[4649] = 0e0;
		v[4650] = 0e0;
		v[4651] = v[1074];
		v[4652] = v[1078];
		v[4653] = 2e0*v[1081];
		v[4654] = 0e0;
		v[4655] = 0e0;
		v[4656] = 0e0;
		v[4657] = 0e0;
		v[4658] = 0e0;
		v[4659] = 0e0;
		v[4660] = 0e0;
		v[4661] = 0e0;
		v[4662] = 0e0;
		v[4663] = 0e0;
		v[4664] = 0e0;
		v[4665] = 0e0;
		v[4666] = 0e0;
		v[4667] = 0e0;
		v[4668] = 0e0;
		v[4669] = 2e0*v[1082];
		v[4670] = v[1083];
		v[4671] = v[1084];
		v[4672] = 0e0;
		v[4673] = 0e0;
		v[4674] = 0e0;
		v[4675] = 0e0;
		v[4676] = 0e0;
		v[4677] = 0e0;
		v[4678] = 0e0;
		v[4679] = 0e0;
		v[4680] = 0e0;
		v[4681] = v[1083];
		v[4682] = 2e0*v[1087];
		v[4683] = v[1088];
		v[4684] = 0e0;
		v[4685] = 0e0;
		v[4686] = 0e0;
		v[4687] = 0e0;
		v[4688] = 0e0;
		v[4689] = 0e0;
		v[4690] = 0e0;
		v[4691] = 0e0;
		v[4692] = 0e0;
		v[4693] = v[1084];
		v[4694] = v[1088];
		v[4695] = 2e0*v[1091];
		v[4696] = v[1069];
		v[4697] = v[1070];
		v[4698] = v[1071];
		v[4699] = v[1044] - v[1046] + 2e0*alphaA[0] * (-v[1043] + v[1076]) + alphaA[2] * v[2905] + v[1063] * v[400] + v[4623
			+ i851];
		v[4700] = -v[1045] + v[1049] + (alphaA[2] * v[1062]) / 2e0 + (alphaA[0] * v[1063]) / 2e0 + 2e0*alphaA[1] * (-v[1043]
			- v[1052] + v[2906]) + v[4635 + i851];
		v[4701] = v[1048] - v[1050] + 2e0*alphaA[2] * (-v[1052] + v[1076]) + alphaA[0] * v[2905] + v[1062] * v[400] + v[4647
			+ i851];
		v[4702] = -v[1069];
		v[4703] = -v[1070];
		v[4704] = -v[1071];
		v[4705] = v[1025] - v[1027] + 2e0*alphaB[0] * (-v[1024] + v[1086]) + alphaB[2] * v[2907] + v[1055] * v[406] + v[4659
			+ i851];
		v[4706] = -v[1026] + v[1030] + (alphaB[2] * v[1054]) / 2e0 + (alphaB[0] * v[1055]) / 2e0 + 2e0*alphaB[1] * (-v[1024]
			- v[1033] + v[2908]) + v[4671 + i851];
		v[4707] = v[1029] - v[1031] + 2e0*alphaB[2] * (-v[1033] + v[1086]) + alphaB[0] * v[2907] + v[1054] * v[406] + v[4683
			+ i851];
		v[1064] = QAi[0][0] * v[974] + QAi[1][0] * v[976] + QAi[2][0] * v[978] + (*epsn)*(v[237] * v[985] + v[240] * v[989]
			+ v[243] * v[995]);
		v[1065] = QAi[0][1] * v[974] + QAi[1][1] * v[976] + QAi[2][1] * v[978] + (*epsn)*(v[238] * v[985] + v[241] * v[989]
			+ v[244] * v[995]);
		v[1066] = QAi[0][2] * v[974] + QAi[1][2] * v[976] + QAi[2][2] * v[978] + (*epsn)*(v[239] * v[985] + v[242] * v[989]
			+ v[245] * v[995]);
		v[1067] = dGAp[0][1] * v[1064] + dGAp[1][1] * v[1065] + dGAp[2][1] * v[1066] + v[3175] * v[935] + v[3176] * v[936];
		v[1068] = dGAp[0][0] * v[1064] + dGAp[1][0] * v[1065] + dGAp[2][0] * v[1066] + v[3177] * v[935] + v[3178] * v[936];
		Rc[i851 - 1] += v[4199 + i851] + v[893] * v[930] + v[894] * v[931] + v[892] * v[935] + v[891] * v[936];
		for (i919 = 1; i919 <= 12; i919++) {
			Kc[i851 - 1][i919 - 1] += v[1059] * v[4211 + i919] + v[1060] * v[4223 + i919] + v[1068] * v[4235 + i919] + v[1067] * v[4247
				+ i919] + v[4695 + i919];
		};/* end for */
	};/* end for */
	v[1101] = -(v[1098] * v[784]) - v[1099] * v[785] - v[1100] * v[786];
	v[1105] = -(v[1102] * v[784]) - v[1103] * v[785] - v[1104] * v[786];
	v[1109] = -(v[1106] * v[784]) - v[1107] * v[785] - v[1108] * v[786];
	v[1149] = 0e0;
	v[1150] = 0e0;
	v[1151] = 0e0;
	b1152 = (*stick);
	if (b1152) {
		b1153 = b782;
		if (b1153) {
			v[1151] = 0e0;
			v[1150] = 0e0;
			v[1149] = 0e0;
		}
		else {
		};
	}
	else {
		b1154 = b816;
		if (b1154) {
			v[1151] = 0e0;
			v[1150] = 0e0;
			v[1149] = 0e0;
		}
		else {
		};
	};
	v[2914] = (*ct)*v[1149];
	v[2910] = (*ct)*v[1150];
	v[2913] = -((*ct)*(-(v[1098] * v[1149]) - v[1099] * v[1150] - v[1100] * v[1151]));
	v[2912] = -((*ct)*(-(v[1102] * v[1149]) - v[1103] * v[1150] - v[1104] * v[1151]));
	v[2911] = -((*ct)*(-(v[1106] * v[1149]) - v[1107] * v[1150] - v[1108] * v[1151]));
	v[2909] = (*ct)*v[1151];
	v[1158] = v[1162] * v[2909];
	v[1159] = v[1164] * v[2909];
	v[1160] = v[1166] * v[2909];
	v[1161] = v[1168] * v[2909];
	v[1163] = v[1162] * v[2910];
	v[1165] = v[1164] * v[2910];
	v[1167] = v[1166] * v[2910];
	v[1169] = v[1168] * v[2910];
	v[1170] = -((*ct)*(v[1142] * v[1149] + v[1143] * v[1150] + v[1144] * v[1151]));
	v[1171] = -((*ct)*(v[1138] * v[1149] + v[1139] * v[1150] + v[1140] * v[1151]));
	v[1172] = -((*ct)*(v[1134] * v[1149] + v[1135] * v[1150] + v[1136] * v[1151]));
	v[1173] = -((*ct)*(v[1118] * v[1149] + v[1119] * v[1150] + v[1120] * v[1151]));
	v[1174] = -((*ct)*(v[1114] * v[1149] + v[1115] * v[1150] + v[1116] * v[1151]));
	v[1175] = -((*ct)*(v[1110] * v[1149] + v[1111] * v[1150] + v[1112] * v[1151]));
	v[1176] = v[2911];
	v[1177] = v[2912];
	v[1178] = v[2913];
	v[1179] = -v[2911];
	v[1180] = -v[2912];
	v[1181] = -v[2913];
	v[1182] = v[1162] * v[2914];
	v[1183] = v[1164] * v[2914];
	v[1184] = v[1166] * v[2914];
	v[1185] = v[1168] * v[2914];
	v[1186] = (*epst)*v[1151];
	v[1863] = -(v[1186] * v[373]);
	v[1187] = (*epst)*v[1150];
	v[1866] = -(v[1187] * v[372]);
	v[1861] = v[1863] + v[1866];
	v[1188] = (*epst)*v[1149];
	v[1867] = -(v[1188] * v[371]);
	v[1868] = v[1866] + v[1867];
	v[1864] = v[1863] + v[1867];
	v[1189] = 0e0;
	v[1190] = 0e0;
	v[1191] = 0e0;
	v[1192] = 0e0;
	v[1193] = 0e0;
	v[1194] = 0e0;
	b1195 = b764;
	if (b1195) {
		v[1194] = 0e0;
		v[1193] = 0e0;
		v[1191] = 0e0;
		v[1190] = 0e0;
		v[1192] = 0e0;
		v[1189] = 0e0;
		v[1196] = 0e0;
		v[1197] = 0e0;
		v[1198] = 0e0;
		v[1199] = 0e0;
		v[1200] = 0e0;
		v[1201] = 0e0;
		v[1202] = 0e0;
		v[1203] = 0e0;
		v[1204] = 0e0;
		v[1205] = 0e0;
		v[1206] = 0e0;
		v[1207] = 0e0;
		v[1208] = 0e0;
		v[1209] = 0e0;
		v[1210] = 0e0;
		v[1211] = 0e0;
		v[1212] = 0e0;
		v[1213] = 0e0;
	}
	else {
		v[1207] = 0e0;
		v[1205] = 0e0;
		v[1206] = 0e0;
		v[1208] = 0e0;
		v[1211] = 0e0;
		v[1209] = 0e0;
		v[1212] = 0e0;
		v[1213] = 0e0;
		v[1210] = 0e0;
		v[1198] = 0e0;
		v[1196] = 0e0;
		v[1197] = 0e0;
		v[1199] = 0e0;
		v[1202] = 0e0;
		v[1200] = 0e0;
		v[1203] = 0e0;
		v[1204] = 0e0;
		v[1201] = 0e0;
	};
	v[1433] = v[1175] * v[2406];
	v[1424] = v[1175] * v[2836];
	v[1418] = v[1175] * v[2838];
	v[2936] = v[1433] + v[1174] * v[1507];
	v[1422] = v[1174] * v[2407];
	v[3108] = v[1422] + v[1424];
	v[1435] = v[1173] * v[1509];
	v[3116] = v[1433] + v[1435];
	v[3106] = v[1435] + v[2936];
	v[2935] = v[1422] + v[1173] * v[1508];
	v[3112] = v[1424] + v[2935];
	v[1415] = v[1173] * v[2408];
	v[3107] = v[1415] + v[1418];
	v[2934] = v[1415] + v[1174] * v[1506];
	v[3115] = v[1418] + v[2934];
	v[1365] = v[1172] * v[2409];
	v[1356] = v[1172] * v[2841];
	v[1350] = v[1172] * v[2843];
	v[2923] = v[1365] + v[1171] * v[1513];
	v[1354] = v[1171] * v[2410];
	v[3120] = v[1354] + v[1356];
	v[1367] = v[1170] * v[1515];
	v[3128] = v[1365] + v[1367];
	v[3118] = v[1367] + v[2923];
	v[2922] = v[1354] + v[1170] * v[1514];
	v[3124] = v[1356] + v[2922];
	v[1347] = v[1170] * v[2411];
	v[4724] = v[1181];
	v[4725] = v[1180];
	v[4726] = v[1179];
	v[4727] = v[1433] + v[1174] * v[2836] + v[1173] * v[2838];
	v[4728] = v[1422] + v[1173] * v[1506] + v[1175] * v[1507];
	v[4729] = v[1415] + v[1174] * v[1508] + v[1175] * v[1509];
	v[4730] = v[1178];
	v[4731] = v[1177];
	v[4732] = v[1176];
	v[4733] = v[1365] + v[1171] * v[2841] + v[1170] * v[2843];
	v[4734] = v[1354] + v[1170] * v[1512] + v[1172] * v[1513];
	v[4735] = v[1347] + v[1171] * v[1514] + v[1172] * v[1515];
	v[3119] = v[1347] + v[1350];
	v[2921] = v[1347] + v[1171] * v[1512];
	v[3127] = v[1350] + v[2921];
	v[1214] = 0e0;
	v[1215] = 0e0;
	v[1216] = 0e0;
	v[1217] = 0e0;
	v[1218] = 0e0;
	v[1219] = 0e0;
	v[1220] = 0e0;
	v[1221] = 0e0;
	v[1222] = 0e0;
	b1223 = (previouscontact);
	if (b1223) {
		v[1194] = v[1194] - v[1186] * v[746];
		v[1193] = v[1193] - v[1187] * v[745];
		v[1225] = v[1188] * v[1224] + v[1861] * v[371];
		v[1227] = v[1187] * v[1226] + v[1864] * v[372];
		v[1229] = v[1186] * v[1228] + v[1868] * v[373];
		v[1191] = v[1191] + v[1186] * v[2915] + v[1868] * v[746];
		v[1190] = v[1190] + v[1187] * v[2916] + v[1864] * v[745];
		v[1192] = v[1192] - v[1188] * v[744];
		v[1189] = v[1189] - v[1188] * v[2917] + v[1861] * v[744];
		v[1214] = gti[0] * v[1225];
		v[1215] = gti[1] * v[1225];
		v[1216] = gti[2] * v[1225];
		v[1233] = -v[1225];
		v[1234] = -(GBi[2] * v[1225]);
		v[1235] = -(GBi[1] * v[1225]);
		v[1236] = -(GBi[0] * v[1225]);
		v[1237] = v[1225];
		v[1238] = GAi[2] * v[1225];
		v[1239] = GAi[1] * v[1225];
		v[1240] = GAi[0] * v[1225];
		v[1217] = gti[0] * v[1227];
		v[1218] = gti[1] * v[1227];
		v[1219] = gti[2] * v[1227];
		v[1241] = -v[1227];
		v[1242] = -(GBi[2] * v[1227]);
		v[1243] = -(GBi[1] * v[1227]);
		v[1244] = -(GBi[0] * v[1227]);
		v[1245] = v[1227];
		v[1246] = GAi[2] * v[1227];
		v[1247] = GAi[1] * v[1227];
		v[1248] = GAi[0] * v[1227];
		v[1220] = gti[0] * v[1229];
		v[1221] = gti[1] * v[1229];
		v[1222] = gti[2] * v[1229];
		v[1249] = -v[1229];
		v[1250] = -(GBi[2] * v[1229]);
		v[1251] = -(GBi[1] * v[1229]);
		v[1252] = -(GBi[0] * v[1229]);
		v[1253] = v[1229];
		v[1254] = GAi[2] * v[1229];
		v[1255] = GAi[1] * v[1229];
		v[1256] = GAi[0] * v[1229];
	}
	else {
		v[1240] = 0e0;
		v[1239] = 0e0;
		v[1238] = 0e0;
		v[1248] = 0e0;
		v[1247] = 0e0;
		v[1246] = 0e0;
		v[1256] = 0e0;
		v[1255] = 0e0;
		v[1254] = 0e0;
		v[1237] = 0e0;
		v[1245] = 0e0;
		v[1253] = 0e0;
		v[1236] = 0e0;
		v[1235] = 0e0;
		v[1234] = 0e0;
		v[1244] = 0e0;
		v[1243] = 0e0;
		v[1242] = 0e0;
		v[1252] = 0e0;
		v[1251] = 0e0;
		v[1250] = 0e0;
		v[1233] = 0e0;
		v[1241] = 0e0;
		v[1249] = 0e0;
	};
	b1257 = b709;
	if (b1257) {
		v[1283] = -(v[1222] * v[726]) / 2e0;
		v[1282] = -(v[1218] * v[726]) / 2e0;
		v[1281] = v[1221] * v[726];
		v[1280] = v[1219] * v[726];
		v[1276] = v[1220] * v[726];
		v[1275] = v[1216] * v[726];
		v[1272] = v[1217] * v[726];
		v[1271] = v[1215] * v[726];
		v[1258] = v[1280] + v[1281];
		v[1259] = v[1275] + v[1276];
		v[1260] = v[1271] + v[1272];
		v[1270] = (v[1214] * v[1261]) / 2e0 + v[1215] * v[1262] + v[1216] * v[1263] + v[1217] * v[1264] + (v[1218] * v[1265])
			/ 2e0 + v[1219] * v[1266] + v[1220] * v[1267] + v[1221] * v[1268] + (v[1222] * v[1269]) / 2e0;
		v[1827] = (-4e0*v[1270]) / Power(v[1273], 2) + v[1282] + v[1283];
		v[1826] = -v[1282] + v[1827] - (v[1214] * v[726]) / 2e0;
		v[1825] = v[1282] - v[1283] + v[1826];
		v[1274] = (-2e0*v[1271] + 2e0*v[1272] + v[1259] * v[723] + v[1258] * v[724] + 4e0*v[1825] * v[725]) / 2e0;
		v[1279] = (2e0*v[1275] - 2e0*v[1276] + v[1260] * v[723] + 4e0*v[1826] * v[724] + v[1258] * v[725]) / 2e0;
		v[1284] = (-2e0*v[1280] + 2e0*v[1281] + 4e0*v[1827] * v[723] + v[1260] * v[724] + v[1259] * v[725]) / 2e0;
		v[2918] = v[1284] * v[711] + v[1279] * v[712] + v[1274] * v[713];
		v[1813] = v[2918] * v[722];
		v[1810] = v[2918] * v[716];
		v[1287] = v[1810] * v[721] + v[1813] / (Power(cos(v[1285]), 2)*sqrt(v[1814]));
		v[2986] = v[1287] / v[714];
		v[2919] = v[1287] / v[714];
		v[1288] = v[1274] * v[2888] + v[2919] * v[713];
		v[1290] = v[1279] * v[2888] + v[2919] * v[712];
		v[1291] = v[1284] * v[2888] + v[2919] * v[711];
		v[1189] = v[1189] - v[1288] * v[381] + v[1290] * v[382];
		v[1191] = v[1191] - v[1290] * v[380] + v[1291] * v[381];
		v[1190] = v[1190] + v[1288] * v[380] - v[1291] * v[382];
	}
	else {
	};
	v[1191] = v[1191] + 2e0*v[1194] * v[373];
	v[1190] = v[1190] + 2e0*v[1193] * v[372];
	v[1189] = v[1189] + 2e0*v[1192] * v[371];
	v[2126] = v[1189] * v[356] + v[1190] * v[357] + v[1191] * v[358];
	v[1292] = v[2126] * v[369];
	v[2920] = v[1292] / v[1293];
	v[1294] = v[2920] * v[358] + v[1191] * v[370];
	v[1296] = v[2920] * v[357] + v[1190] * v[370];
	v[1297] = v[2920] * v[356] + v[1189] * v[370];
	v[1249] = v[1249] - v[1294];
	v[1253] = v[1253] + v[1294];
	v[1241] = v[1241] - v[1296];
	v[1245] = v[1245] + v[1296];
	v[1233] = v[1233] - v[1297];
	v[1237] = v[1237] + v[1297];
	v[1298] = v[1170] * v[1872];
	v[1299] = v[1170] * v[1871];
	v[1300] = v[1170] * v[1870];
	v[1303] = v[1171] * v[1877];
	v[1304] = v[1170] * v[342] + v[1171] * v[344];
	v[2924] = v[1304] * v[263];
	v[1307] = v[1171] * v[1875];
	v[1308] = v[1298] + v[1303];
	v[1310] = v[1171] * v[1876] + v[2924] / v[333];
	v[1313] = v[1172] * v[1880];
	v[1314] = v[1170] * v[336] + v[1172] * v[344];
	v[2925] = v[1314] * v[268];
	v[1315] = v[1171] * v[336] + v[1172] * v[342];
	v[2926] = v[1315] * v[272];
	v[3349] = -(v[2840] * v[2924]) - v[2926] * v[331] - v[2925] * v[332] - v[1171] * (v[3076] * v[336] + v[3080] * v[336]
		+ v[337] * v[342] + v[3081] * v[344] + v[3083] * v[344]) - v[1172] * (v[3078] * v[342] + v[3082] * v[344] + v[334] * (v[336]
			+ v[262] * v[342] + v[263] * v[344])) - v[1170] * (v[3074] * v[336] + v[3077] * v[336] + v[3075] * v[342] + v[3079] * v[342]
				+ v[344] * v[346]);
	v[1317] = v[1172] * v[1882] + v[2925] / v[333];
	v[1318] = v[1310] + v[1317];
	v[1320] = v[1172] * v[1881] + v[2926] / v[333];
	v[1321] = v[1299] + v[1320];
	v[1322] = v[1173] * v[1887];
	v[1323] = v[1173] * v[1886];
	v[1324] = v[1173] * v[1885];
	v[1327] = v[1174] * v[1892];
	v[1328] = v[1173] * v[316] + v[1174] * v[318];
	v[2937] = v[1328] * v[223];
	v[1331] = v[1174] * v[1890];
	v[1332] = v[1322] + v[1327];
	v[1334] = v[1174] * v[1891] + v[2937] / v[307];
	v[1337] = v[1175] * v[1895];
	v[1338] = v[1173] * v[310] + v[1175] * v[318];
	v[2938] = v[1338] * v[228];
	v[1339] = v[1174] * v[310] + v[1175] * v[316];
	v[2939] = v[1339] * v[232];
	v[3355] = -(v[2835] * v[2937]) - v[2939] * v[305] - v[2938] * v[306] - v[1174] * (v[3089] * v[310] + v[3093] * v[310]
		+ v[311] * v[316] + v[3094] * v[318] + v[3096] * v[318]) - v[1175] * (v[3091] * v[316] + v[3095] * v[318] + v[308] * (v[310]
			+ v[222] * v[316] + v[223] * v[318])) - v[1173] * (v[3087] * v[310] + v[3090] * v[310] + v[3088] * v[316] + v[3092] * v[316]
				+ v[318] * v[320]);
	v[1341] = v[1175] * v[1897] + v[2938] / v[307];
	v[1342] = v[1334] + v[1341];
	v[1344] = v[1175] * v[1896] + v[2939] / v[307];
	v[1345] = v[1323] + v[1344];
	v[1250] = dGBp[2][0] * v[1158] + dGBp[2][1] * v[1159] + v[1250] - GBp[2] * v[1294];
	v[1251] = dGBp[1][0] * v[1158] + dGBp[1][1] * v[1159] + v[1251] - GBp[1] * v[1294];
	v[1252] = dGBp[0][0] * v[1158] + dGBp[0][1] * v[1159] + v[1252] - GBp[0] * v[1294];
	v[1346] = QBi[2][2] * v[1250] + QBi[2][1] * v[1251] + QBi[2][0] * v[1252] + v[3127] * v[344];
	v[1349] = QBi[1][2] * v[1250] + QBi[1][1] * v[1251] + QBi[1][0] * v[1252] + v[1315] * v[2843] + v[2921] * v[342];
	v[1351] = QBi[0][2] * v[1250] + QBi[0][1] * v[1251] + QBi[0][0] * v[1252] + v[3119] * v[336];
	v[1242] = dGBp[2][0] * v[1163] + dGBp[2][1] * v[1165] + v[1242] - GBp[2] * v[1296];
	v[1243] = dGBp[1][0] * v[1163] + dGBp[1][1] * v[1165] + v[1243] - GBp[1] * v[1296];
	v[1244] = dGBp[0][0] * v[1163] + dGBp[0][1] * v[1165] + v[1244] - GBp[0] * v[1296];
	v[1352] = QBi[2][2] * v[1242] + QBi[2][1] * v[1243] + QBi[2][0] * v[1244] + v[1314] * v[2841] + v[2922] * v[344];
	v[1355] = QBi[1][2] * v[1242] + QBi[1][1] * v[1243] + QBi[1][0] * v[1244] + v[3124] * v[342];
	v[1357] = QBi[0][2] * v[1242] + QBi[0][1] * v[1243] + QBi[0][0] * v[1244] + v[3120] * v[336];
	v[1234] = dGBp[2][0] * v[1182] + dGBp[2][1] * v[1183] + v[1234] - GBp[2] * v[1297];
	v[1235] = dGBp[1][0] * v[1182] + dGBp[1][1] * v[1183] + v[1235] - GBp[1] * v[1297];
	v[1236] = dGBp[0][0] * v[1182] + dGBp[0][1] * v[1183] + v[1236] - GBp[0] * v[1297];
	v[1364] = QBi[2][2] * v[1234] + QBi[2][1] * v[1235] + QBi[2][0] * v[1236] + v[1304] * v[1513] + v[3128] * v[344];
	v[1366] = QBi[1][2] * v[1234] + QBi[1][1] * v[1235] + QBi[1][0] * v[1236] + v[2923] * v[342];
	v[1369] = QBi[0][2] * v[1234] + QBi[0][1] * v[1235] + QBi[0][0] * v[1236] + v[3118] * v[336];
	v[1370] = -(v[1196] * v[860]);
	v[1371] = -(v[1196] * v[858]);
	v[1372] = -(v[1196] * v[856]);
	v[1373] = -(v[1197] * v[860]);
	v[1374] = -(v[1197] * v[856]);
	v[1375] = -(v[1197] * v[858]);
	v[2949] = -2e0*v[1375];
	v[1376] = -(v[1198] * v[858]);
	v[1377] = -(v[1198] * v[856]);
	v[1378] = -(v[1198] * v[860]);
	v[1379] = -(v[1199] * v[860]);
	v[1380] = -(v[1199] * v[858]);
	v[1381] = -(v[1199] * v[856]);
	v[2947] = -2e0*v[1381];
	v[1382] = -(v[1200] * v[856]);
	v[1383] = -(v[1200] * v[860]);
	v[2950] = 2e0*v[1383];
	v[1384] = -(v[1200] * v[858]);
	v[1385] = -(v[1201] * v[858]);
	v[1386] = -(v[1201] * v[860]);
	v[1387] = -(v[1201] * v[856]);
	v[1388] = v[1376] + v[1379] + v[1382] + v[1385] + 2e0*v[1307] * v[517] - v[1318] * v[520] - v[1308] * v[523];
	v[1389] = -(v[1202] * v[860]);
	v[1390] = -(v[1202] * v[856]);
	v[1391] = -(v[1202] * v[858]);
	v[1392] = -v[1371] - v[1374] - v[1386] - v[1389] - v[1318] * v[517] + 2e0*v[1313] * v[520] + v[1321] * v[523];
	v[1393] = v[1366] * v[258] - v[1376] * v[510] + v[1371] * v[511] - v[1375] * v[512];
	v[1394] = -(v[1203] * v[860]);
	v[1395] = -(v[1203] * v[858]);
	v[2948] = 2e0*v[1395];
	v[1396] = -(v[1203] * v[856]);
	v[1397] = -(v[1204] * v[858]);
	v[1398] = -(v[1204] * v[860]);
	v[1399] = -(v[1204] * v[856]);
	v[1403] = -v[1377] - v[1390] - v[1394] - v[1397] - v[1308] * v[517] + v[1321] * v[520] + 2e0*v[1300] * v[523];
	v[3104] = -v[1403] / 2e0;
	v[1404] = v[1364] * v[258] - v[1377] * v[510] + v[1372] * v[511] - v[1374] * v[512];
	v[1405] = v[1357] * v[258] - v[1379] * v[510] + v[1389] * v[511] - v[1383] * v[512];
	v[1406] = v[1373] + v[1384];
	v[1407] = v[1352] * v[258] - v[1381] * v[510] + v[1390] * v[511] - v[1382] * v[512];
	v[1408] = v[1351] * v[258] - v[1394] * v[510] + v[1398] * v[511] - v[1386] * v[512];
	v[1409] = v[1349] * v[258] - v[1395] * v[510] + v[1397] * v[511] - v[1385] * v[512];
	v[1410] = v[1380] + v[1396];
	v[1411] = v[1370] + v[1399];
	v[5316] = 0e0;
	v[5317] = 0e0;
	v[5318] = 0e0;
	v[5319] = 0e0;
	v[5320] = 0e0;
	v[5321] = 0e0;
	v[5322] = 0e0;
	v[5323] = 0e0;
	v[5324] = 0e0;
	v[5325] = -v[1392] / 2e0 - v[1410];
	v[5326] = (v[1388] - 2e0*v[1411]) / 2e0;
	v[5327] = -v[1406] + v[3104];
	v[1412] = 1e0 / Power(v[333], 2);
	v[2933] = -(v[1412] * v[342]);
	v[2932] = -(v[1412] * v[344]);
	v[2931] = -(v[1412] * v[336]);
	v[2930] = -(v[1412] * v[331]);
	v[2929] = -(v[1170] * v[1412]);
	v[2928] = -(v[1412] * v[332]);
	v[2927] = -(v[1412] * v[2840]);
	v[2348] = -(v[1412] * (v[3082] + v[263] * v[334]));
	v[2347] = -(v[1412] * (v[3078] + v[262] * v[334]));
	v[2346] = -(v[1412] * (v[3076] + v[3080]));
	v[2345] = -(v[1412] * (v[3081] + v[3083]));
	v[2344] = -(v[1412] * (v[3074] + v[3077]));
	v[2343] = -(v[1412] * (v[3075] + v[3079]));
	v[2342] = -(v[1412] * v[334]);
	v[3086] = v[2342] * v[336];
	v[2341] = -(v[1412] * v[337]);
	v[3085] = v[2341] * v[342];
	v[3084] = -(v[1412] * v[344] * v[346]);
	v[2339] = -(v[1412] * v[2924]);
	v[2338] = -(v[1412] * v[2925]);
	v[2337] = -(v[1412] * v[2926]);
	v[2336] = v[1304] * v[2927];
	v[2335] = v[1314] * v[2928];
	v[2334] = v[1315] * v[2930];
	v[2219] = v[1171] * v[2927];
	v[2218] = v[2842] * v[2929];
	v[2216] = v[1172] * v[2342];
	v[3334] = v[2336] + (v[2216] + v[2218])*v[344];
	v[3070] = v[2216] + v[2219];
	v[3335] = v[2218] + v[3070];
	v[2212] = v[1172] * v[2928];
	v[2209] = v[1171] * v[2341];
	v[3333] = v[2209] + v[2212];
	v[2208] = v[2844] * v[2929];
	v[3069] = v[2208] + v[2209];
	v[3332] = v[2212] + v[3069];
	v[3331] = v[2335] + v[3069] * v[344];
	v[2204] = v[1172] * v[2930];
	v[2202] = -(v[1171] * v[1412] * v[343]);
	v[2201] = v[2929] * v[346];
	v[3330] = v[2201] + v[2204];
	v[3068] = v[2201] + v[2202];
	v[3329] = v[2334] + v[3068] * v[342];
	v[3328] = v[2204] + v[3068];
	v[2161] = v[270] * v[2931];
	v[2158] = v[265] * v[2931];
	v[2155] = v[263] * v[2932];
	v[2154] = v[262] * v[2933];
	v[2149] = v[268] * v[2932];
	v[2148] = v[267] * v[2933];
	v[3320] = v[2148] + v[2158];
	v[3057] = v[2148] + v[2149];
	v[3318] = v[2158] + v[3057];
	v[2146] = v[261] * v[2931];
	v[3316] = v[2146] + v[2155];
	v[3058] = v[2146] + v[2154];
	v[3319] = v[2155] + v[3058];
	v[2142] = v[273] * v[2932];
	v[3321] = v[2142] + v[2161];
	v[2141] = v[272] * v[2933];
	v[3055] = v[2141] + v[2142];
	v[3317] = v[2161] + v[3055];
	v[1879] = v[3086] + v[2347] * v[342] + v[2348] * v[344];
	v[1874] = v[3085] + v[2346] * v[336] + v[2345] * v[344];
	v[1869] = v[3084] + v[2344] * v[336] + v[2343] * v[342];
	v[1722] = v[263] * v[2927];
	v[1720] = v[268] * v[2928];
	v[1716] = v[272] * v[2930];
	v[2333] = v[1300] + v[1307] + v[1313] + v[1315] * v[1716] + v[1314] * v[1720] + v[1304] * v[1722] + v[1170] * v[1869]
		+ v[1171] * v[1874] + v[1172] * v[1879];
	v[1413] = (2e0*v[1372] + alphaB[1] * v[1388] - alphaB[0] * v[1392] - 2e0*v[1398] - alphaB[2] * v[1403]
		+ 4e0*v[2333] * v[258] + v[2947] + v[2948] + v[2949] + v[2950] - v[1410] * v[405] - v[1411] * v[408] - v[1406] * v[410]
		+ v[1369] * v[513] + 2e0*v[1366] * v[518] + 2e0*v[1364] * v[524] + 2e0*v[1357] * v[528] + v[1355] * v[532]
		+ 2e0*v[1352] * v[537] + 2e0*v[1351] * v[541] + 2e0*v[1349] * v[545] + v[1346] * v[550]) / 2e0;
	v[1254] = dGAp[2][0] * v[1160] + dGAp[2][1] * v[1161] + v[1254] + GAp[2] * v[1294];
	v[1255] = dGAp[1][0] * v[1160] + dGAp[1][1] * v[1161] + v[1255] + GAp[1] * v[1294];
	v[1256] = dGAp[0][0] * v[1160] + dGAp[0][1] * v[1161] + v[1256] + GAp[0] * v[1294];
	v[1414] = QAi[2][2] * v[1254] + QAi[2][1] * v[1255] + QAi[2][0] * v[1256] + v[3115] * v[318];
	v[1417] = QAi[1][2] * v[1254] + QAi[1][1] * v[1255] + QAi[1][0] * v[1256] + v[1339] * v[2838] + v[2934] * v[316];
	v[1419] = QAi[0][2] * v[1254] + QAi[0][1] * v[1255] + QAi[0][0] * v[1256] + v[310] * v[3107];
	v[1246] = dGAp[2][0] * v[1167] + dGAp[2][1] * v[1169] + v[1246] + GAp[2] * v[1296];
	v[1247] = dGAp[1][0] * v[1167] + dGAp[1][1] * v[1169] + v[1247] + GAp[1] * v[1296];
	v[1248] = dGAp[0][0] * v[1167] + dGAp[0][1] * v[1169] + v[1248] + GAp[0] * v[1296];
	v[1420] = QAi[2][2] * v[1246] + QAi[2][1] * v[1247] + QAi[2][0] * v[1248] + v[1338] * v[2836] + v[2935] * v[318];
	v[1423] = QAi[1][2] * v[1246] + QAi[1][1] * v[1247] + QAi[1][0] * v[1248] + v[3112] * v[316];
	v[1425] = QAi[0][2] * v[1246] + QAi[0][1] * v[1247] + QAi[0][0] * v[1248] + v[310] * v[3108];
	v[1238] = dGAp[2][0] * v[1184] + dGAp[2][1] * v[1185] + v[1238] + GAp[2] * v[1297];
	v[1239] = dGAp[1][0] * v[1184] + dGAp[1][1] * v[1185] + v[1239] + GAp[1] * v[1297];
	v[1240] = dGAp[0][0] * v[1184] + dGAp[0][1] * v[1185] + v[1240] + GAp[0] * v[1297];
	v[1432] = QAi[2][2] * v[1238] + QAi[2][1] * v[1239] + QAi[2][0] * v[1240] + v[1328] * v[1507] + v[3116] * v[318];
	v[1434] = QAi[1][2] * v[1238] + QAi[1][1] * v[1239] + QAi[1][0] * v[1240] + v[2936] * v[316];
	v[1437] = QAi[0][2] * v[1238] + QAi[0][1] * v[1239] + QAi[0][0] * v[1240] + v[310] * v[3106];
	v[1438] = v[1205] * v[872];
	v[1439] = v[1205] * v[870];
	v[1440] = v[1205] * v[868];
	v[1441] = v[1206] * v[872];
	v[1442] = v[1206] * v[868];
	v[1443] = v[1206] * v[870];
	v[2953] = -2e0*v[1443];
	v[1444] = v[1207] * v[870];
	v[1445] = v[1207] * v[868];
	v[1446] = v[1207] * v[872];
	v[1447] = v[1208] * v[872];
	v[1448] = v[1208] * v[870];
	v[1449] = v[1208] * v[868];
	v[2951] = -2e0*v[1449];
	v[1450] = v[1209] * v[868];
	v[1451] = v[1209] * v[872];
	v[2954] = 2e0*v[1451];
	v[1452] = v[1209] * v[870];
	v[1453] = v[1210] * v[870];
	v[1454] = v[1210] * v[872];
	v[1455] = v[1210] * v[868];
	v[1456] = v[1444] + v[1447] + v[1450] + v[1453] + 2e0*v[1331] * v[418] - v[1342] * v[421] - v[1332] * v[424];
	v[1457] = v[1211] * v[872];
	v[1458] = v[1211] * v[868];
	v[1459] = v[1211] * v[870];
	v[1460] = -v[1439] - v[1442] - v[1454] - v[1457] - v[1342] * v[418] + 2e0*v[1337] * v[421] + v[1345] * v[424];
	v[1461] = v[1434] * v[218] - v[1444] * v[411] + v[1439] * v[412] - v[1443] * v[413];
	v[1462] = v[1212] * v[872];
	v[1463] = v[1212] * v[870];
	v[2952] = 2e0*v[1463];
	v[1464] = v[1212] * v[868];
	v[1465] = v[1213] * v[870];
	v[1466] = v[1213] * v[872];
	v[1467] = v[1213] * v[868];
	v[1471] = -v[1445] - v[1458] - v[1462] - v[1465] - v[1332] * v[418] + v[1345] * v[421] + 2e0*v[1324] * v[424];
	v[3101] = -v[1471] / 2e0;
	v[1472] = v[1432] * v[218] - v[1445] * v[411] + v[1440] * v[412] - v[1442] * v[413];
	v[1473] = v[1425] * v[218] - v[1447] * v[411] + v[1457] * v[412] - v[1451] * v[413];
	v[1474] = v[1441] + v[1452];
	v[1475] = v[1420] * v[218] - v[1449] * v[411] + v[1458] * v[412] - v[1450] * v[413];
	v[1476] = v[1419] * v[218] - v[1462] * v[411] + v[1466] * v[412] - v[1454] * v[413];
	v[1477] = v[1417] * v[218] - v[1463] * v[411] + v[1465] * v[412] - v[1453] * v[413];
	v[1478] = v[1448] + v[1464];
	v[1479] = v[1438] + v[1467];
	v[5328] = 0e0;
	v[5329] = 0e0;
	v[5330] = 0e0;
	v[5331] = -v[1460] / 2e0 - v[1478];
	v[5332] = (v[1456] - 2e0*v[1479]) / 2e0;
	v[5333] = -v[1474] + v[3101];
	v[5334] = 0e0;
	v[5335] = 0e0;
	v[5336] = 0e0;
	v[5337] = 0e0;
	v[5338] = 0e0;
	v[5339] = 0e0;
	v[1480] = 1e0 / Power(v[307], 2);
	v[2946] = -(v[1480] * v[316]);
	v[2945] = -(v[1480] * v[318]);
	v[2944] = -(v[1480] * v[310]);
	v[2943] = -(v[1480] * v[305]);
	v[2942] = -(v[1173] * v[1480]);
	v[2941] = -(v[1480] * v[306]);
	v[2940] = -(v[1480] * v[2835]);
	v[2380] = -(v[1480] * (v[223] * v[308] + v[3095]));
	v[2379] = -(v[1480] * (v[222] * v[308] + v[3091]));
	v[2378] = -(v[1480] * (v[3089] + v[3093]));
	v[2377] = -(v[1480] * (v[3094] + v[3096]));
	v[2376] = -(v[1480] * (v[3087] + v[3090]));
	v[2375] = -(v[1480] * (v[3088] + v[3092]));
	v[2374] = -(v[1480] * v[308]);
	v[3099] = v[2374] * v[310];
	v[2373] = -(v[1480] * v[311]);
	v[3098] = v[2373] * v[316];
	v[3097] = -(v[1480] * v[318] * v[320]);
	v[2371] = -(v[1480] * v[2937]);
	v[2370] = -(v[1480] * v[2938]);
	v[2369] = -(v[1480] * v[2939]);
	v[2368] = v[1328] * v[2940];
	v[2367] = v[1338] * v[2941];
	v[2366] = v[1339] * v[2943];
	v[2285] = v[1174] * v[2940];
	v[2284] = v[2837] * v[2942];
	v[2282] = v[1175] * v[2374];
	v[3342] = v[2368] + (v[2282] + v[2284])*v[318];
	v[3073] = v[2282] + v[2285];
	v[3343] = v[2284] + v[3073];
	v[2278] = v[1175] * v[2941];
	v[2275] = v[1174] * v[2373];
	v[3341] = v[2275] + v[2278];
	v[2274] = v[2839] * v[2942];
	v[3072] = v[2274] + v[2275];
	v[3340] = v[2278] + v[3072];
	v[3339] = v[2367] + v[3072] * v[318];
	v[2270] = v[1175] * v[2943];
	v[2268] = -(v[1174] * v[1480] * v[317]);
	v[2267] = v[2942] * v[320];
	v[3338] = v[2267] + v[2270];
	v[3071] = v[2267] + v[2268];
	v[3337] = v[2366] + v[3071] * v[316];
	v[3336] = v[2270] + v[3071];
	v[2191] = v[230] * v[2944];
	v[2188] = v[225] * v[2944];
	v[2185] = v[223] * v[2945];
	v[2184] = v[222] * v[2946];
	v[2179] = v[228] * v[2945];
	v[2178] = v[227] * v[2946];
	v[3326] = v[2178] + v[2188];
	v[3065] = v[2178] + v[2179];
	v[3324] = v[2188] + v[3065];
	v[2176] = v[221] * v[2944];
	v[3322] = v[2176] + v[2185];
	v[3066] = v[2176] + v[2184];
	v[3325] = v[2185] + v[3066];
	v[2172] = v[233] * v[2945];
	v[3327] = v[2172] + v[2191];
	v[2171] = v[232] * v[2946];
	v[3063] = v[2171] + v[2172];
	v[3323] = v[2191] + v[3063];
	v[1894] = v[3099] + v[2379] * v[316] + v[2380] * v[318];
	v[1889] = v[3098] + v[2378] * v[310] + v[2377] * v[318];
	v[1884] = v[3097] + v[2376] * v[310] + v[2375] * v[316];
	v[1694] = v[223] * v[2940];
	v[1692] = v[228] * v[2941];
	v[1688] = v[232] * v[2943];
	v[2365] = v[1324] + v[1331] + v[1337] + v[1339] * v[1688] + v[1338] * v[1692] + v[1328] * v[1694] + v[1173] * v[1884]
		+ v[1174] * v[1889] + v[1175] * v[1894];
	v[1481] = (2e0*v[1440] + alphaA[1] * v[1456] - alphaA[0] * v[1460] - 2e0*v[1466] - alphaA[2] * v[1471]
		+ 4e0*v[218] * v[2365] + v[2951] + v[2952] + v[2953] + v[2954] - v[1478] * v[399] - v[1479] * v[402] - v[1474] * v[404]
		+ v[1437] * v[414] + 2e0*v[1434] * v[419] + 2e0*v[1432] * v[425] + 2e0*v[1425] * v[429] + v[1423] * v[433]
		+ 2e0*v[1420] * v[438] + 2e0*v[1419] * v[442] + 2e0*v[1417] * v[446] + v[1414] * v[451]) / 2e0;
	v[1482] = (-2e0*v[1298] + 2e0*v[1303] - v[1378] * v[513] - 2e0*v[1376] * v[518] - 2e0*v[1377] * v[524]
		- 2e0*v[1379] * v[528] - v[1380] * v[532] + v[2947] * v[537] - 2e0*v[1394] * v[541] - v[2948] * v[545] - v[1396] * v[550])
		/ 2e0;
	v[1484] = -v[1299] + v[1320] + (v[1370] * v[513]) / 2e0 + v[1371] * v[518] + v[1372] * v[524] + v[1389] * v[528] +
		(v[1391] * v[532]) / 2e0 + v[1390] * v[537] + v[1398] * v[541] + v[1397] * v[545] + (v[1399] * v[550]) / 2e0;
	v[1485] = (v[1355] * v[258] - v[1380] * v[510] + v[1391] * v[511] - v[1384] * v[512]) / 2e0;
	v[1486] = (-2e0*v[1310] + 2e0*v[1317] - v[1373] * v[513] + v[2949] * v[518] - 2e0*v[1374] * v[524] - v[2950] * v[528]
		- v[1384] * v[532] - 2e0*v[1382] * v[537] - 2e0*v[1386] * v[541] - 2e0*v[1385] * v[545] - v[1387] * v[550]) / 2e0;
	v[5340] = 0e0;
	v[5341] = 0e0;
	v[5342] = 0e0;
	v[5343] = 0e0;
	v[5344] = 0e0;
	v[5345] = 0e0;
	v[5346] = 0e0;
	v[5347] = 0e0;
	v[5348] = 0e0;
	v[5349] = 8e0*v[1482];
	v[5350] = -8e0*v[1484];
	v[5351] = 8e0*v[1486];
	v[3345] = v[1482] * v[405] - v[1484] * v[408] + v[1486] * v[410];
	v[1503] = -v[1485] + v[1486] * v[1578] + v[1484] * v[1581] + v[1482] * v[1583] - v[1413] * v[3105];
	v[2405] = v[1503] + (-(v[1369] * v[258]) + v[1378] * v[510] - v[1370] * v[511] + v[1373] * v[512]) / 2e0;
	v[1487] = (v[1346] * v[258] - v[1396] * v[510] + v[1399] * v[511] - v[1387] * v[512]) / 2e0;
	v[2403] = v[1485] - v[1487] + v[2405];
	v[2398] = -v[1487] + v[1503];
	v[2400] = (v[1404] + v[1408]) / 2e0;
	v[1489] = v[1407] + v[1409];
	v[2404] = v[1489] / 2e0;
	v[1490] = v[1393] + v[1405];
	v[2399] = v[1490] / 2e0;
	v[1491] = (-2e0*v[1322] + 2e0*v[1327] - v[1446] * v[414] - 2e0*v[1444] * v[419] - 2e0*v[1445] * v[425]
		- 2e0*v[1447] * v[429] - v[1448] * v[433] + v[2951] * v[438] - 2e0*v[1462] * v[442] - v[2952] * v[446] - v[1464] * v[451])
		/ 2e0;
	v[1493] = -v[1323] + v[1344] + (v[1438] * v[414]) / 2e0 + v[1439] * v[419] + v[1440] * v[425] + v[1457] * v[429] +
		(v[1459] * v[433]) / 2e0 + v[1458] * v[438] + v[1466] * v[442] + v[1465] * v[446] + (v[1467] * v[451]) / 2e0;
	v[1494] = (v[1423] * v[218] - v[1448] * v[411] + v[1459] * v[412] - v[1452] * v[413]) / 2e0;
	v[1495] = (-2e0*v[1334] + 2e0*v[1341] - v[1441] * v[414] + v[2953] * v[419] - 2e0*v[1442] * v[425] - v[2954] * v[429]
		- v[1452] * v[433] - 2e0*v[1450] * v[438] - 2e0*v[1454] * v[442] - 2e0*v[1453] * v[446] - v[1455] * v[451]) / 2e0;
	v[5352] = 0e0;
	v[5353] = 0e0;
	v[5354] = 0e0;
	v[5355] = 8e0*v[1491];
	v[5356] = -8e0*v[1493];
	v[5357] = 8e0*v[1495];
	v[5358] = 0e0;
	v[5359] = 0e0;
	v[5360] = 0e0;
	v[5361] = 0e0;
	v[5362] = 0e0;
	v[5363] = 0e0;
	v[3351] = v[1491] * v[399] - v[1493] * v[402] + v[1495] * v[404];
	v[1501] = -v[1494] + v[1495] * v[1564] + v[1493] * v[1567] + v[1491] * v[1569] - v[1481] * v[3102];
	v[2397] = v[1501] + (-(v[1437] * v[218]) + v[1446] * v[411] - v[1438] * v[412] + v[1441] * v[413]) / 2e0;
	v[1496] = (v[1414] * v[218] - v[1464] * v[411] + v[1467] * v[412] - v[1455] * v[413]) / 2e0;
	v[2395] = v[1494] - v[1496] + v[2397];
	v[2390] = -v[1496] + v[1501];
	v[2392] = (v[1472] + v[1476]) / 2e0;
	v[1498] = v[1475] + v[1477];
	v[2396] = v[1498] / 2e0;
	v[1499] = v[1461] + v[1473];
	v[4712] = v[1101] + v[1237];
	v[4713] = v[1105] + v[1245];
	v[4714] = v[1109] + v[1253];
	v[4715] = -v[1475] + v[1477] + 2e0*alphaA[0] * v[2390] + alphaA[2] * v[2392] + v[1460] * v[3100] + 2e0*
		(v[1478] * v[3100] + v[1491] * v[3102]) + v[1499] * v[400] - v[1110] * v[784] - v[1111] * v[785] - v[1112] * v[786];
	v[4716] = v[1472] - v[1476] + (alphaA[2] * v[1498]) / 2e0 + (alphaA[0] * v[1499]) / 2e0 + (v[1456] * v[218]) / 2e0
		+ 2e0*alphaA[1] * v[2395] + 2e0*(v[1479] * v[3100] - v[1493] * v[3102]) - v[1114] * v[784] - v[1115] * v[785]
		- v[1116] * v[786];
	v[4717] = -v[1461] + v[1473] + alphaA[0] * v[2392] + 2e0*alphaA[2] * v[2397] + v[218] * v[3101] + 2e0*
		(v[1474] * v[3100] + v[1495] * v[3102]) + v[1498] * v[400] - v[1118] * v[784] - v[1119] * v[785] - v[1120] * v[786];
	v[4718] = -v[1101] + v[1233];
	v[4719] = -v[1105] + v[1241];
	v[4720] = -v[1109] + v[1249];
	v[4721] = -v[1407] + v[1409] + 2e0*alphaB[0] * v[2398] + alphaB[2] * v[2400] + v[1392] * v[3103] + 2e0*
		(v[1410] * v[3103] + v[1482] * v[3105]) + v[1490] * v[406] - v[1134] * v[784] - v[1135] * v[785] - v[1136] * v[786];
	v[4722] = v[1404] - v[1408] + (alphaB[2] * v[1489]) / 2e0 + (alphaB[0] * v[1490]) / 2e0 + 2e0*alphaB[1] * v[2403] +
		(v[1388] * v[258]) / 2e0 + 2e0*(v[1411] * v[3103] - v[1484] * v[3105]) - v[1138] * v[784] - v[1139] * v[785]
		- v[1140] * v[786];
	v[4723] = -v[1393] + v[1405] + alphaB[0] * v[2400] + 2e0*alphaB[2] * v[2405] + v[258] * v[3104] + 2e0*
		(v[1406] * v[3103] + v[1486] * v[3105]) + v[1489] * v[406] - v[1142] * v[784] - v[1143] * v[785] - v[1144] * v[786];
	v[2391] = v[1499] / 2e0;
	for (i1147 = 1; i1147 <= 12; i1147++) {
		i2980 = (i1147 == 9 ? 1 : 0);
		i2979 = (i1147 == 3 ? 1 : 0);
		i2987 = i2979 - i2980;
		i2978 = (i1147 == 8 ? 1 : 0);
		i2977 = (i1147 == 2 ? 1 : 0);
		i2988 = i2977 - i2978;
		i2976 = (i1147 == 7 ? 1 : 0);
		i2975 = (i1147 == 1 ? 1 : 0);
		i2989 = i2975 - i2976;
		i2960 = (i1147 == 11 ? 1 : 0);
		v[3052] = (*a4)*i2960;
		i2959 = (i1147 == 10 ? 1 : 0);
		v[3053] = (*a4)*i2959;
		v[2968] = -(i2959*v[258]);
		i2958 = (i1147 == 12 ? 1 : 0);
		v[3054] = (*a4)*i2958;
		v[2967] = -(i2958*v[258]);
		i2957 = (i1147 == 5 ? 1 : 0);
		v[3060] = (*a4)*i2957;
		i2956 = (i1147 == 4 ? 1 : 0);
		v[3061] = (*a4)*i2956;
		v[2962] = -(i2956*v[218]);
		i2955 = (i1147 == 6 ? 1 : 0);
		v[3062] = (*a4)*i2955;
		v[2961] = -(i2955*v[218]);
		v[1521] = v[4287 + i1147];
		v[1523] = v[4311 + i1147];
		v[1525] = v[4299 + i1147];
		v[1526] = v[4739 + i1147];
		v[1528] = v[4275 + i1147];
		v[2393] = -8e0*v[1500] * v[1528];
		v[1529] = v[4787 + i1147];
		v[1531] = v[4335 + i1147];
		v[1533] = v[4359 + i1147];
		v[1535] = v[4347 + i1147];
		v[1536] = v[4811 + i1147];
		v[1538] = v[4323 + i1147];
		v[2401] = -8e0*v[1502] * v[1538];
		v[1539] = v[4859 + i1147];
		v[1540] = (*a4)*i2980;
		v[1541] = (*a4)*i2978;
		v[1542] = (*a4)*i2976;
		v[1543] = (*a4)*i2979;
		v[1544] = (*a4)*i2977;
		v[1545] = (*a4)*i2975;
		v[1558] = i2955 + v[1521];
		v[1559] = -i2955 + v[1521];
		v[1560] = i2956 + v[1523];
		v[1561] = -i2956 + v[1523];
		v[1562] = -i2957 + v[1525];
		v[1563] = i2957 + v[1525];
		v[1565] = v[1528] * v[1564] + 8e0*i2955*v[966];
		v[1566] = 2e0*alphaA[1] * i2957 - v[1528];
		v[1568] = v[1528] * v[1567] - 8e0*i2957*v[966];
		v[1570] = v[1528] * v[1569] + 8e0*i2956*v[966];
		v[1571] = -4e0*v[1528] * v[966];
		v[3130] = -v[1571] / 2e0;
		v[1603] = 2e0*v[1571] * v[218];
		v[2973] = v[1603] * v[307];
		v[1572] = i2958 + v[1531];
		v[1573] = -i2958 + v[1531];
		v[1574] = i2959 + v[1533];
		v[1575] = -i2959 + v[1533];
		v[1576] = -i2960 + v[1535];
		v[1577] = i2960 + v[1535];
		v[1579] = v[1538] * v[1578] + 8e0*i2958*v[981];
		v[1580] = 2e0*alphaB[1] * i2960 - v[1538];
		v[1582] = v[1538] * v[1581] - 8e0*i2960*v[981];
		v[1584] = v[1538] * v[1583] + 8e0*i2959*v[981];
		v[1585] = -4e0*v[1538] * v[981];
		v[3133] = -v[1585] / 2e0;
		v[1653] = 2e0*v[1585] * v[258];
		v[2974] = v[1653] * v[333];
		v[1586] = -(i2957*v[218]) - (v[1571] * v[402]) / 2e0;
		v[2964] = 2e0*v[1586];
		v[2963] = -2e0*(v[2962] - (v[1571] * v[399]) / 2e0);
		v[2965] = -2e0*(v[2961] - (v[1571] * v[404]) / 2e0);
		v[1589] = -(alphaA[2] * v[1571]) / 2e0 + v[2961] / 2e0;
		v[1590] = -(alphaA[0] * v[1571]) / 2e0 + v[2962] / 2e0;
		v[1591] = -v[1586] / 2e0;
		v[1592] = (v[1529] * v[218] + v[1571] * v[414]) / 2e0;
		v[1612] = v[1592] * v[310];
		v[1593] = (v[1566] * v[218] + v[1571] * v[433]) / 2e0;
		v[1620] = v[1593] * v[316];
		v[1594] = (v[1526] * v[218] + v[1571] * v[451]) / 2e0;
		v[1628] = v[1594] * v[318];
		v[1595] = v[1560] * v[218] + v[1571] * v[446];
		v[2966] = v[1628] + v[1595] * v[316];
		v[1596] = v[1562] * v[218] + v[1571] * v[442];
		v[1631] = v[1596] * v[310];
		v[1597] = v[1561] * v[218] + v[1571] * v[438];
		v[1598] = v[1558] * v[218] + v[1571] * v[429];
		v[1622] = v[1598] * v[310];
		v[1599] = v[1563] * v[218] + v[1571] * v[425];
		v[1600] = v[1603] + 2e0*v[1589] * v[424];
		v[1601] = v[1559] * v[218] + v[1571] * v[419];
		v[1614] = v[1601] * v[316];
		v[1602] = v[1589] * v[421] + v[1590] * v[424];
		v[1604] = v[1603] + 2e0*v[1590] * v[421];
		v[1706] = v[1175] * v[1604];
		v[1605] = -(v[1590] * v[418]) - v[1591] * v[421];
		v[1606] = -(v[1589] * v[418]) - v[1591] * v[424];
		v[1607] = v[1603] + 2e0*v[1591] * v[418];
		v[1710] = v[1174] * v[1607];
		v[1608] = -(v[1206] * (v[1590] + v[1563] * v[413] + v[1565] * v[425])) + v[1205] * (v[1571] + v[1563] * v[412]
			+ v[1568] * v[425]) - v[1207] * (v[1589] + v[1563] * v[411] + v[1570] * v[425]) + v[1209] * (v[1591] - v[1561] * v[413]
				- v[1565] * v[438]) + v[1211] * (-v[1589] + v[1561] * v[412] + v[1568] * v[438]) - v[1208] * (v[1571] + v[1561] * v[411]
					+ v[1570] * v[438]) - (v[1210] * (v[1526] * v[413] + v[1565] * v[451])) / 2e0 + (v[1213] * (v[2964] + v[1526] * v[412]
						+ v[1568] * v[451])) / 2e0 - (v[1212] * (v[2963] + v[1526] * v[411] + v[1570] * v[451])) / 2e0;
		v[1609] = -(v[1206] * (v[1571] + v[1559] * v[413] + v[1565] * v[419])) + v[1205] * (-v[1590] + v[1559] * v[412]
			+ v[1568] * v[419]) + v[1207] * (v[1591] - v[1559] * v[411] - v[1570] * v[419]) - (v[1209] * (v[2965] + v[1566] * v[413]
				+ v[1565] * v[433])) / 2e0 + (v[1211] * (v[1566] * v[412] + v[1568] * v[433])) / 2e0 - (v[1208] * (v[2963]
					+ v[1566] * v[411] + v[1570] * v[433])) / 2e0 + v[1210] * (v[1591] - v[1560] * v[413] - v[1565] * v[446]) + v[1213] * (
						-v[1589] + v[1560] * v[412] + v[1568] * v[446]) + v[1212] * (v[1571] - v[1560] * v[411] - v[1570] * v[446]);
		v[1610] = -(v[1206] * (v[2965] + v[1529] * v[413] + v[1565] * v[414])) / 2e0 + (v[1205] * (v[2964] + v[1529] * v[412]
			+ v[1568] * v[414])) / 2e0 - (v[1207] * (v[1529] * v[411] + v[1570] * v[414])) / 2e0 + v[1209] * (v[1571]
				- v[1558] * v[413] - v[1565] * v[429]) + v[1211] * (-v[1590] + v[1558] * v[412] + v[1568] * v[429]) + v[1208] * (v[1591]
					- v[1558] * v[411] - v[1570] * v[429]) - v[1210] * (v[1590] + v[1562] * v[413] + v[1565] * v[442]) + v[1213] * (-v[1571]
						+ v[1562] * v[412] + v[1568] * v[442]) - v[1212] * (v[1589] + v[1562] * v[411] + v[1570] * v[442]);
		v[1611] = v[1612] + v[1614];
		v[1613] = v[1612] + v[1599] * v[318];
		v[1615] = v[1613] + v[1614] + v[3061];
		v[1616] = QAi[0][0] * v[1592] + QAi[2][0] * v[1599] + QAi[1][0] * v[1601];
		v[1617] = QAi[0][1] * v[1592] + QAi[2][1] * v[1599] + QAi[1][1] * v[1601];
		v[1618] = QAi[0][2] * v[1592] + QAi[2][2] * v[1599] + QAi[1][2] * v[1601];
		v[1619] = v[1620] + v[1622];
		v[1621] = v[1620] + v[1597] * v[318];
		v[1623] = v[1621] + v[1622] + v[3060];
		v[1624] = QAi[1][0] * v[1593] + QAi[2][0] * v[1597] + QAi[0][0] * v[1598];
		v[1625] = QAi[1][1] * v[1593] + QAi[2][1] * v[1597] + QAi[0][1] * v[1598];
		v[1626] = QAi[1][2] * v[1593] + QAi[2][2] * v[1597] + QAi[0][2] * v[1598];
		v[1627] = v[1631] + v[2966] + v[3062];
		v[1632] = v[1628] + v[1631];
		v[1633] = QAi[2][0] * v[1594] + QAi[1][0] * v[1595] + QAi[0][0] * v[1596];
		v[2993] = v[1149] * v[1616] + v[1150] * v[1624] + v[1151] * v[1633];
		v[1634] = QAi[2][1] * v[1594] + QAi[1][1] * v[1595] + QAi[0][1] * v[1596];
		v[2994] = v[1149] * v[1617] + v[1150] * v[1625] + v[1151] * v[1634];
		v[1635] = QAi[2][2] * v[1594] + QAi[1][2] * v[1595] + QAi[0][2] * v[1596];
		v[2995] = v[1149] * v[1618] + v[1150] * v[1626] + v[1151] * v[1635];
		v[1636] = -(i2960*v[258]) - (v[1585] * v[408]) / 2e0;
		v[2970] = 2e0*v[1636];
		v[2969] = -2e0*(v[2968] - (v[1585] * v[405]) / 2e0);
		v[2971] = -2e0*(v[2967] - (v[1585] * v[410]) / 2e0);
		v[1639] = -(alphaB[2] * v[1585]) / 2e0 + v[2967] / 2e0;
		v[1640] = -(alphaB[0] * v[1585]) / 2e0 + v[2968] / 2e0;
		v[1641] = -v[1636] / 2e0;
		v[1642] = (v[1539] * v[258] + v[1585] * v[513]) / 2e0;
		v[1662] = v[1642] * v[336];
		v[1643] = (v[1580] * v[258] + v[1585] * v[532]) / 2e0;
		v[1670] = v[1643] * v[342];
		v[1644] = (v[1536] * v[258] + v[1585] * v[550]) / 2e0;
		v[1678] = v[1644] * v[344];
		v[1645] = v[1574] * v[258] + v[1585] * v[545];
		v[2972] = v[1678] + v[1645] * v[342];
		v[1646] = v[1576] * v[258] + v[1585] * v[541];
		v[1681] = v[1646] * v[336];
		v[1647] = v[1575] * v[258] + v[1585] * v[537];
		v[1648] = v[1572] * v[258] + v[1585] * v[528];
		v[1672] = v[1648] * v[336];
		v[1649] = v[1577] * v[258] + v[1585] * v[524];
		v[1650] = v[1653] + 2e0*v[1639] * v[523];
		v[1651] = v[1573] * v[258] + v[1585] * v[518];
		v[1664] = v[1651] * v[342];
		v[1652] = v[1639] * v[520] + v[1640] * v[523];
		v[1654] = v[1653] + 2e0*v[1640] * v[520];
		v[1734] = v[1172] * v[1654];
		v[1655] = -(v[1640] * v[517]) - v[1641] * v[520];
		v[1656] = -(v[1639] * v[517]) - v[1641] * v[523];
		v[1657] = v[1653] + 2e0*v[1641] * v[517];
		v[1738] = v[1171] * v[1657];
		v[1658] = v[1197] * (v[1640] + v[1577] * v[512] + v[1579] * v[524]) - v[1196] * (v[1585] + v[1577] * v[511]
			+ v[1582] * v[524]) + v[1198] * (v[1639] + v[1577] * v[510] + v[1584] * v[524]) + v[1200] * (-v[1641] + v[1575] * v[512]
				+ v[1579] * v[537]) - v[1202] * (-v[1639] + v[1575] * v[511] + v[1582] * v[537]) + v[1199] * (v[1585] + v[1575] * v[510]
					+ v[1584] * v[537]) + (v[1201] * (v[1536] * v[512] + v[1579] * v[550])) / 2e0 - (v[1204] * (v[2970] + v[1536] * v[511]
						+ v[1582] * v[550])) / 2e0 + (v[1203] * (v[2969] + v[1536] * v[510] + v[1584] * v[550])) / 2e0;
		v[1659] = v[1197] * (v[1585] + v[1573] * v[512] + v[1579] * v[518]) - v[1196] * (-v[1640] + v[1573] * v[511]
			+ v[1582] * v[518]) + v[1198] * (-v[1641] + v[1573] * v[510] + v[1584] * v[518]) + (v[1200] * (v[2971] + v[1580] * v[512]
				+ v[1579] * v[532])) / 2e0 - (v[1202] * (v[1580] * v[511] + v[1582] * v[532])) / 2e0 + (v[1199] * (v[2969]
					+ v[1580] * v[510] + v[1584] * v[532])) / 2e0 + v[1201] * (-v[1641] + v[1574] * v[512] + v[1579] * v[545]) - v[1204] * (
						-v[1639] + v[1574] * v[511] + v[1582] * v[545]) + v[1203] * (-v[1585] + v[1574] * v[510] + v[1584] * v[545]);
		v[1660] = (v[1197] * (v[2971] + v[1539] * v[512] + v[1579] * v[513])) / 2e0 - (v[1196] * (v[2970] + v[1539] * v[511]
			+ v[1582] * v[513])) / 2e0 + (v[1198] * (v[1539] * v[510] + v[1584] * v[513])) / 2e0 + v[1200] * (-v[1585]
				+ v[1572] * v[512] + v[1579] * v[528]) - v[1202] * (-v[1640] + v[1572] * v[511] + v[1582] * v[528]) + v[1199] * (-v[1641]
					+ v[1572] * v[510] + v[1584] * v[528]) + v[1201] * (v[1640] + v[1576] * v[512] + v[1579] * v[541]) - v[1204] * (-v[1585]
						+ v[1576] * v[511] + v[1582] * v[541]) + v[1203] * (v[1639] + v[1576] * v[510] + v[1584] * v[541]);
		v[1661] = v[1662] + v[1664];
		v[1663] = v[1662] + v[1649] * v[344];
		v[1665] = v[1663] + v[1664] + v[3053];
		v[1666] = QBi[0][0] * v[1642] + QBi[2][0] * v[1649] + QBi[1][0] * v[1651];
		v[1667] = QBi[0][1] * v[1642] + QBi[2][1] * v[1649] + QBi[1][1] * v[1651];
		v[1668] = QBi[0][2] * v[1642] + QBi[2][2] * v[1649] + QBi[1][2] * v[1651];
		v[1669] = v[1670] + v[1672];
		v[1671] = v[1670] + v[1647] * v[344];
		v[1673] = v[1671] + v[1672] + v[3052];
		v[1674] = QBi[1][0] * v[1643] + QBi[2][0] * v[1647] + QBi[0][0] * v[1648];
		v[1675] = QBi[1][1] * v[1643] + QBi[2][1] * v[1647] + QBi[0][1] * v[1648];
		v[1676] = QBi[1][2] * v[1643] + QBi[2][2] * v[1647] + QBi[0][2] * v[1648];
		v[1677] = v[1681] + v[2972] + v[3054];
		v[1682] = v[1678] + v[1681];
		v[1683] = QBi[2][0] * v[1644] + QBi[1][0] * v[1645] + QBi[0][0] * v[1646];
		v[2996] = v[1149] * v[1666] + v[1150] * v[1674] + v[1151] * v[1683];
		v[1684] = QBi[2][1] * v[1644] + QBi[1][1] * v[1645] + QBi[0][1] * v[1646];
		v[2997] = v[1149] * v[1667] + v[1150] * v[1675] + v[1151] * v[1684];
		v[1685] = QBi[2][2] * v[1644] + QBi[1][2] * v[1645] + QBi[0][2] * v[1646];
		v[2998] = v[1149] * v[1668] + v[1150] * v[1676] + v[1151] * v[1685];
		v[1686] = v[1568] + v[1602];
		v[1704] = v[1175] * v[1686];
		v[1687] = -v[1568] + v[1602];
		v[1689] = (v[1686] * v[232] + v[1688] * v[2973] + v[1595] * v[305]) / v[307];
		v[1690] = v[1565] + v[1605];
		v[1712] = v[1175] * v[1690];
		v[1691] = -v[1565] + v[1605];
		v[1708] = v[1174] * v[1691];
		v[1693] = (v[1690] * v[228] + v[1692] * v[2973] + v[1597] * v[306]) / v[307];
		v[1695] = (v[1691] * v[223] + v[1599] * v[2835] + v[1694] * v[2973]) / v[307];
		v[1696] = v[1706] + v[1708];
		v[3113] = v[1696] / v[307];
		v[1697] = v[1570] + v[1606];
		v[1702] = v[1174] * v[1697];
		v[1698] = -v[1570] + v[1606];
		v[1699] = v[1710] + v[1712];
		v[3109] = v[1699] / v[307];
		v[1700] = v[1173] * v[1600] + v[1702] + v[1704];
		v[3117] = v[1700] / v[307];
		v[1703] = v[1700] - v[1704];
		v[1705] = v[1700] - v[1702];
		v[3110] = v[1705] / v[307];
		v[1707] = v[1173] * v[1687] + v[1706];
		v[1709] = v[1707] + v[1708];
		v[3111] = v[1709] / v[307];
		v[1711] = v[1173] * v[1698] + v[1710];
		v[1713] = v[1711] + v[1712];
		v[3114] = v[1713] / v[307];
		v[1714] = v[1582] + v[1652];
		v[1732] = v[1172] * v[1714];
		v[1715] = -v[1582] + v[1652];
		v[1717] = (v[1714] * v[272] + v[1716] * v[2974] + v[1645] * v[331]) / v[333];
		v[1718] = v[1579] + v[1655];
		v[1740] = v[1172] * v[1718];
		v[1719] = -v[1579] + v[1655];
		v[1736] = v[1171] * v[1719];
		v[1721] = (v[1718] * v[268] + v[1720] * v[2974] + v[1647] * v[332]) / v[333];
		v[1723] = (v[1719] * v[263] + v[1649] * v[2840] + v[1722] * v[2974]) / v[333];
		v[1724] = v[1734] + v[1736];
		v[3125] = v[1724] / v[333];
		v[1725] = v[1584] + v[1656];
		v[1730] = v[1171] * v[1725];
		v[1726] = -v[1584] + v[1656];
		v[1727] = v[1738] + v[1740];
		v[3121] = v[1727] / v[333];
		v[1728] = v[1170] * v[1650] + v[1730] + v[1732];
		v[3129] = v[1728] / v[333];
		v[1731] = v[1728] - v[1732];
		v[1733] = v[1728] - v[1730];
		v[3122] = v[1733] / v[333];
		v[1735] = v[1170] * v[1715] + v[1734];
		v[1737] = v[1735] + v[1736];
		v[3123] = v[1737] / v[333];
		v[1739] = v[1170] * v[1726] + v[1738];
		v[1741] = v[1739] + v[1740];
		v[3126] = v[1741] / v[333];
		v[1743] = i2989 + GAp[0] * v[1616] + GAp[1] * v[1617] + GAp[2] * v[1618] - GBp[0] * v[1666] - GBp[1] * v[1667]
			- GBp[2] * v[1668];
		v[1746] = i2988 + GAp[0] * v[1624] + GAp[1] * v[1625] + GAp[2] * v[1626] - GBp[0] * v[1674] - GBp[1] * v[1675]
			- GBp[2] * v[1676];
		v[1749] = i2987 + GAp[0] * v[1633] + GAp[1] * v[1634] + GAp[2] * v[1635] - GBp[0] * v[1683] - GBp[1] * v[1684]
			- GBp[2] * v[1685];
		v[3050] = v[1743] * v[356] + v[1746] * v[357] + v[1749] * v[358];
		v[1751] = v[3050] / v[1293];
		v[2981] = v[1751] * v[369];
		v[1761] = v[2981] * v[358] + v[1749] * v[370];
		v[1757] = v[2981] * v[357] + v[1746] * v[370];
		v[1753] = v[2981] * v[356] + v[1743] * v[370];
		v[1752] = 2e0*v[1753] * v[371];
		v[1754] = 2e0*v[1192] * v[1753];
		v[1755] = v[1753];
		v[1756] = 2e0*v[1757] * v[372];
		v[1758] = 2e0*v[1193] * v[1757];
		v[1759] = v[1757];
		v[1760] = 2e0*v[1761] * v[373];
		v[1762] = 2e0*v[1194] * v[1761];
		v[1763] = v[1761];
		v[1764] = 0e0;
		v[1765] = 0e0;
		v[1766] = 0e0;
		v[1767] = 0e0;
		v[1768] = 0e0;
		v[1769] = 0e0;
		v[1770] = 0e0;
		v[1771] = 0e0;
		v[1772] = 0e0;
		v[1773] = 0e0;
		v[1774] = 0e0;
		v[1775] = 0e0;
		v[1776] = 0e0;
		v[1777] = 0e0;
		v[1778] = 0e0;
		v[1779] = 0e0;
		v[1780] = 0e0;
		v[1781] = 0e0;
		v[1782] = 0e0;
		v[1783] = 0e0;
		v[1784] = 0e0;
		v[1785] = 0e0;
		v[1786] = 0e0;
		v[1787] = 0e0;
		v[1788] = 0e0;
		v[1789] = 0e0;
		v[1790] = 0e0;
		v[1791] = 0e0;
		v[1792] = 0e0;
		v[1793] = 0e0;
		v[1794] = 0e0;
		v[1795] = 0e0;
		b1796 = b709;
		if (b1796) {
			v[1799] = v[1763];
			v[1797] = v[1759];
			v[1798] = v[1763] * v[381] - v[1797] * v[382];
			v[1800] = -(v[1799] * v[380]) + v[1755] * v[382];
			v[1801] = v[1797] * v[380] - v[1755] * v[381];
			v[2985] = v[1284] * v[1798] + v[1279] * v[1800] + v[1274] * v[1801];
			v[2983] = v[1798] * v[711] + v[1800] * v[712] + v[1801] * v[713];
			v[1802] = v[2983] / v[714];
			v[2984] = v[1802] * v[3213];
			v[1812] = v[1802] * v[2982];
			v[1767] = -(v[1287] * v[1803] * v[2983]);
			v[1804] = v[1798] * v[2888] + v[2984] * v[711];
			v[1823] = 2e0*v[1804] * v[723];
			v[1806] = v[1800] * v[2888] + v[2984] * v[712];
			v[1820] = 2e0*v[1806] * v[724];
			v[1807] = v[1801] * v[2888] + v[2984] * v[713];
			v[1821] = 2e0*v[1807] * v[725];
			v[1770] = v[1812] * v[2918] + v[2985] * v[716];
			v[1769] = v[1802] * v[1810] * v[720];
			v[1768] = v[1802] * v[2918] * v[721] + v[2985] * v[722];
			v[1794] = 2e0*v[1812] * v[1813] * v[3214];
			v[1795] = v[1286] * v[1802] * v[1808] * v[1813] * v[3215];
			v[1766] = v[1274] * v[2984] + v[1801] * v[2986];
			v[1765] = v[1279] * v[2984] + v[1800] * v[2986];
			v[1764] = v[1284] * v[2984] + v[1798] * v[2986];
			v[1815] = (v[1806] * v[723] + v[1804] * v[724]) / 2e0;
			v[1816] = v[1820] + v[1823];
			v[1817] = v[1816] + v[1821];
			v[1818] = (v[1807] * v[723] + v[1804] * v[725]) / 2e0;
			v[1819] = (v[1807] * v[724] + v[1806] * v[725]) / 2e0;
			v[1822] = v[1820] + v[1821];
			v[1824] = v[1821] + v[1823];
			v[1773] = (v[1259] * v[1804] + v[1258] * v[1806] + 4e0*v[1807] * v[1825]) / 2e0;
			v[1772] = (v[1260] * v[1804] + v[1258] * v[1807] + 4e0*v[1806] * v[1826]) / 2e0;
			v[1771] = (v[1260] * v[1806] + v[1259] * v[1807] + 4e0*v[1804] * v[1827]) / 2e0;
			v[1828] = -4e0*v[1817] * v[2106];
			v[1793] = 8e0*v[1270] * v[1817] * v[3216];
			v[1784] = (v[1214] * v[1828]) / 2e0;
			v[1788] = (v[1218] * v[1828]) / 2e0;
			v[1786] = v[1216] * v[1828];
			v[1790] = v[1220] * v[1828];
			v[1789] = v[1219] * v[1828];
			v[1791] = v[1221] * v[1828];
			v[1785] = v[1215] * v[1828];
			v[1787] = v[1217] * v[1828];
			v[1792] = (v[1222] * v[1828]) / 2e0;
			v[1829] = -v[1807] + v[1815];
			v[1830] = v[1807] + v[1815];
			v[1831] = v[1806] + v[1818];
			v[1832] = -v[1806] + v[1818];
			v[1833] = -v[1804] + v[1819];
			v[1834] = v[1804] + v[1819];
			v[1776] = v[1262] * v[1828] + v[1829] * v[726];
			v[1778] = v[1264] * v[1828] + v[1830] * v[726];
			v[1777] = v[1263] * v[1828] + v[1831] * v[726];
			v[1781] = v[1267] * v[1828] + v[1832] * v[726];
			v[1775] = (v[1261] * v[1828] - v[1822] * v[726]) / 2e0;
			v[1780] = v[1266] * v[1828] + v[1833] * v[726];
			v[1782] = v[1268] * v[1828] + v[1834] * v[726];
			v[1779] = (v[1265] * v[1828] - v[1824] * v[726]) / 2e0;
			v[1783] = (v[1269] * v[1828] - v[1816] * v[726]) / 2e0;
			v[1774] = -(v[1222] * v[1816]) / 2e0 - (v[1214] * v[1822]) / 2e0 - (v[1218] * v[1824]) / 2e0 + v[1215] * v[1829]
				+ v[1217] * v[1830] + v[1216] * v[1831] + v[1220] * v[1832] + v[1219] * v[1833] + v[1221] * v[1834];
		}
		else {
		};
		v[1835] = 0e0;
		v[1836] = 0e0;
		v[1837] = 0e0;
		v[1838] = 0e0;
		v[1839] = 0e0;
		v[1840] = 0e0;
		b1841 = (previouscontact);
		if (b1841) {
			v[1865] = v[1760];
			v[1862] = v[1756];
			v[1860] = v[1752];
			v[1859] = v[1763];
			v[1853] = v[1759];
			v[1851] = v[1755];
			v[1849] = v[1776];
			v[1848] = v[1777];
			v[1846] = v[1779];
			v[1845] = v[1780];
			v[1843] = v[1782];
			v[1842] = v[1783];
			v[1857] = v[1188] * v[1851];
			v[1856] = v[1186] * v[1763];
			v[1854] = v[1187] * v[1759];
			v[1783] = 0e0;
			v[1782] = 0e0;
			v[1844] = i2987 + GAi[0] * v[1633] + GAi[1] * v[1634] + GAi[2] * v[1635] - GBi[0] * v[1683] - GBi[1] * v[1684]
				- GBi[2] * v[1685] + gti[0] * v[1781] + gti[2] * v[1842] + gti[1] * v[1843];
			v[2990] = -(v[1844] * v[373]) - v[1859] * v[746];
			v[1781] = 0e0;
			v[1780] = 0e0;
			v[1779] = 0e0;
			v[1847] = i2988 + GAi[0] * v[1624] + GAi[1] * v[1625] + GAi[2] * v[1626] - GBi[0] * v[1674] - GBi[1] * v[1675]
				- GBi[2] * v[1676] + gti[0] * v[1778] + gti[2] * v[1845] + gti[1] * v[1846];
			v[2992] = -(v[1847] * v[372]) - v[1853] * v[745];
			v[1778] = 0e0;
			v[1777] = 0e0;
			v[1776] = 0e0;
			v[1850] = i2989 + GAi[0] * v[1616] + GAi[1] * v[1617] + GAi[2] * v[1618] - GBi[0] * v[1666] - GBi[1] * v[1667]
				- GBi[2] * v[1668] + gti[0] * v[1775] + gti[2] * v[1848] + gti[1] * v[1849];
			v[2991] = -(v[1850] * v[371]) - v[1851] * v[744];
			v[1775] = 0e0;
			v[1852] = v[1854] + v[1857];
			v[1855] = v[1854] + v[1856];
			v[1858] = v[1856] + v[1857];
			v[1840] = v[1186] * v[1844];
			v[1839] = v[1187] * v[1847];
			v[1838] = v[1188] * v[1850];
			v[1835] = -(v[1188] * v[1860]) + v[1851] * v[1861] - v[1855] * v[371];
			v[1754] = v[1754] + v[1850] * v[1861] + v[1188] * (v[2990] + v[2992]) - v[1855] * v[744];
			v[1836] = -(v[1187] * v[1862]) + v[1853] * v[1864] - v[1858] * v[372];
			v[1758] = v[1758] + v[1847] * v[1864] + v[1187] * (v[2990] + v[2991]) - v[1858] * v[745];
			v[1837] = -(v[1186] * v[1865]) + v[1859] * v[1868] - v[1852] * v[373];
			v[1762] = v[1762] + v[1844] * v[1868] + v[1186] * (v[2991] + v[2992]) - v[1852] * v[746];
		}
		else {
		};
		v[1873] = v[1515] * v[1663] + v[1514] * v[1671] + v[1653] * v[1869] + v[1650] * v[1870] + v[1715] * v[1871]
			+ v[1726] * v[1872] + v[1677] * v[2411] + v[1721] * v[336] + v[1723] * v[342] + (*a4)*v[5099 + i1147];
		v[1878] = v[1513] * v[1661] + v[1653] * v[1874] + v[1657] * v[1875] + v[1719] * v[1876] + v[1725] * v[1877]
			+ v[1673] * v[2410] + v[1512] * v[2972] + v[1717] * v[336] + v[1723] * v[344] + (*a4)*v[5111 + i1147];
		v[1883] = v[1653] * v[1879] + v[1654] * v[1880] + v[1714] * v[1881] + v[1718] * v[1882] + v[1665] * v[2409]
			+ v[1669] * v[2841] + v[1682] * v[2843] + v[1717] * v[342] + v[1721] * v[344] + (*a4)*v[5123 + i1147];
		v[1888] = v[1509] * v[1613] + v[1508] * v[1621] + v[1603] * v[1884] + v[1600] * v[1885] + v[1687] * v[1886]
			+ v[1698] * v[1887] + v[1627] * v[2408] + v[1693] * v[310] + v[1695] * v[316] + (*a4)*v[5135 + i1147];
		v[1893] = v[1507] * v[1611] + v[1603] * v[1889] + v[1607] * v[1890] + v[1691] * v[1891] + v[1697] * v[1892]
			+ v[1623] * v[2407] + v[1506] * v[2966] + v[1689] * v[310] + v[1695] * v[318] + (*a4)*v[5147 + i1147];
		v[1898] = v[1603] * v[1894] + v[1604] * v[1895] + v[1686] * v[1896] + v[1690] * v[1897] + v[1615] * v[2406]
			+ v[1619] * v[2836] + v[1632] * v[2838] + v[1689] * v[316] + v[1693] * v[318] + (*a4)*v[5159 + i1147];
		b1899 = b764;
		if (b1899) {
			v[1755] = 0e0;
			v[1752] = 0e0;
			v[1759] = 0e0;
			v[1763] = 0e0;
			v[1756] = 0e0;
			v[1760] = 0e0;
		}
		else {
		};
		v[1900] = (*ct)*(dGAp[0][1] * v[2993] + dGAp[1][1] * v[2994] + dGAp[2][1] * v[2995]);
		v[3046] = v[1900] * v[670];
		v[3042] = v[1900] * v[672];
		v[3038] = v[1900] * v[674];
		v[1901] = (*ct)*(dGAp[0][0] * v[2993] + dGAp[1][0] * v[2994] + dGAp[2][0] * v[2995]);
		v[3047] = v[1901] * v[655];
		v[3043] = v[1901] * v[657];
		v[3039] = v[1901] * v[659];
		v[1902] = (*ct)*(dGBp[0][1] * v[2996] + dGBp[1][1] * v[2997] + dGBp[2][1] * v[2998]);
		v[3048] = -(v[1902] * v[700]);
		v[3044] = -(v[1902] * v[702]);
		v[3040] = -(v[1902] * v[704]);
		v[1903] = (*ct)*(dGBp[0][0] * v[2996] + dGBp[1][0] * v[2997] + dGBp[2][0] * v[2998]);
		v[3049] = -(v[1903] * v[685]);
		v[3045] = -(v[1903] * v[687]);
		v[3041] = -(v[1903] * v[689]);
		v[1904] = -(i2975*v[1098]) + i2976 * v[1098] - i2977 * v[1102] + i2978 * v[1102] - i2979 * v[1106] + i2980 * v[1106]
			- i2956 * v[1110] - i2957 * v[1114] - i2955 * v[1118] - i2959 * v[1134] - i2960 * v[1138] - i2958 * v[1142];
		v[1919] = v[1904];
		v[1905] = -(i2975*v[1099]) + i2976 * v[1099] - i2977 * v[1103] + i2978 * v[1103] - i2979 * v[1107] + i2980 * v[1107]
			- i2956 * v[1111] - i2957 * v[1115] - i2955 * v[1119] - i2959 * v[1135] - i2960 * v[1139] - i2958 * v[1143];
		v[1917] = v[1905];
		v[1906] = -(i2975*v[1100]) + i2976 * v[1100] - i2977 * v[1104] + i2978 * v[1104] - i2979 * v[1108] + i2980 * v[1108]
			- i2956 * v[1112] - i2957 * v[1116] - i2955 * v[1120] - i2959 * v[1136] - i2960 * v[1140] - i2958 * v[1144];
		v[1915] = v[1906];
		v[1907] = 0e0;
		v[1908] = 0e0;
		v[1909] = 0e0;
		v[1910] = 0e0;
		v[1911] = 0e0;
		v[1912] = 0e0;
		b1913 = (*stick);
		if (b1913) {
			b1914 = b782;
			if (b1914) {
				v[1912] = v[1906];
				v[1906] = 0e0;
				v[1911] = v[1905];
				v[1905] = 0e0;
				v[1910] = v[1904];
				v[1904] = 0e0;
			}
			else {
				v[2999] = (*mud)*(v[1919] * v[778] + v[1917] * v[779] + v[1915] * v[780]);
				v[1906] = 0e0;
				v[1905] = 0e0;
				v[3001] = v[1930] * v[2999] * v[793];
				v[1904] = 0e0;
				v[3000] = v[1928] * v[2999] * v[792] * v[797];
				v[1912] = v[1915] * v[1927] + v[3000] * v[780];
				v[1911] = v[1917] * v[1927] + v[3000] * v[779];
				v[1910] = v[1919] * v[1927] + v[3000] * v[778];
				v[1909] = v[3001] * v[771];
				v[1908] = v[3001] * v[770];
				v[1907] = v[3001] * v[769];
			};
		}
		else {
			b1931 = b816;
			if (b1931) {
				v[1912] = v[1915];
				v[1906] = 0e0;
				v[1911] = v[1917];
				v[1905] = 0e0;
				v[1910] = v[1919];
				v[1904] = 0e0;
			}
			else {
				v[1937] = v[1919] * v[3002];
				v[1935] = v[1917] * v[3002];
				v[1934] = v[1915] * v[3002];
				v[3004] = (*mud)*v[1940] * (v[1919] * v[778] + v[1917] * v[779] + v[1915] * v[780])*v[823];
				v[3003] = v[1936] * (v[1937] * v[778] + v[1935] * v[779] + v[1934] * v[780])*v[822];
				v[1912] = v[3003] * v[780] + v[1934] * v[823];
				v[1911] = v[3003] * v[779] + v[1935] * v[823];
				v[1910] = v[3003] * v[778] + v[1937] * v[823];
				v[1909] = v[3004] * v[771];
				v[1908] = v[3004] * v[770];
				v[1907] = v[3004] * v[769];
			};
		};
		v[3007] = -((*ct)*(-(v[1098] * v[1910]) - v[1099] * v[1911] - v[1100] * v[1912]));
		v[3006] = -((*ct)*(-(v[1102] * v[1910]) - v[1103] * v[1911] - v[1104] * v[1912]));
		v[3005] = -((*ct)*(-(v[1106] * v[1910]) - v[1107] * v[1911] - v[1108] * v[1912]));
		v[1942] = -((*ct)*(v[1151] * v[1873] + v[1912] * v[355])) - i2958 * v[786];
		v[1943] = -((*ct)*(v[1151] * v[1878] + v[1912] * v[345])) - i2960 * v[786];
		v[1944] = -((*ct)*(v[1151] * v[1883] + v[1912] * v[335])) - i2959 * v[786];
		v[1948] = -((*ct)*(v[1151] * v[1888] + v[1912] * v[329])) - i2955 * v[786];
		v[1949] = -((*ct)*(v[1151] * v[1893] + v[1912] * v[319])) - i2957 * v[786];
		v[1950] = -((*ct)*(v[1151] * v[1898] + v[1912] * v[309])) - i2956 * v[786];
		v[3035] = (*ct)*(v[1151] * v[1543] + v[1912] * v[300]) - (*ct)*(v[1151] * v[1540] + v[1912] * v[303]) + i2979 * v[786]
			- i2980 * v[786];
		v[3036] = (*ct)*(v[1151] * v[1544] + v[1912] * v[299]) - (*ct)*(v[1151] * v[1541] + v[1912] * v[302]) + i2977 * v[786]
			- i2978 * v[786];
		v[3037] = (*ct)*(v[1151] * v[1545] + v[1912] * v[298]) - (*ct)*(v[1151] * v[1542] + v[1912] * v[301]) + i2975 * v[786]
			- i2976 * v[786];
		v[1954] = -((*ct)*(v[1150] * v[1873] + v[1911] * v[355])) - i2958 * v[785];
		v[1955] = -((*ct)*(v[1150] * v[1878] + v[1911] * v[345])) - i2960 * v[785];
		v[1956] = -((*ct)*(v[1150] * v[1883] + v[1911] * v[335])) - i2959 * v[785];
		v[1960] = -((*ct)*(v[1150] * v[1888] + v[1911] * v[329])) - i2955 * v[785];
		v[1961] = -((*ct)*(v[1150] * v[1893] + v[1911] * v[319])) - i2957 * v[785];
		v[1962] = -((*ct)*(v[1150] * v[1898] + v[1911] * v[309])) - i2956 * v[785];
		v[3032] = (*ct)*(v[1150] * v[1543] + v[1911] * v[300]) - (*ct)*(v[1150] * v[1540] + v[1911] * v[303]) + i2979 * v[785]
			- i2980 * v[785];
		v[3033] = (*ct)*(v[1150] * v[1544] + v[1911] * v[299]) - (*ct)*(v[1150] * v[1541] + v[1911] * v[302]) + i2977 * v[785]
			- i2978 * v[785];
		v[3034] = (*ct)*(v[1150] * v[1545] + v[1911] * v[298]) - (*ct)*(v[1150] * v[1542] + v[1911] * v[301]) + i2975 * v[785]
			- i2976 * v[785];
		v[1966] = -((*ct)*(v[1149] * v[1873] + v[1910] * v[355])) - i2958 * v[784];
		v[1967] = -((*ct)*(v[1149] * v[1878] + v[1910] * v[345])) - i2960 * v[784];
		v[1968] = -((*ct)*(v[1149] * v[1883] + v[1910] * v[335])) - i2959 * v[784];
		v[1972] = -((*ct)*(v[1149] * v[1888] + v[1910] * v[329])) - i2955 * v[784];
		v[1973] = -((*ct)*(v[1149] * v[1893] + v[1910] * v[319])) - i2957 * v[784];
		v[1974] = -((*ct)*(v[1149] * v[1898] + v[1910] * v[309])) - i2956 * v[784];
		v[3029] = (*ct)*(v[1149] * v[1543] + v[1910] * v[300]) - (*ct)*(v[1149] * v[1540] + v[1910] * v[303]) + i2979 * v[784]
			- i2980 * v[784];
		v[3030] = (*ct)*(v[1149] * v[1544] + v[1910] * v[299]) - (*ct)*(v[1149] * v[1541] + v[1910] * v[302]) + i2977 * v[784]
			- i2978 * v[784];
		v[3031] = (*ct)*(v[1149] * v[1545] + v[1910] * v[298]) - (*ct)*(v[1149] * v[1542] + v[1910] * v[301]) + i2975 * v[784]
			- i2976 * v[784];
		v[1978] = -((*ct)*(v[1142] * v[1910] + v[1143] * v[1911] + v[1144] * v[1912]));
		v[1979] = -((*ct)*(v[1138] * v[1910] + v[1139] * v[1911] + v[1140] * v[1912]));
		v[1980] = -((*ct)*(v[1134] * v[1910] + v[1135] * v[1911] + v[1136] * v[1912]));
		v[1981] = -((*ct)*(v[1118] * v[1910] + v[1119] * v[1911] + v[1120] * v[1912]));
		v[1982] = -((*ct)*(v[1114] * v[1910] + v[1115] * v[1911] + v[1116] * v[1912]));
		v[1983] = -((*ct)*(v[1110] * v[1910] + v[1111] * v[1911] + v[1112] * v[1912]));
		v[1984] = v[3005];
		v[1985] = v[3006];
		v[1986] = v[3007];
		v[1987] = -v[3005];
		v[1988] = -v[3006];
		v[1989] = -v[3007];
		v[1993] = v[1909];
		v[1994] = v[1908];
		v[1995] = v[1907];
		v[1996] = 0e0;
		v[1997] = 0e0;
		v[1998] = 0e0;
		b1999 = b764;
		if (b1999) {
			v[3010] = (*cn)*v[1907];
			v[3009] = (*cn)*v[1908];
			v[3008] = (*cn)*v[1909];
			v[3013] = -v[1989] + v[1909] * v[2589] + v[1908] * v[2591] - v[3010] * v[749];
			v[3014] = v[1989] + v[3013];
			v[2042] = v[1907] * v[2857];
			v[3012] = -v[1988] + v[1909] * v[2043] + v[2042] * v[372] - v[3009] * v[751];
			v[3015] = v[1988] + v[3012];
			v[3011] = -v[1987] + v[1908] * v[2043] + v[2042] * v[373] - v[3008] * v[753];
			v[3016] = v[1987] + v[3011];
			v[1998] = v[2565] * v[3008];
			v[1997] = v[2567] * v[3009];
			v[1762] = v[1762] + (*cn)*(v[1907] * v[2569] + v[1908] * v[2570] + v[1909] * v[2571]);
			v[1758] = v[1758] + (*cn)*(v[1907] * v[2573] + v[1908] * v[2574] + v[1909] * v[2575]);
			v[1996] = v[2577] * v[3010];
			v[1754] = v[1754] + (*cn)*(v[1907] * v[2579] + v[1908] * v[2580] + v[1909] * v[2581]);
			v[1978] = v[1978] + (*cn)*(v[1907] * v[2024] + v[1908] * v[2025] + v[1909] * v[2026]);
			v[1979] = v[1979] + (*cn)*(v[1907] * v[2027] + v[1908] * v[2028] + v[1909] * v[2029]);
			v[1980] = v[1980] + (*cn)*(v[1907] * v[2030] + v[1908] * v[2031] + v[1909] * v[2032]);
			v[1981] = v[1981] + (*cn)*(v[1907] * v[2033] + v[1908] * v[2034] + v[1909] * v[2035]);
			v[1982] = v[1982] + (*cn)*(v[1907] * v[2036] + v[1908] * v[2037] + v[1909] * v[2038]);
			v[1983] = v[1983] + (*cn)*(v[1907] * v[2039] + v[1908] * v[2040] + v[1909] * v[2041]);
			v[1984] = v[3011];
			v[1985] = v[3012];
			v[1986] = v[3013];
			v[1987] = -v[3011];
			v[1988] = -v[3012];
			v[1989] = -v[3013];
			v[2053] = v[3014] * v[345];
			v[2054] = v[3014] * v[355];
			v[2055] = v[3014] * v[335];
			v[2056] = v[3015] * v[335];
			v[2057] = v[3015] * v[355];
			v[2058] = v[3016] * v[355];
			v[2059] = v[3015] * v[345];
			v[2060] = v[3016] * v[335];
			v[2061] = v[3016] * v[345];
			v[2062] = -(v[3014] * v[319]);
			v[2063] = -(v[3014] * v[329]);
			v[2064] = -(v[3014] * v[309]);
			v[2065] = -(v[3015] * v[309]);
			v[2066] = -(v[3015] * v[329]);
			v[2067] = -(v[3016] * v[329]);
			v[2068] = -(v[3015] * v[319]);
			v[2069] = -(v[3016] * v[309]);
			v[2070] = -(v[3016] * v[319]);
		}
		else {
			v[2064] = 0e0;
			v[2062] = 0e0;
			v[2063] = 0e0;
			v[2065] = 0e0;
			v[2068] = 0e0;
			v[2066] = 0e0;
			v[2069] = 0e0;
			v[2070] = 0e0;
			v[2067] = 0e0;
			v[2055] = 0e0;
			v[2053] = 0e0;
			v[2054] = 0e0;
			v[2056] = 0e0;
			v[2059] = 0e0;
			v[2057] = 0e0;
			v[2060] = 0e0;
			v[2061] = 0e0;
			v[2058] = 0e0;
			v[1993] = 0e0;
			v[1994] = 0e0;
			v[1995] = 0e0;
		};
		v[2071] = 0e0;
		v[2072] = 0e0;
		v[2073] = 0e0;
		v[2074] = 0e0;
		v[2075] = 0e0;
		v[2076] = 0e0;
		v[2077] = 0e0;
		v[2078] = 0e0;
		v[2079] = 0e0;
		b2080 = (previouscontact);
		if (b2080) {
			v[1992] = (*epst)*v[1910];
			v[3019] = v[1992] * v[371];
			v[1991] = (*epst)*v[1911];
			v[3018] = v[1991] * v[372];
			v[3020] = v[3018] + v[3019];
			v[1990] = (*epst)*v[1912];
			v[3017] = v[1990] * v[373];
			v[3022] = v[3017] + v[3018];
			v[3021] = v[3017] + v[3019];
			v[1840] = v[1840] + v[1990] * v[746];
			v[1839] = v[1839] + v[1991] * v[745];
			v[1835] = v[1835] + v[1224] * v[1992] - v[3022] * v[371];
			v[1836] = v[1836] + v[1226] * v[1991] - v[3021] * v[372];
			v[1837] = v[1837] + v[1228] * v[1990] - v[3020] * v[373];
			v[1838] = v[1838] + v[1992] * v[744];
			v[1762] = v[1762] + v[1990] * v[2915] - v[3020] * v[746];
			v[1758] = v[1758] + v[1991] * v[2916] - v[3021] * v[745];
			v[1754] = v[1754] - v[1992] * v[2917] - v[3022] * v[744];
			v[2071] = gti[0] * v[1835];
			v[2072] = gti[1] * v[1835];
			v[2073] = gti[2] * v[1835];
			v[2081] = -v[1835];
			v[2082] = -(GBi[2] * v[1835]);
			v[2083] = -(GBi[1] * v[1835]);
			v[2084] = -(GBi[0] * v[1835]);
			v[2085] = v[1835];
			v[2086] = GAi[2] * v[1835];
			v[2087] = GAi[1] * v[1835];
			v[2088] = GAi[0] * v[1835];
			v[2074] = gti[0] * v[1836];
			v[2075] = gti[1] * v[1836];
			v[2076] = gti[2] * v[1836];
			v[2089] = -v[1836];
			v[2090] = -(GBi[2] * v[1836]);
			v[2091] = -(GBi[1] * v[1836]);
			v[2092] = -(GBi[0] * v[1836]);
			v[2093] = v[1836];
			v[2094] = GAi[2] * v[1836];
			v[2095] = GAi[1] * v[1836];
			v[2096] = GAi[0] * v[1836];
			v[2077] = gti[0] * v[1837];
			v[2078] = gti[1] * v[1837];
			v[2079] = gti[2] * v[1837];
			v[2097] = -v[1837];
			v[2098] = -(GBi[2] * v[1837]);
			v[2099] = -(GBi[1] * v[1837]);
			v[2100] = -(GBi[0] * v[1837]);
			v[2101] = v[1837];
			v[2102] = GAi[2] * v[1837];
			v[2103] = GAi[1] * v[1837];
			v[2104] = GAi[0] * v[1837];
			v[1996] = -v[1838] + v[1996];
			v[1997] = -v[1839] + v[1997];
			v[1998] = -v[1840] + v[1998];
		}
		else {
			v[2088] = 0e0;
			v[2087] = 0e0;
			v[2086] = 0e0;
			v[2096] = 0e0;
			v[2095] = 0e0;
			v[2094] = 0e0;
			v[2104] = 0e0;
			v[2103] = 0e0;
			v[2102] = 0e0;
			v[2085] = 0e0;
			v[2093] = 0e0;
			v[2101] = 0e0;
			v[2084] = 0e0;
			v[2083] = 0e0;
			v[2082] = 0e0;
			v[2092] = 0e0;
			v[2091] = 0e0;
			v[2090] = 0e0;
			v[2100] = 0e0;
			v[2099] = 0e0;
			v[2098] = 0e0;
			v[2081] = 0e0;
			v[2089] = 0e0;
			v[2097] = 0e0;
		};
		b2105 = b709;
		if (b2105) {
			v[1792] = v[1792] + (v[2079] * v[726]) / 2e0;
			v[1791] = v[1791] + v[2078] * v[726];
			v[1790] = v[1790] + v[2077] * v[726];
			v[1789] = v[1789] + v[2076] * v[726];
			v[1788] = v[1788] + (v[2075] * v[726]) / 2e0;
			v[1787] = v[1787] + v[2074] * v[726];
			v[1786] = v[1786] + v[2073] * v[726];
			v[1785] = v[1785] + v[2072] * v[726];
			v[1774] = v[1774] + (v[1261] * v[2071]) / 2e0 + v[1262] * v[2072] + v[1263] * v[2073] + v[1264] * v[2074] +
				(v[1265] * v[2075]) / 2e0 + v[1266] * v[2076] + v[1267] * v[2077] + v[1268] * v[2078] + (v[1269] * v[2079]) / 2e0;
			v[1784] = v[1784] + (v[2071] * v[726]) / 2e0;
			v[1793] = v[1793] - 4e0*v[1774] * v[2106];
			v[3023] = v[1784] - v[1793];
			v[3025] = (v[1786] + v[1790]) / 2e0;
			v[3024] = (v[1789] + v[1791]) / 2e0;
			v[1773] = v[1773] - v[1785] + v[1787] + v[3025] * v[723] + v[3024] * v[724] - 2e0*(v[1788] + v[3023])*v[725];
			v[3026] = (v[1785] + v[1787]) / 2e0;
			v[1772] = v[1772] + v[1786] - v[1790] + v[3026] * v[723] - 2e0*(v[1792] + v[3023])*v[724] + v[3024] * v[725];
			v[1771] = v[1771] - v[1789] + v[1791] - 2e0*(v[1788] + v[1792] - v[1793])*v[723] + v[3026] * v[724]
				+ v[3025] * v[725];
			v[3027] = v[1771] * v[711] + v[1772] * v[712] + v[1773] * v[713];
			v[1770] = v[1770] + v[3027] * v[716];
			v[1768] = v[1768] + v[3027] * v[722];
			v[1769] = v[1769] + v[1770] * v[721];
			v[1794] = v[1794] + 2e0*v[1768] * v[1808];
			v[1795] = v[1795] + (v[1794] * v[1809]) / 2e0;
			v[1767] = v[1767] + v[1769] + v[1795];
			v[3028] = v[1767] / v[714];
			v[1766] = v[1766] + v[1773] * v[2888] + v[3028] * v[713];
			v[1765] = v[1765] + v[1772] * v[2888] + v[3028] * v[712];
			v[1764] = v[1764] + v[1771] * v[2888] + v[3028] * v[711];
			v[1754] = v[1754] - v[1766] * v[381] + v[1765] * v[382];
			v[1762] = v[1762] - v[1765] * v[380] + v[1764] * v[381];
			v[1758] = v[1758] + v[1766] * v[380] - v[1764] * v[382];
		}
		else {
		};
		v[2113] = -(v[1974] * v[682]) - v[1973] * v[683] - v[1972] * v[684] + v[3031] * v[685] + v[3030] * v[687]
			+ v[3029] * v[689] - v[1968] * v[691] - v[1967] * v[692] - v[1966] * v[693];
		v[2114] = -(v[1974] * v[697]) - v[1973] * v[698] - v[1972] * v[699] + v[3031] * v[700] + v[3030] * v[702]
			+ v[3029] * v[704] - v[1968] * v[706] - v[1967] * v[707] - v[1966] * v[708];
		v[2115] = v[1974] * v[652] + v[1973] * v[653] + v[1972] * v[654] - v[3031] * v[655] - v[3030] * v[657] - v[3029] * v[659]
			+ v[1968] * v[661] + v[1967] * v[662] + v[1966] * v[663];
		v[2116] = v[1974] * v[667] + v[1973] * v[668] + v[1972] * v[669] - v[3031] * v[670] - v[3030] * v[672] - v[3029] * v[674]
			+ v[1968] * v[676] + v[1967] * v[677] + v[1966] * v[678];
		v[2117] = -(v[1962] * v[682]) - v[1961] * v[683] - v[1960] * v[684] + v[3034] * v[685] + v[3033] * v[687]
			+ v[3032] * v[689] - v[1956] * v[691] - v[1955] * v[692] - v[1954] * v[693];
		v[2118] = -(v[1962] * v[697]) - v[1961] * v[698] - v[1960] * v[699] + v[3034] * v[700] + v[3033] * v[702]
			+ v[3032] * v[704] - v[1956] * v[706] - v[1955] * v[707] - v[1954] * v[708];
		v[2119] = v[1962] * v[652] + v[1961] * v[653] + v[1960] * v[654] - v[3034] * v[655] - v[3033] * v[657] - v[3032] * v[659]
			+ v[1956] * v[661] + v[1955] * v[662] + v[1954] * v[663];
		v[2120] = v[1962] * v[667] + v[1961] * v[668] + v[1960] * v[669] - v[3034] * v[670] - v[3033] * v[672] - v[3032] * v[674]
			+ v[1956] * v[676] + v[1955] * v[677] + v[1954] * v[678];
		v[2121] = -(v[1950] * v[682]) - v[1949] * v[683] - v[1948] * v[684] + v[3037] * v[685] + v[3036] * v[687]
			+ v[3035] * v[689] - v[1944] * v[691] - v[1943] * v[692] - v[1942] * v[693];
		v[2122] = -(v[1950] * v[697]) - v[1949] * v[698] - v[1948] * v[699] + v[3037] * v[700] + v[3036] * v[702]
			+ v[3035] * v[704] - v[1944] * v[706] - v[1943] * v[707] - v[1942] * v[708];
		v[2123] = v[1950] * v[652] + v[1949] * v[653] + v[1948] * v[654] - v[3037] * v[655] - v[3036] * v[657] - v[3035] * v[659]
			+ v[1944] * v[661] + v[1943] * v[662] + v[1942] * v[663];
		v[2124] = v[1950] * v[667] + v[1949] * v[668] + v[1948] * v[669] - v[3037] * v[670] - v[3036] * v[672] - v[3035] * v[674]
			+ v[1944] * v[676] + v[1943] * v[677] + v[1942] * v[678];
		v[1978] = v[1978] - v[1901] * v[663] - v[1900] * v[678] + v[1903] * v[693] + v[1902] * v[708];
		v[2206] = v[1978] * v[2834];
		v[1979] = v[1979] - v[1901] * v[662] - v[1900] * v[677] + v[1903] * v[692] + v[1902] * v[707];
		v[3056] = v[1979] * v[333];
		v[2210] = v[1979] * v[2833];
		v[1980] = v[1980] - v[1901] * v[661] - v[1900] * v[676] + v[1903] * v[691] + v[1902] * v[706];
		v[3059] = v[1980] * v[333];
		v[2213] = v[1980] * v[2832];
		v[1981] = v[1981] - v[1901] * v[654] - v[1900] * v[669] + v[1903] * v[684] + v[1902] * v[699];
		v[2272] = v[1981] * v[2831];
		v[1982] = v[1982] - v[1901] * v[653] - v[1900] * v[668] + v[1903] * v[683] + v[1902] * v[698];
		v[3064] = v[1982] * v[307];
		v[2276] = v[1982] * v[2830];
		v[1983] = v[1983] - v[1901] * v[652] - v[1900] * v[667] + v[1903] * v[682] + v[1902] * v[697];
		v[3067] = v[1983] * v[307];
		v[2279] = v[1983] * v[2829];
		v[1984] = v[1984] + v[3038] + v[3039] + v[3040] + v[3041];
		v[1985] = v[1985] + v[3042] + v[3043] + v[3044] + v[3045];
		v[1986] = v[1986] + v[3046] + v[3047] + v[3048] + v[3049];
		v[1987] = v[1987] - v[3038] - v[3039] - v[3040] - v[3041];
		v[1988] = v[1988] - v[3042] - v[3043] - v[3044] - v[3045];
		v[1989] = v[1989] - v[3046] - v[3047] - v[3048] - v[3049];
		v[5448] = v[1989];
		v[5449] = v[1988];
		v[5450] = v[1987];
		v[5451] = v[1174] * v[1689] + v[1173] * v[1693] + v[1603] * (v[2282] + v[1173] * v[2376] + v[1174] * v[2378])
			+ v[1983] * v[2406] + v[1982] * v[2836] + v[1981] * v[2838] + v[1592] * v[3106] + v[1596] * v[3107] + v[1598] * v[3108]
			+ v[225] * v[3109] + v[230] * v[3110] + v[221] * v[3111];
		v[5452] = v[1175] * v[1689] + v[1173] * v[1695] + v[1506] * v[1981] + v[1507] * v[1983] + v[1603] * (v[2275]
			+ v[1173] * v[2375] + v[1175] * v[2379]) + v[1982] * v[2407] + v[1595] * v[2934] + v[1601] * v[2936] + v[1593] * v[3112]
			+ v[222] * v[3113] + v[227] * v[3114] + v[1703] * v[3154];
		v[5453] = v[1175] * v[1693] + v[1174] * v[1695] + v[1508] * v[1982] + v[1509] * v[1983] + v[1603] * (v[2267]
			+ v[1174] * v[2377] + v[1175] * v[2380]) + v[1981] * v[2408] + v[1597] * v[2935] + v[1594] * v[3115] + v[1599] * v[3116]
			+ v[233] * v[3117] + v[1707] * v[3152] + v[1711] * v[3153];
		v[5454] = v[1986];
		v[5455] = v[1985];
		v[5456] = v[1984];
		v[5457] = v[1171] * v[1717] + v[1170] * v[1721] + v[1653] * (v[2216] + v[1170] * v[2344] + v[1171] * v[2346])
			+ v[1980] * v[2409] + v[1979] * v[2841] + v[1978] * v[2843] + v[1642] * v[3118] + v[1646] * v[3119] + v[1648] * v[3120]
			+ v[265] * v[3121] + v[270] * v[3122] + v[261] * v[3123];
		v[5458] = v[1172] * v[1717] + v[1170] * v[1723] + v[1512] * v[1978] + v[1513] * v[1980] + v[1653] * (v[2209]
			+ v[1170] * v[2343] + v[1172] * v[2347]) + v[1979] * v[2410] + v[1645] * v[2921] + v[1651] * v[2923] + v[1643] * v[3124]
			+ v[262] * v[3125] + v[267] * v[3126] + v[1731] * v[3151];
		v[5459] = v[1172] * v[1721] + v[1171] * v[1723] + v[1514] * v[1979] + v[1515] * v[1980] + v[1653] * (v[2201]
			+ v[1171] * v[2345] + v[1172] * v[2348]) + v[1978] * v[2411] + v[1647] * v[2922] + v[1644] * v[3127] + v[1649] * v[3128]
			+ v[273] * v[3129] + v[1735] * v[3149] + v[1739] * v[3150];
		v[1762] = v[1762] + 2e0*v[1998] * v[373];
		v[1758] = v[1758] + 2e0*v[1997] * v[372];
		v[1754] = v[1754] + 2e0*v[1996] * v[371];
		v[3051] = (-(v[1292] * v[2125] * v[3050]) + v[1751] * v[2126] * v[368] + (v[1189] * v[1743] + v[1190] * v[1746]
			+ v[1191] * v[1749] + v[1754] * v[356] + v[1758] * v[357] + v[1762] * v[358])*v[369]) / v[1293];
		v[2129] = (*epsn)*v[1993] + v[1749] * v[2920] + v[1191] * v[2981] + v[3051] * v[358] + v[1762] * v[370];
		v[2131] = (*epsn)*v[1994] + v[1746] * v[2920] + v[1190] * v[2981] + v[3051] * v[357] + v[1758] * v[370];
		v[2133] = (*epsn)*v[1995] + v[1743] * v[2920] + v[1189] * v[2981] + v[3051] * v[356] + v[1754] * v[370];
		v[2097] = v[2097] - v[2129];
		v[2101] = v[2101] + v[2129];
		v[2089] = v[2089] - v[2131];
		v[2093] = v[2093] + v[2131];
		v[2081] = v[2081] - v[2133];
		v[2085] = v[2085] + v[2133];
		v[2134] = v[1170] * v[3052] + v[1978] * v[342];
		v[2135] = v[1170] * v[3053] + v[1978] * v[336];
		v[2136] = v[1306] * v[1978] + v[1170] * (v[1653] * v[3057] + v[1671] / v[333]) + (v[2134] * v[267]) / v[333];
		v[2137] = v[1312] * v[1978] + v[1170] * (v[1653] * v[3316] + v[1663] / v[333]) + (v[2135] * v[261]) / v[333];
		v[2138] = (v[2135] * v[270] + v[2134] * v[272] + v[1170] * (v[1677] + v[2974] * v[3317]) + v[1302] * v[1978] * v[333])
			/ v[333];
		v[2139] = v[1171] * v[3054] + v[1979] * v[344];
		v[2140] = v[1171] * v[3053] + v[1979] * v[336];
		v[2143] = v[1301] * v[1979] + v[1171] * (v[1653] * v[3055] + v[2972] / v[333]) + (v[2139] * v[273]) / v[333];
		v[2144] = v[2134] + v[2139];
		v[2145] = v[2136] + v[2143];
		v[2147] = (v[1304] * v[1649] + v[2140] * v[261] + v[2144] * v[263] + v[2339] * v[2974] + v[1311] * v[3056] + v[1171] *
			(v[1661] + v[2974] * v[3058])) / v[333];
		v[2150] = (v[2140] * v[265] + v[2139] * v[268] + v[1305] * v[3056] + v[1171] * (v[1673] + v[2974] * v[3318])) / v[333];
		v[2151] = v[1172] * v[3052] + v[1980] * v[342];
		v[2152] = v[1172] * v[3054] + v[1980] * v[344];
		v[2153] = v[2140] + v[2151];
		v[2156] = (v[2151] * v[262] + v[2152] * v[263] + v[1309] * v[3059] + v[1172] * (v[1665] + v[2974] * v[3319])) / v[333];
		v[2157] = v[2135] + v[2152];
		v[2159] = (v[1314] * v[1647] + v[2151] * v[267] + v[2157] * v[268] + v[2338] * v[2974] + v[1316] * v[3059] + v[1172] *
			(v[1669] + v[2974] * v[3320])) / v[333];
		v[2160] = v[2147] + v[2159];
		v[2162] = (v[1315] * v[1645] + v[2153] * v[272] + v[2152] * v[273] + v[2337] * v[2974] + v[1319] * v[3059] + v[1172] *
			(v[1682] + v[2974] * v[3321])) / v[333];
		v[2163] = v[2137] + v[2162];
		v[2164] = v[1173] * v[3060] + v[1981] * v[316];
		v[2165] = v[1173] * v[3061] + v[1981] * v[310];
		v[2166] = v[1330] * v[1981] + v[1173] * (v[1603] * v[3065] + v[1621] / v[307]) + (v[2164] * v[227]) / v[307];
		v[2167] = v[1336] * v[1981] + (v[2165] * v[221]) / v[307] + v[1173] * (v[1613] / v[307] + v[1603] * v[3322]);
		v[2168] = (v[2165] * v[230] + v[2164] * v[232] + v[1326] * v[1981] * v[307] + v[1173] * (v[1627] + v[2973] * v[3323]))
			/ v[307];
		v[2169] = v[1174] * v[3062] + v[1982] * v[318];
		v[2170] = v[1174] * v[3061] + v[1982] * v[310];
		v[2173] = v[1325] * v[1982] + v[1174] * (v[1603] * v[3063] + v[2966] / v[307]) + (v[2169] * v[233]) / v[307];
		v[2174] = v[2164] + v[2169];
		v[2175] = v[2166] + v[2173];
		v[2177] = (v[1328] * v[1599] + v[2170] * v[221] + v[2174] * v[223] + v[2371] * v[2973] + v[1335] * v[3064] + v[1174] *
			(v[1611] + v[2973] * v[3066])) / v[307];
		v[2180] = (v[2170] * v[225] + v[2169] * v[228] + v[1329] * v[3064] + v[1174] * (v[1623] + v[2973] * v[3324])) / v[307];
		v[2181] = v[1175] * v[3060] + v[1983] * v[316];
		v[2182] = v[1175] * v[3062] + v[1983] * v[318];
		v[2183] = v[2170] + v[2181];
		v[2186] = (v[2181] * v[222] + v[2182] * v[223] + v[1333] * v[3067] + v[1175] * (v[1615] + v[2973] * v[3325])) / v[307];
		v[2187] = v[2165] + v[2182];
		v[2189] = (v[1338] * v[1597] + v[2181] * v[227] + v[2187] * v[228] + v[2370] * v[2973] + v[1340] * v[3067] + v[1175] *
			(v[1619] + v[2973] * v[3326])) / v[307];
		v[2190] = v[2177] + v[2189];
		v[2192] = (v[1339] * v[1595] + v[2183] * v[232] + v[2182] * v[233] + v[2369] * v[2973] + v[1343] * v[3067] + v[1175] *
			(v[1632] + v[2973] * v[3327])) / v[307];
		v[2193] = v[2167] + v[2192];
		v[2098] = v[2098] + dGBp[2][0] * v[2121] + dGBp[2][1] * v[2122] - GBp[2] * v[2129];
		v[2099] = v[2099] + dGBp[1][0] * v[2121] + dGBp[1][1] * v[2122] - GBp[1] * v[2129];
		v[2100] = v[2100] + dGBp[0][0] * v[2121] + dGBp[0][1] * v[2122] - GBp[0] * v[2129];
		v[2090] = v[2090] + dGBp[2][0] * v[2117] + dGBp[2][1] * v[2118] - GBp[2] * v[2131];
		v[2091] = v[2091] + dGBp[1][0] * v[2117] + dGBp[1][1] * v[2118] - GBp[1] * v[2131];
		v[2092] = v[2092] + dGBp[0][0] * v[2117] + dGBp[0][1] * v[2118] - GBp[0] * v[2131];
		v[2194] = v[1182] * v[1668] + v[1163] * v[1676] + v[1158] * v[1685] + v[2113] * v[279] + v[2117] * v[282]
			+ v[2121] * v[285];
		v[2195] = v[1182] * v[1667] + v[1163] * v[1675] + v[1158] * v[1684] + v[2113] * v[278] + v[2117] * v[281]
			+ v[2121] * v[284];
		v[2196] = v[1182] * v[1666] + v[1163] * v[1674] + v[1158] * v[1683] + v[2113] * v[277] + v[2117] * v[280]
			+ v[2121] * v[283];
		v[2082] = v[2082] + dGBp[2][0] * v[2113] + dGBp[2][1] * v[2114] - GBp[2] * v[2133];
		v[2083] = v[2083] + dGBp[1][0] * v[2113] + dGBp[1][1] * v[2114] - GBp[1] * v[2133];
		v[2084] = v[2084] + dGBp[0][0] * v[2113] + dGBp[0][1] * v[2114] - GBp[0] * v[2133];
		v[2197] = v[1183] * v[1668] + v[1165] * v[1676] + v[1159] * v[1685] + v[2114] * v[279] + v[2118] * v[282]
			+ v[2122] * v[285];
		v[2198] = v[1183] * v[1667] + v[1165] * v[1675] + v[1159] * v[1684] + v[2114] * v[278] + v[2118] * v[281]
			+ v[2122] * v[284];
		v[2199] = v[1183] * v[1666] + v[1165] * v[1674] + v[1159] * v[1683] + v[2114] * v[277] + v[2118] * v[280]
			+ v[2122] * v[283];
		v[2200] = QBi[2][2] * v[2098] + QBi[2][1] * v[2099] + QBi[2][0] * v[2100] + v[1512] * v[2139] + v[2152] * v[2843] +
			(v[3129] + v[1653] * v[3328])*v[344] + v[2206] * v[346];
		v[2203] = QBi[1][2] * v[2098] + QBi[1][1] * v[2099] + QBi[1][0] * v[2100] + v[2134] * v[2411] + v[1731] * v[2833]
			+ v[2153] * v[2843] + v[1653] * v[3329] + (v[1315] * v[1714]) / v[333] + v[2210] * v[343];
		v[2205] = QBi[0][2] * v[2098] + QBi[0][1] * v[2099] + QBi[0][0] * v[2100] + v[2135] * v[2411] + v[2213] * v[331] +
			(v[3122] + v[1653] * v[3330])*v[336];
		v[2207] = QBi[2][2] * v[2090] + QBi[2][1] * v[2091] + QBi[2][0] * v[2092] + v[2139] * v[2410] + v[1739] * v[2834]
			+ v[2157] * v[2841] + v[2206] * v[2844] + (v[1314] * v[1718]) / v[333] + v[1653] * v[3331];
		v[2211] = QBi[1][2] * v[2090] + QBi[1][1] * v[2091] + QBi[1][0] * v[2092] + v[1514] * v[2134] + v[2151] * v[2841]
			+ v[2210] * v[337] + (v[3126] + v[1653] * v[3332])*v[342];
		v[2214] = QBi[0][2] * v[2090] + QBi[0][1] * v[2091] + QBi[0][0] * v[2092] + v[2140] * v[2410] + v[2213] * v[332] +
			(v[3121] + v[1653] * v[3333])*v[336];
		v[2215] = QBi[2][2] * v[2082] + QBi[2][1] * v[2083] + QBi[2][0] * v[2084] + v[1513] * v[2144] + v[2152] * v[2409]
			+ v[1735] * v[2834] + v[2206] * v[2842] + (v[1304] * v[1719]) / v[333] + v[1653] * v[3334];
		v[2217] = QBi[1][2] * v[2082] + QBi[1][1] * v[2083] + QBi[1][0] * v[2084] + v[2151] * v[2409] + v[2210] * v[2840] +
			(v[1653] * v[3070] + v[3125])*v[342];
		v[2220] = QBi[0][2] * v[2082] + QBi[0][1] * v[2083] + QBi[0][0] * v[2084] + v[1515] * v[2135] + v[1513] * v[2140]
			+ v[2213] * v[334] + (v[3123] + v[1653] * v[3335])*v[336];
		v[2221] = -(v[2053] * v[860]);
		v[2222] = -(v[2053] * v[858]);
		v[2223] = -(v[2053] * v[856]);
		v[2224] = -(v[2054] * v[860]);
		v[2225] = -(v[2054] * v[856]);
		v[2226] = -(v[2054] * v[858]);
		v[2227] = -(v[2055] * v[858]);
		v[2228] = -(v[2055] * v[856]);
		v[2229] = -(v[2055] * v[860]);
		v[2230] = -(v[2056] * v[860]);
		v[2231] = -(v[2056] * v[858]);
		v[2232] = -(v[2056] * v[856]);
		v[2233] = -(v[2057] * v[856]);
		v[2234] = -(v[2057] * v[860]);
		v[2235] = -(v[2057] * v[858]);
		v[2236] = -(v[2058] * v[858]);
		v[2237] = -(v[2058] * v[860]);
		v[2238] = -(v[2058] * v[856]);
		v[2239] = -(v[1308] * v[1639]) - v[1318] * v[1640] + 2e0*v[1307] * v[1641] + v[2227] + v[2230] + v[2233] + v[2236]
			+ 2e0*v[2150] * v[517] - v[2160] * v[520] - v[2145] * v[523];
		v[2240] = -(v[2059] * v[860]);
		v[2241] = -(v[2059] * v[856]);
		v[2242] = -(v[2059] * v[858]);
		v[2243] = v[1321] * v[1639] + 2e0*v[1313] * v[1640] - v[1318] * v[1641] - v[2222] - v[2225] - v[2237] - v[2240]
			- v[2160] * v[517] + 2e0*v[2156] * v[520] + v[2163] * v[523];
		v[2244] = -(v[1375] * v[1579]) + v[1371] * v[1582] - v[1376] * v[1584] + v[1366] * v[1585] + v[2217] * v[258]
			- v[2227] * v[510] + v[2222] * v[511] - v[2226] * v[512];
		v[2245] = -(v[2060] * v[860]);
		v[2246] = -(v[2060] * v[858]);
		v[2247] = -(v[2060] * v[856]);
		v[2248] = -(v[2061] * v[858]);
		v[2249] = -(v[2061] * v[860]);
		v[2250] = -(v[2061] * v[856]);
		v[2251] = 2e0*v[1300] * v[1639] + v[1321] * v[1640] - v[1308] * v[1641] - v[2228] - v[2241] - v[2245] - v[2248]
			- v[2145] * v[517] + v[2163] * v[520] + 2e0*v[2138] * v[523];
		v[2252] = -(v[1374] * v[1579]) + v[1372] * v[1582] - v[1377] * v[1584] + v[1364] * v[1585] + v[2215] * v[258]
			- v[2228] * v[510] + v[2223] * v[511] - v[2225] * v[512];
		v[2253] = -(v[1383] * v[1579]) + v[1389] * v[1582] - v[1379] * v[1584] + v[1357] * v[1585] + v[2214] * v[258]
			- v[2230] * v[510] + v[2240] * v[511] - v[2234] * v[512];
		v[2254] = v[2224] + v[2235];
		v[2255] = -(v[1382] * v[1579]) + v[1390] * v[1582] - v[1381] * v[1584] + v[1352] * v[1585] + v[2207] * v[258]
			- v[2232] * v[510] + v[2241] * v[511] - v[2233] * v[512];
		v[2256] = -(v[1386] * v[1579]) + v[1398] * v[1582] - v[1394] * v[1584] + v[1351] * v[1585] + v[2205] * v[258]
			- v[2245] * v[510] + v[2249] * v[511] - v[2237] * v[512];
		v[2257] = -(v[1385] * v[1579]) + v[1397] * v[1582] - v[1395] * v[1584] + v[1349] * v[1585] + v[2203] * v[258]
			- v[2246] * v[510] + v[2248] * v[511] - v[2236] * v[512];
		v[2258] = v[2231] + v[2247];
		v[2259] = v[2221] + v[2250];
		v[2102] = v[2102] + dGAp[2][0] * v[2123] + dGAp[2][1] * v[2124] + GAp[2] * v[2129];
		v[2103] = v[2103] + dGAp[1][0] * v[2123] + dGAp[1][1] * v[2124] + GAp[1] * v[2129];
		v[2104] = v[2104] + dGAp[0][0] * v[2123] + dGAp[0][1] * v[2124] + GAp[0] * v[2129];
		v[2094] = v[2094] + dGAp[2][0] * v[2119] + dGAp[2][1] * v[2120] + GAp[2] * v[2131];
		v[2095] = v[2095] + dGAp[1][0] * v[2119] + dGAp[1][1] * v[2120] + GAp[1] * v[2131];
		v[2096] = v[2096] + dGAp[0][0] * v[2119] + dGAp[0][1] * v[2120] + GAp[0] * v[2131];
		v[2260] = v[1184] * v[1616] + v[1167] * v[1624] + v[1160] * v[1633] + v[2115] * v[237] + v[2119] * v[240]
			+ v[2123] * v[243];
		v[2261] = v[1184] * v[1617] + v[1167] * v[1625] + v[1160] * v[1634] + v[2115] * v[238] + v[2119] * v[241]
			+ v[2123] * v[244];
		v[2262] = v[1184] * v[1618] + v[1167] * v[1626] + v[1160] * v[1635] + v[2115] * v[239] + v[2119] * v[242]
			+ v[2123] * v[245];
		v[2086] = v[2086] + dGAp[2][0] * v[2115] + dGAp[2][1] * v[2116] + GAp[2] * v[2133];
		v[2087] = v[2087] + dGAp[1][0] * v[2115] + dGAp[1][1] * v[2116] + GAp[1] * v[2133];
		v[2088] = v[2088] + dGAp[0][0] * v[2115] + dGAp[0][1] * v[2116] + GAp[0] * v[2133];
		v[2263] = v[1185] * v[1616] + v[1169] * v[1624] + v[1161] * v[1633] + v[2116] * v[237] + v[2120] * v[240]
			+ v[2124] * v[243];
		v[2264] = v[1185] * v[1617] + v[1169] * v[1625] + v[1161] * v[1634] + v[2116] * v[238] + v[2120] * v[241]
			+ v[2124] * v[244];
		v[2265] = v[1185] * v[1618] + v[1169] * v[1626] + v[1161] * v[1635] + v[2116] * v[239] + v[2120] * v[242]
			+ v[2124] * v[245];
		v[2266] = QAi[2][2] * v[2102] + QAi[2][1] * v[2103] + QAi[2][0] * v[2104] + v[1506] * v[2169] + v[2182] * v[2838]
			+ v[2272] * v[320] + v[318] * (v[3117] + v[1603] * v[3336]);
		v[2269] = QAi[1][2] * v[2102] + QAi[1][1] * v[2103] + QAi[1][0] * v[2104] + v[2164] * v[2408] + v[1703] * v[2830]
			+ v[2183] * v[2838] + (v[1339] * v[1686]) / v[307] + v[2276] * v[317] + v[1603] * v[3337];
		v[2271] = QAi[0][2] * v[2102] + QAi[0][1] * v[2103] + QAi[0][0] * v[2104] + v[2165] * v[2408] + v[2279] * v[305]
			+ v[310] * (v[3110] + v[1603] * v[3338]);
		v[2273] = QAi[2][2] * v[2094] + QAi[2][1] * v[2095] + QAi[2][0] * v[2096] + v[2169] * v[2407] + v[1711] * v[2831]
			+ v[2187] * v[2836] + v[2272] * v[2839] + (v[1338] * v[1690]) / v[307] + v[1603] * v[3339];
		v[2277] = QAi[1][2] * v[2094] + QAi[1][1] * v[2095] + QAi[1][0] * v[2096] + v[1508] * v[2164] + v[2181] * v[2836]
			+ v[2276] * v[311] + v[316] * (v[3114] + v[1603] * v[3340]);
		v[2280] = QAi[0][2] * v[2094] + QAi[0][1] * v[2095] + QAi[0][0] * v[2096] + v[2170] * v[2407] + v[2279] * v[306]
			+ v[310] * (v[3109] + v[1603] * v[3341]);
		v[2281] = QAi[2][2] * v[2086] + QAi[2][1] * v[2087] + QAi[2][0] * v[2088] + v[1507] * v[2174] + v[2182] * v[2406]
			+ v[1707] * v[2831] + v[2272] * v[2837] + (v[1328] * v[1691]) / v[307] + v[1603] * v[3342];
		v[2283] = QAi[1][2] * v[2086] + QAi[1][1] * v[2087] + QAi[1][0] * v[2088] + v[2181] * v[2406] + v[2276] * v[2835] +
			(v[1603] * v[3073] + v[3113])*v[316];
		v[2286] = QAi[0][2] * v[2086] + QAi[0][1] * v[2087] + QAi[0][0] * v[2088] + v[1509] * v[2165] + v[1507] * v[2170]
			+ v[2279] * v[308] + v[310] * (v[3111] + v[1603] * v[3343]);
		v[2287] = v[2062] * v[872];
		v[2288] = v[2062] * v[870];
		v[2289] = v[2062] * v[868];
		v[2290] = v[2063] * v[872];
		v[2291] = v[2063] * v[868];
		v[2292] = v[2063] * v[870];
		v[2293] = v[2064] * v[870];
		v[2294] = v[2064] * v[868];
		v[2295] = v[2064] * v[872];
		v[2296] = v[2065] * v[872];
		v[2297] = v[2065] * v[870];
		v[2298] = v[2065] * v[868];
		v[2299] = v[2066] * v[868];
		v[2300] = v[2066] * v[872];
		v[2301] = v[2066] * v[870];
		v[2302] = v[2067] * v[870];
		v[2303] = v[2067] * v[872];
		v[2304] = v[2067] * v[868];
		v[2305] = -(v[1332] * v[1589]) - v[1342] * v[1590] + 2e0*v[1331] * v[1591] + v[2293] + v[2296] + v[2299] + v[2302]
			+ 2e0*v[2180] * v[418] - v[2190] * v[421] - v[2175] * v[424];
		v[2306] = v[2068] * v[872];
		v[2307] = v[2068] * v[868];
		v[2308] = v[2068] * v[870];
		v[2309] = v[1345] * v[1589] + 2e0*v[1337] * v[1590] - v[1342] * v[1591] - v[2288] - v[2291] - v[2303] - v[2306]
			- v[2190] * v[418] + 2e0*v[2186] * v[421] + v[2193] * v[424];
		v[2310] = -(v[1443] * v[1565]) + v[1439] * v[1568] - v[1444] * v[1570] + v[1434] * v[1571] + v[218] * v[2283]
			- v[2293] * v[411] + v[2288] * v[412] - v[2292] * v[413];
		v[2311] = v[2069] * v[872];
		v[2312] = v[2069] * v[870];
		v[2313] = v[2069] * v[868];
		v[2314] = v[2070] * v[870];
		v[2315] = v[2070] * v[872];
		v[2316] = v[2070] * v[868];
		v[2317] = 2e0*v[1324] * v[1589] + v[1345] * v[1590] - v[1332] * v[1591] - v[2294] - v[2307] - v[2311] - v[2314]
			- v[2175] * v[418] + v[2193] * v[421] + 2e0*v[2168] * v[424];
		v[2318] = -(v[1442] * v[1565]) + v[1440] * v[1568] - v[1445] * v[1570] + v[1432] * v[1571] + v[218] * v[2281]
			- v[2294] * v[411] + v[2289] * v[412] - v[2291] * v[413];
		v[2319] = -(v[1451] * v[1565]) + v[1457] * v[1568] - v[1447] * v[1570] + v[1425] * v[1571] + v[218] * v[2280]
			- v[2296] * v[411] + v[2306] * v[412] - v[2300] * v[413];
		v[2320] = v[2290] + v[2301];
		v[2321] = -(v[1450] * v[1565]) + v[1458] * v[1568] - v[1449] * v[1570] + v[1420] * v[1571] + v[218] * v[2273]
			- v[2298] * v[411] + v[2307] * v[412] - v[2299] * v[413];
		v[2322] = -(v[1454] * v[1565]) + v[1466] * v[1568] - v[1462] * v[1570] + v[1419] * v[1571] + v[218] * v[2271]
			- v[2311] * v[411] + v[2315] * v[412] - v[2303] * v[413];
		v[2323] = -(v[1453] * v[1565]) + v[1465] * v[1568] - v[1463] * v[1570] + v[1417] * v[1571] + v[218] * v[2269]
			- v[2312] * v[411] + v[2314] * v[412] - v[2302] * v[413];
		v[2324] = v[2297] + v[2313];
		v[2325] = v[2287] + v[2316];
		v[2326] = (-(v[1396] * v[1536]) - v[1378] * v[1539] - 2e0*v[1379] * v[1572] - 2e0*v[1376] * v[1573]
			- 2e0*v[1395] * v[1574] - 2e0*v[1381] * v[1575] - 2e0*v[1394] * v[1576] - 2e0*v[1377] * v[1577] - v[1380] * v[1580]
			- 2e0*v[2136] + 2e0*v[2143] - v[2229] * v[513] - 2e0*v[2227] * v[518] - 2e0*v[2228] * v[524] - 2e0*v[2230] * v[528]
			- v[2231] * v[532] - 2e0*v[2232] * v[537] - 2e0*v[2245] * v[541] - 2e0*v[2246] * v[545] - v[2247] * v[550]) / 2e0;
		v[2327] = (-(v[1373] * v[1579]) + v[1370] * v[1582] - v[1378] * v[1584] + v[1369] * v[1585] + v[2220] * v[258]
			- v[2229] * v[510] + v[2221] * v[511] - v[2224] * v[512]) / 2e0;
		v[2329] = (v[1399] * v[1536] + v[1370] * v[1539] + 2e0*v[1389] * v[1572] + 2e0*v[1371] * v[1573]
			+ 2e0*v[1397] * v[1574] + 2e0*v[1390] * v[1575] + 2e0*v[1398] * v[1576] + 2e0*v[1372] * v[1577] + v[1391] * v[1580]
			- 2e0*v[2137] + 2e0*v[2162] + v[2221] * v[513] + 2e0*v[2222] * v[518] + 2e0*v[2223] * v[524] + 2e0*v[2240] * v[528]
			+ v[2242] * v[532] + 2e0*v[2241] * v[537] + 2e0*v[2249] * v[541] + 2e0*v[2248] * v[545] + v[2250] * v[550]) / 2e0;
		v[2330] = (-(v[1384] * v[1579]) + v[1391] * v[1582] - v[1380] * v[1584] + v[1355] * v[1585] + v[2211] * v[258]
			- v[2231] * v[510] + v[2242] * v[511] - v[2235] * v[512]) / 2e0;
		v[2331] = (-(v[1387] * v[1536]) - v[1373] * v[1539] - 2e0*v[1383] * v[1572] - 2e0*v[1375] * v[1573]
			- 2e0*v[1385] * v[1574] - 2e0*v[1382] * v[1575] - 2e0*v[1386] * v[1576] - 2e0*v[1374] * v[1577] - v[1384] * v[1580]
			- 2e0*v[2147] + 2e0*v[2159] - v[2224] * v[513] - 2e0*v[2226] * v[518] - 2e0*v[2225] * v[524] - 2e0*v[2234] * v[528]
			- v[2235] * v[532] - 2e0*v[2233] * v[537] - 2e0*v[2237] * v[541] - 2e0*v[2236] * v[545] - v[2238] * v[550]) / 2e0;
		v[2402] = v[1581] * v[2329] - v[2330] + v[1578] * v[2331] + 24e0*v[1538] * v[3344] * v[3345] - 2e0*v[1502] * (
			-4e0*v[1413] * v[1538] + 4e0*v[2326] * v[405] + v[5339 + i1147]) - 2e0*(v[1346] * v[1536] + v[1369] * v[1539]
				+ 2e0*v[1357] * v[1572] + 2e0*v[1366] * v[1573] + 2e0*v[1349] * v[1574] + 2e0*v[1352] * v[1575]
				+ 2e0*v[1351] * v[1576] + 2e0*v[1364] * v[1577] + v[1355] * v[1580] + 2e0*v[2223] - 2e0*v[2226] - 2e0*v[2232]
				+ 2e0*v[2234] + alphaB[1] * v[2239] - alphaB[0] * v[2243] + 2e0*v[2246] - 2e0*v[2249] - alphaB[2] * v[2251]
				+ 4e0*v[1585] * v[2333] + 4e0*v[258] * (v[2138] + v[1731] * v[2141] + v[1728] * v[2142] + v[1722] * v[2144]
					+ v[1737] * v[2146] + v[1741] * v[2148] + v[1739] * v[2149] + v[2150] + v[1716] * v[2153] + v[1724] * v[2154]
					+ v[1735] * v[2155] + v[2156] + v[1720] * v[2157] + v[1727] * v[2158] + v[1733] * v[2161] + v[1677] * v[2201]
					+ v[1682] * v[2204] + v[1671] * v[2208] + v[1673] * v[2209] + v[1669] * v[2212] + v[1665] * v[2216] + v[1663] * v[2218]
					+ v[1661] * v[2219] + v[1645] * v[2334] + v[1647] * v[2335] + v[1649] * v[2336] + v[1714] * v[2337] + v[1718] * v[2338]
					+ v[1719] * v[2339] + v[2134] * v[2343] + v[2135] * v[2344] + v[2139] * v[2345] + v[2140] * v[2346] + v[2151] * v[2347]
					+ v[2152] * v[2348] + v[2202] * v[2972] + v[1978] * v[3084] + v[1979] * v[3085] + v[1980] * v[3086]
					- 2e0*v[1653] * v[3348] * v[3349]) - v[2258] * v[405] - v[2259] * v[408] - v[2254] * v[410] + v[2220] * v[513]
				+ 2e0*v[2217] * v[518] + 2e0*v[2215] * v[524] + 2e0*v[2214] * v[528] + 2e0*v[5315 + i1147] + v[2211] * v[532]
				+ 2e0*v[2207] * v[537] + 2e0*v[2205] * v[541] + 2e0*v[2203] * v[545] + v[2200] * v[550])*v[981];
		v[3135] = v[2402] + (v[1387] * v[1579] - v[1399] * v[1582] + v[1396] * v[1584] - v[1346] * v[1585] - v[2200] * v[258]
			+ v[2247] * v[510] - v[2250] * v[511] + v[2238] * v[512]) / 2e0;
		v[3134] = (v[2252] + v[2256]) / 2e0;
		v[2351] = v[2255] + v[2257];
		v[2352] = v[2244] + v[2253];
		v[2353] = -(QBi[2][2] * v[1658]) - QBi[1][2] * v[1659] - QBi[0][2] * v[1660] - v[1297] * v[1668] - v[1296] * v[1676]
			- v[1294] * v[1685] - v[2133] * v[279] - v[2131] * v[282] - v[2129] * v[285] + v[2055] * v[561] + v[2053] * v[562]
			+ v[2054] * v[563] + v[2056] * v[576] + v[2059] * v[577] + v[2057] * v[578] + v[2060] * v[591] + v[2061] * v[592]
			+ v[2058] * v[593];
		v[2354] = -(QBi[2][1] * v[1658]) - QBi[1][1] * v[1659] - QBi[0][1] * v[1660] - v[1297] * v[1667] - v[1296] * v[1675]
			- v[1294] * v[1684] - v[2133] * v[278] - v[2131] * v[281] - v[2129] * v[284] + v[2055] * v[558] + v[2053] * v[559]
			+ v[2054] * v[560] + v[2056] * v[573] + v[2059] * v[574] + v[2057] * v[575] + v[2060] * v[588] + v[2061] * v[589]
			+ v[2058] * v[590];
		v[2355] = -(QBi[2][0] * v[1658]) - QBi[1][0] * v[1659] - QBi[0][0] * v[1660] - v[1297] * v[1666] - v[1296] * v[1674]
			- v[1294] * v[1683] - v[2133] * v[277] - v[2131] * v[280] - v[2129] * v[283] + v[2055] * v[555] + v[2053] * v[556]
			+ v[2054] * v[557] + v[2056] * v[570] + v[2059] * v[571] + v[2057] * v[572] + v[2060] * v[585] + v[2061] * v[586]
			+ v[2058] * v[587];
		v[2356] = ddGBp[2][0][1] * v[2194] + ddGBp[1][0][1] * v[2195] + ddGBp[0][0][1] * v[2196]
			+ ddGBp[2][1][1] * v[2197] + ddGBp[1][1][1] * v[2198] + ddGBp[0][1][1] * v[2199] + dGBp[2][1] * v[2353]
			+ dGBp[1][1] * v[2354] + dGBp[0][1] * v[2355];
		v[2357] = ddGBp[2][0][0] * v[2194] + ddGBp[1][0][0] * v[2195] + ddGBp[0][0][0] * v[2196]
			+ ddGBp[2][1][0] * v[2197] + ddGBp[1][1][0] * v[2198] + ddGBp[0][1][0] * v[2199] + dGBp[2][0] * v[2353]
			+ dGBp[1][0] * v[2354] + dGBp[0][0] * v[2355];
		v[2358] = (-(v[1464] * v[1526]) - v[1446] * v[1529] - 2e0*v[1447] * v[1558] - 2e0*v[1444] * v[1559]
			- 2e0*v[1463] * v[1560] - 2e0*v[1449] * v[1561] - 2e0*v[1462] * v[1562] - 2e0*v[1445] * v[1563] - v[1448] * v[1566]
			- 2e0*v[2166] + 2e0*v[2173] - v[2295] * v[414] - 2e0*v[2293] * v[419] - 2e0*v[2294] * v[425] - 2e0*v[2296] * v[429]
			- v[2297] * v[433] - 2e0*v[2298] * v[438] - 2e0*v[2311] * v[442] - 2e0*v[2312] * v[446] - v[2313] * v[451]) / 2e0;
		v[2359] = (-(v[1441] * v[1565]) + v[1438] * v[1568] - v[1446] * v[1570] + v[1437] * v[1571] + v[218] * v[2286]
			- v[2295] * v[411] + v[2287] * v[412] - v[2290] * v[413]) / 2e0;
		v[2361] = (v[1467] * v[1526] + v[1438] * v[1529] + 2e0*v[1457] * v[1558] + 2e0*v[1439] * v[1559]
			+ 2e0*v[1465] * v[1560] + 2e0*v[1458] * v[1561] + 2e0*v[1466] * v[1562] + 2e0*v[1440] * v[1563] + v[1459] * v[1566]
			- 2e0*v[2167] + 2e0*v[2192] + v[2287] * v[414] + 2e0*v[2288] * v[419] + 2e0*v[2289] * v[425] + 2e0*v[2306] * v[429]
			+ v[2308] * v[433] + 2e0*v[2307] * v[438] + 2e0*v[2315] * v[442] + 2e0*v[2314] * v[446] + v[2316] * v[451]) / 2e0;
		v[2362] = (-(v[1452] * v[1565]) + v[1459] * v[1568] - v[1448] * v[1570] + v[1423] * v[1571] + v[218] * v[2277]
			- v[2297] * v[411] + v[2308] * v[412] - v[2301] * v[413]) / 2e0;
		v[2363] = (-(v[1455] * v[1526]) - v[1441] * v[1529] - 2e0*v[1451] * v[1558] - 2e0*v[1443] * v[1559]
			- 2e0*v[1453] * v[1560] - 2e0*v[1450] * v[1561] - 2e0*v[1454] * v[1562] - 2e0*v[1442] * v[1563] - v[1452] * v[1566]
			- 2e0*v[2177] + 2e0*v[2189] - v[2290] * v[414] - 2e0*v[2292] * v[419] - 2e0*v[2291] * v[425] - 2e0*v[2300] * v[429]
			- v[2301] * v[433] - 2e0*v[2299] * v[438] - 2e0*v[2303] * v[442] - 2e0*v[2302] * v[446] - v[2304] * v[451]) / 2e0;
		v[2394] = v[1567] * v[2361] - v[2362] + v[1564] * v[2363] + 24e0*v[1528] * v[3350] * v[3351] - 2e0*v[1500] * (
			-4e0*v[1481] * v[1528] + 4e0*v[2358] * v[399] + v[5351 + i1147]) - 2e0*(v[1414] * v[1526] + v[1437] * v[1529]
				+ 2e0*v[1425] * v[1558] + 2e0*v[1434] * v[1559] + 2e0*v[1417] * v[1560] + 2e0*v[1420] * v[1561]
				+ 2e0*v[1419] * v[1562] + 2e0*v[1432] * v[1563] + v[1423] * v[1566] + 2e0*v[2289] - 2e0*v[2292] - 2e0*v[2298]
				+ 2e0*v[2300] + alphaA[1] * v[2305] - alphaA[0] * v[2309] + 2e0*v[2312] - 2e0*v[2315] - alphaA[2] * v[2317]
				+ 4e0*v[1571] * v[2365] + 4e0*v[218] * (v[2168] + v[1703] * v[2171] + v[1700] * v[2172] + v[1694] * v[2174]
					+ v[1709] * v[2176] + v[1713] * v[2178] + v[1711] * v[2179] + v[2180] + v[1688] * v[2183] + v[1696] * v[2184]
					+ v[1707] * v[2185] + v[2186] + v[1692] * v[2187] + v[1699] * v[2188] + v[1705] * v[2191] + v[1627] * v[2267]
					+ v[1632] * v[2270] + v[1621] * v[2274] + v[1623] * v[2275] + v[1619] * v[2278] + v[1615] * v[2282] + v[1613] * v[2284]
					+ v[1611] * v[2285] + v[1595] * v[2366] + v[1597] * v[2367] + v[1599] * v[2368] + v[1686] * v[2369] + v[1690] * v[2370]
					+ v[1691] * v[2371] + v[2164] * v[2375] + v[2165] * v[2376] + v[2169] * v[2377] + v[2170] * v[2378] + v[2181] * v[2379]
					+ v[2182] * v[2380] + v[2268] * v[2966] + v[1981] * v[3097] + v[1982] * v[3098] + v[1983] * v[3099]
					- 2e0*v[1603] * v[3354] * v[3355]) - v[2324] * v[399] - v[2325] * v[402] - v[2320] * v[404] + v[2286] * v[414]
				+ 2e0*v[2283] * v[419] + 2e0*v[2281] * v[425] + 2e0*v[2280] * v[429] + v[2277] * v[433] + 2e0*v[2273] * v[438]
				+ 2e0*v[2271] * v[442] + 2e0*v[2269] * v[446] + v[2266] * v[451] + 2e0*v[5327 + i1147])*v[966];
		v[3132] = v[2394] + (v[1455] * v[1565] - v[1467] * v[1568] + v[1464] * v[1570] - v[1414] * v[1571] - v[218] * v[2266]
			+ v[2313] * v[411] - v[2316] * v[412] + v[2304] * v[413]) / 2e0;
		v[3131] = (v[2318] + v[2322]) / 2e0;
		v[2383] = v[2321] + v[2323];
		v[2384] = v[2310] + v[2319];
		v[5364] = 0e0;
		v[5365] = 0e0;
		v[5366] = 0e0;
		v[5367] = 2e0*v[2390];
		v[5368] = v[2391];
		v[5369] = v[2392];
		v[5370] = 0e0;
		v[5371] = 0e0;
		v[5372] = 0e0;
		v[5373] = 0e0;
		v[5374] = 0e0;
		v[5375] = 0e0;
		v[5376] = 0e0;
		v[5377] = 0e0;
		v[5378] = 0e0;
		v[5379] = v[2391];
		v[5380] = 2e0*v[2395];
		v[5381] = v[2396];
		v[5382] = 0e0;
		v[5383] = 0e0;
		v[5384] = 0e0;
		v[5385] = 0e0;
		v[5386] = 0e0;
		v[5387] = 0e0;
		v[5388] = 0e0;
		v[5389] = 0e0;
		v[5390] = 0e0;
		v[5391] = v[2392];
		v[5392] = v[2396];
		v[5393] = 2e0*v[2397];
		v[5394] = 0e0;
		v[5395] = 0e0;
		v[5396] = 0e0;
		v[5397] = 0e0;
		v[5398] = 0e0;
		v[5399] = 0e0;
		v[5400] = 0e0;
		v[5401] = 0e0;
		v[5402] = 0e0;
		v[5403] = 0e0;
		v[5404] = 0e0;
		v[5405] = 0e0;
		v[5406] = 0e0;
		v[5407] = 0e0;
		v[5408] = 0e0;
		v[5409] = 2e0*v[2398];
		v[5410] = v[2399];
		v[5411] = v[2400];
		v[5412] = 0e0;
		v[5413] = 0e0;
		v[5414] = 0e0;
		v[5415] = 0e0;
		v[5416] = 0e0;
		v[5417] = 0e0;
		v[5418] = 0e0;
		v[5419] = 0e0;
		v[5420] = 0e0;
		v[5421] = v[2399];
		v[5422] = 2e0*v[2403];
		v[5423] = v[2404];
		v[5424] = 0e0;
		v[5425] = 0e0;
		v[5426] = 0e0;
		v[5427] = 0e0;
		v[5428] = 0e0;
		v[5429] = 0e0;
		v[5430] = 0e0;
		v[5431] = 0e0;
		v[5432] = 0e0;
		v[5433] = v[2400];
		v[5434] = v[2404];
		v[5435] = 2e0*v[2405];
		v[5436] = v[2085];
		v[5437] = v[2093];
		v[5438] = v[2101];
		v[5439] = -v[2321] + v[2323] + v[2309] * v[3100] + v[1460] * v[3130] + 2e0*(v[1491] * v[2393] + v[2324] * v[3100]
			+ v[2358] * v[3102] + v[1478] * v[3130]) + alphaA[2] * v[3131] + 2e0*alphaA[0] * v[3132] + v[2384] * v[400] + v[5363
			+ i1147];
		v[5440] = v[2318] - v[2322] + (alphaA[2] * v[2383]) / 2e0 + (alphaA[0] * v[2384]) / 2e0 - v[2305] * v[3100]
			- v[1456] * v[3130] + 2e0*alphaA[1] * (-v[2359] + v[2362] + v[3132]) + v[5375 + i1147] + 2e0*(-(v[1493] * v[2393])
				+ v[2325] * v[3100] + v[1479] * v[3130] - 4e0*v[2361] * v[966]);
		v[5441] = -v[2310] + v[2319] + 2e0*alphaA[2] * (-v[2359] + v[2394]) + v[2317] * v[3100] + v[1471] * v[3130] + 2e0*
			(v[1495] * v[2393] + v[2320] * v[3100] + v[2363] * v[3102] + v[1474] * v[3130]) + alphaA[0] * v[3131] + v[2383] * v[400]
			+ v[5387 + i1147];
		v[5442] = v[2081];
		v[5443] = v[2089];
		v[5444] = v[2097];
		v[5445] = -v[2255] + v[2257] + v[2243] * v[3103] + v[1392] * v[3133] + 2e0*(v[1482] * v[2401] + v[2258] * v[3103]
			+ v[2326] * v[3105] + v[1410] * v[3133]) + alphaB[2] * v[3134] + 2e0*alphaB[0] * v[3135] + v[2352] * v[406] + v[5399
			+ i1147];
		v[5446] = v[2252] - v[2256] + (alphaB[2] * v[2351]) / 2e0 + (alphaB[0] * v[2352]) / 2e0 - v[2239] * v[3103]
			- v[1388] * v[3133] + 2e0*alphaB[1] * (-v[2327] + v[2330] + v[3135]) + v[5411 + i1147] + 2e0*(-(v[1484] * v[2401])
				+ v[2259] * v[3103] + v[1411] * v[3133] - 4e0*v[2329] * v[981]);
		v[5447] = -v[2244] + v[2253] + 2e0*alphaB[2] * (-v[2327] + v[2402]) + v[2251] * v[3103] + v[1403] * v[3133] + 2e0*
			(v[1486] * v[2401] + v[2254] * v[3103] + v[2331] * v[3105] + v[1406] * v[3133]) + alphaB[0] * v[3134] + v[2351] * v[406]
			+ v[5423 + i1147];
		v[2385] = QAi[2][0] * v[1608] + QAi[1][0] * v[1609] + QAi[0][0] * v[1610] + v[1297] * v[1616] + v[1296] * v[1624]
			+ v[1294] * v[1633] + v[2133] * v[237] + v[2131] * v[240] + v[2129] * v[243] + v[2064] * v[456] + v[2062] * v[457]
			+ v[2063] * v[458] + v[2065] * v[471] + v[2068] * v[472] + v[2066] * v[473] + v[2069] * v[486] + v[2070] * v[487]
			+ v[2067] * v[488];
		v[2386] = QAi[2][1] * v[1608] + QAi[1][1] * v[1609] + QAi[0][1] * v[1610] + v[1297] * v[1617] + v[1296] * v[1625]
			+ v[1294] * v[1634] + v[2133] * v[238] + v[2131] * v[241] + v[2129] * v[244] + v[2064] * v[459] + v[2062] * v[460]
			+ v[2063] * v[461] + v[2065] * v[474] + v[2068] * v[475] + v[2066] * v[476] + v[2069] * v[489] + v[2070] * v[490]
			+ v[2067] * v[491];
		v[2387] = QAi[2][2] * v[1608] + QAi[1][2] * v[1609] + QAi[0][2] * v[1610] + v[1297] * v[1618] + v[1296] * v[1626]
			+ v[1294] * v[1635] + v[2133] * v[239] + v[2131] * v[242] + v[2129] * v[245] + v[2064] * v[462] + v[2062] * v[463]
			+ v[2063] * v[464] + v[2065] * v[477] + v[2068] * v[478] + v[2066] * v[479] + v[2069] * v[492] + v[2070] * v[493]
			+ v[2067] * v[494];
		v[2388] = ddGAp[0][0][1] * v[2260] + ddGAp[1][0][1] * v[2261] + ddGAp[2][0][1] * v[2262]
			+ ddGAp[0][1][1] * v[2263] + ddGAp[1][1][1] * v[2264] + ddGAp[2][1][1] * v[2265] + dGAp[0][1] * v[2385]
			+ dGAp[1][1] * v[2386] + dGAp[2][1] * v[2387];
		v[2389] = ddGAp[0][0][0] * v[2260] + ddGAp[1][0][0] * v[2261] + ddGAp[2][0][0] * v[2262]
			+ ddGAp[0][1][0] * v[2263] + ddGAp[1][1][0] * v[2264] + ddGAp[2][1][0] * v[2265] + dGAp[0][0] * v[2385]
			+ dGAp[1][0] * v[2386] + dGAp[2][0] * v[2387];
		Rc[i1147 - 1] += v[4711 + i1147] + (*a4)*v[4723 + i1147];
		for (i1518 = 1; i1518 <= 12; i1518++) {
			Kc[i1147 - 1][i1518 - 1] += v[2356] * v[4211 + i1518] + v[2357] * v[4223 + i1518] + v[2389] * v[4235 + i1518]
				+ v[2388] * v[4247 + i1518] + v[5435 + i1518] + (*a4)*v[5447 + i1518];
		};/* end for */
	};/* end for */
	b2420 = b764;
	v[2421] = v[768] * v[856];
	v[2422] = v[768] * v[858];
	v[2423] = v[768] * v[860];
	v[2424] = v[768] * v[868];
	v[2425] = v[768] * v[870];
	v[2426] = v[768] * v[872];
	v[2427] = v[767] * v[856];
	v[2428] = v[767] * v[858];
	v[2429] = v[767] * v[860];
	v[2430] = v[767] * v[868];
	v[2431] = v[767] * v[870];
	v[2432] = v[767] * v[872];
	v[2433] = v[766] * v[856];
	v[2434] = v[766] * v[858];
	v[2435] = v[766] * v[860];
	v[2436] = v[766] * v[868];
	v[2437] = v[766] * v[870];
	v[2438] = v[766] * v[872];
	v[2439] = v[237] * v[766] + v[240] * v[767] + v[243] * v[768];
	v[2440] = v[238] * v[766] + v[241] * v[767] + v[244] * v[768];
	v[2441] = v[239] * v[766] + v[242] * v[767] + v[245] * v[768];
	v[3408] = ddGAp[0][0][0] * v[2439] + ddGAp[1][0][0] * v[2440] + ddGAp[2][0][0] * v[2441];
	v[3407] = ddGAp[0][1][0] * v[2439] + ddGAp[1][1][0] * v[2440] + ddGAp[2][1][0] * v[2441];
	v[3406] = ddGAp[0][0][1] * v[2439] + ddGAp[1][0][1] * v[2440] + ddGAp[2][0][1] * v[2441];
	v[3405] = ddGAp[0][1][1] * v[2439] + ddGAp[1][1][1] * v[2440] + ddGAp[2][1][1] * v[2441];
	v[2442] = -(v[277] * v[766]) - v[280] * v[767] - v[283] * v[768];
	v[2443] = -(v[279] * v[766]) - v[282] * v[767] - v[285] * v[768];
	v[2444] = -(v[278] * v[766]) - v[281] * v[767] - v[284] * v[768];
	v[3404] = ddGBp[0][0][0] * v[2442] + ddGBp[2][0][0] * v[2443] + ddGBp[1][0][0] * v[2444];
	v[3403] = ddGBp[0][1][0] * v[2442] + ddGBp[2][1][0] * v[2443] + ddGBp[1][1][0] * v[2444];
	v[3402] = ddGBp[0][0][1] * v[2442] + ddGBp[2][0][1] * v[2443] + ddGBp[1][0][1] * v[2444];
	v[3401] = ddGBp[0][1][1] * v[2442] + ddGBp[2][1][1] * v[2443] + ddGBp[1][1][1] * v[2444];
	v[2445] = (v[2421] * v[258]) / 2e0;
	v[2446] = v[2422] * v[258];
	v[2447] = v[2423] * v[258];
	v[2448] = v[2427] * v[258];
	v[2449] = (v[2428] * v[258]) / 2e0;
	v[2450] = v[2429] * v[258];
	v[2451] = v[2433] * v[258];
	v[2452] = v[2434] * v[258];
	v[2453] = (v[2435] * v[513]) / 2e0 + v[2434] * v[518] + v[2433] * v[524] + v[2429] * v[528] + (v[2428] * v[532]) / 2e0
		+ v[2427] * v[537] + v[2423] * v[541] + v[2422] * v[545] + (v[2421] * v[550]) / 2e0;
	v[2820] = -v[2445] - v[2449] - 4e0*v[2453] * v[981];
	v[2826] = v[2445] - (v[2435] * v[258]) / 2e0 + v[2820];
	v[2824] = -v[2445] + v[2449] + v[2826];
	v[2455] = (v[218] * v[2424]) / 2e0;
	v[2456] = v[218] * v[2425];
	v[2457] = v[218] * v[2426];
	v[2458] = v[218] * v[2430];
	v[2459] = (v[218] * v[2431]) / 2e0;
	v[2460] = v[218] * v[2432];
	v[2461] = v[218] * v[2436];
	v[2462] = v[218] * v[2437];
	v[2463] = (v[2438] * v[414]) / 2e0 + v[2437] * v[419] + v[2436] * v[425] + v[2432] * v[429] + (v[2431] * v[433]) / 2e0
		+ v[2430] * v[438] + v[2426] * v[442] + v[2425] * v[446] + (v[2424] * v[451]) / 2e0;
	v[2813] = -v[2455] - v[2459] - 4e0*v[2463] * v[966];
	v[2819] = -(v[218] * v[2438]) / 2e0 + v[2455] + v[2813];
	v[2817] = -v[2455] + v[2459] + v[2819];
	v[2822] = (v[2447] + v[2451]) / 2e0;
	v[2466] = v[2446] + v[2448];
	v[2825] = v[2466] / 2e0;
	v[2467] = v[2450] + v[2452];
	v[2821] = v[2467] / 2e0;
	v[2468] = dGAp[0][1] * v[2439] + dGAp[1][1] * v[2440] + dGAp[2][1] * v[2441];
	v[2469] = dGAp[0][0] * v[2439] + dGAp[1][0] * v[2440] + dGAp[2][0] * v[2441];
	v[2470] = dGBp[0][0] * v[2442] + dGBp[2][0] * v[2443] + dGBp[1][0] * v[2444];
	v[2471] = dGBp[0][1] * v[2442] + dGBp[2][1] * v[2443] + dGBp[1][1] * v[2444];
	v[2815] = (v[2457] + v[2461]) / 2e0;
	v[2473] = v[2456] + v[2458];
	v[2818] = v[2473] / 2e0;
	v[2474] = v[2460] + v[2462];
	v[5464] = v[766];
	v[5465] = v[767];
	v[5466] = v[768];
	v[5467] = v[2456] - v[2458] + 2e0*alphaA[0] * v[2813] + alphaA[2] * v[2815] + v[2474] * v[400];
	v[5468] = -v[2457] + v[2461] + (alphaA[2] * v[2473]) / 2e0 + (alphaA[0] * v[2474]) / 2e0 + 2e0*alphaA[1] * v[2817];
	v[5469] = v[2460] - v[2462] + alphaA[0] * v[2815] + 2e0*alphaA[2] * v[2819] + v[2473] * v[400];
	v[5470] = -v[766];
	v[5471] = -v[767];
	v[5472] = -v[768];
	v[5473] = v[2446] - v[2448] + 2e0*alphaB[0] * v[2820] + alphaB[2] * v[2822] + v[2467] * v[406];
	v[5474] = -v[2447] + v[2451] + (alphaB[2] * v[2466]) / 2e0 + (alphaB[0] * v[2467]) / 2e0 + 2e0*alphaB[1] * v[2824];
	v[5475] = v[2450] - v[2452] + alphaB[0] * v[2822] + 2e0*alphaB[2] * v[2826] + v[2466] * v[406];
	v[2814] = v[2474] / 2e0;
	for (i2415 = 1; i2415 <= 12; i2415++) {
		i3141 = (i2415 == 11 ? 1 : 0);
		i3140 = (i2415 == 10 ? 1 : 0);
		i3139 = (i2415 == 12 ? 1 : 0);
		i3138 = (i2415 == 5 ? 1 : 0);
		i3137 = (i2415 == 4 ? 1 : 0);
		i3136 = (i2415 == 6 ? 1 : 0);
		v[2505] = v[4235 + i2415];
		v[2504] = v[4247 + i2415];
		v[2500] = v[4223 + i2415];
		v[2499] = v[4211 + i2415];
		v[2481] = v[4287 + i2415];
		v[2482] = v[4311 + i2415];
		v[2483] = v[4299 + i2415];
		v[2484] = v[4335 + i2415];
		v[2485] = v[4359 + i2415];
		v[2486] = v[4347 + i2415];
		v[2488] = v[4787 + i2415];
		v[2489] = v[4275 + i2415];
		v[2530] = -4e0*v[2489] * v[966];
		v[2490] = v[5479 + i2415];
		v[2492] = v[4739 + i2415];
		v[2494] = v[4859 + i2415];
		v[2495] = v[4323 + i2415];
		v[2541] = -4e0*v[2495] * v[981];
		v[2496] = v[5491 + i2415];
		v[2498] = v[4811 + i2415];
		v[2501] = dGBp[1][1] * v[2499] + dGBp[1][0] * v[2500];
		v[2502] = dGBp[2][1] * v[2499] + dGBp[2][0] * v[2500];
		v[2503] = dGBp[0][1] * v[2499] + dGBp[0][0] * v[2500];
		v[2506] = dGAp[2][1] * v[2504] + dGAp[2][0] * v[2505];
		v[2507] = dGAp[1][1] * v[2504] + dGAp[1][0] * v[2505];
		v[2508] = dGAp[0][1] * v[2504] + dGAp[0][0] * v[2505];
		v[2509] = -i3136 + v[2481];
		v[2511] = i3136 + v[2481];
		v[2512] = -i3137 + v[2482];
		v[2514] = i3137 + v[2482];
		v[2515] = i3138 + v[2483];
		v[2517] = -i3138 + v[2483];
		v[2518] = -i3139 + v[2484];
		v[2520] = i3139 + v[2484];
		v[2521] = -i3140 + v[2485];
		v[2523] = i3140 + v[2485];
		v[2524] = i3141 + v[2486];
		v[2526] = -i3141 + v[2486];
		v[2528] = (v[218] * v[2488]) / 2e0 + v[2489] * v[2527];
		v[2529] = v[218] * v[2509] + v[2530] * v[419];
		v[2531] = v[218] * v[2515] + v[2530] * v[425];
		v[2532] = v[218] * v[2511] + v[2530] * v[429];
		v[2533] = (v[218] * v[2490] + v[2530] * v[433]) / 2e0;
		v[2534] = v[218] * v[2512] + v[2530] * v[438];
		v[2535] = v[218] * v[2517] + v[2530] * v[442];
		v[2536] = v[218] * v[2514] + v[2530] * v[446];
		v[2537] = (v[218] * v[2492] + v[2530] * v[451]) / 2e0;
		v[2539] = v[2495] * v[2538] + (v[2494] * v[258]) / 2e0;
		v[2540] = v[2518] * v[258] + v[2541] * v[518];
		v[2542] = v[2524] * v[258] + v[2541] * v[524];
		v[2543] = v[2520] * v[258] + v[2541] * v[528];
		v[2544] = (v[2496] * v[258] + v[2541] * v[532]) / 2e0;
		v[2545] = v[2521] * v[258] + v[2541] * v[537];
		v[2546] = v[2526] * v[258] + v[2541] * v[541];
		v[2547] = v[2523] * v[258] + v[2541] * v[545];
		v[2548] = (v[2498] * v[258] + v[2541] * v[550]) / 2e0;
		v[2550] = v[239] * v[2506] + v[238] * v[2507] + v[237] * v[2508] - v[2503] * v[277] - v[2501] * v[278] - v[2502] * v[279]
			+ v[4611 + i2415] + v[2542] * v[856] + v[2540] * v[858] + v[2539] * v[860] + v[2531] * v[868] + v[2529] * v[870]
			+ v[2528] * v[872];
		v[2552] = v[242] * v[2506] + v[241] * v[2507] + v[240] * v[2508] - v[2503] * v[280] - v[2501] * v[281] - v[2502] * v[282]
			+ v[4599 + i2415] + v[2545] * v[856] + v[2544] * v[858] + v[2543] * v[860] + v[2534] * v[868] + v[2533] * v[870]
			+ v[2532] * v[872];
		v[2553] = v[2528] * v[766] + v[2532] * v[767] + v[2535] * v[768];
		v[2554] = v[2529] * v[766] + v[2533] * v[767] + v[2536] * v[768];
		v[2555] = v[2531] * v[766] + v[2534] * v[767] + v[2537] * v[768];
		v[2556] = v[2539] * v[766] + v[2543] * v[767] + v[2546] * v[768];
		v[2557] = v[2540] * v[766] + v[2544] * v[767] + v[2547] * v[768];
		v[2559] = v[245] * v[2506] + v[244] * v[2507] + v[243] * v[2508] - v[2503] * v[283] - v[2501] * v[284] - v[2502] * v[285]
			+ v[4587 + i2415] + v[2548] * v[856] + v[2547] * v[858] + v[2546] * v[860] + v[2537] * v[868] + v[2536] * v[870]
			+ v[2535] * v[872];
		v[2560] = v[2542] * v[766] + v[2545] * v[767] + v[2548] * v[768];
		b2561 = b764;
		if (b2561) {
			v[3144] = (*cn)*v[2550];
			v[3143] = (*cn)*v[2552];
			v[3142] = (*cn)*v[2559];
			v[3147] = v[2043] * v[2552] + v[2550] * v[2589] - v[3142] * v[753];
			v[3146] = v[2043] * v[2559] + v[2550] * v[2591] - v[3143] * v[751];
			v[3145] = v[2559] * v[2589] + v[2552] * v[2591] - v[3144] * v[749];
			v[2562] = 0e0;
			v[2563] = 0e0;
			v[2564] = 0e0;
			v[2566] = v[2565] * v[3142];
			v[2568] = v[2567] * v[3143];
			v[2572] = (*cn)*(v[2550] * v[2569] + v[2552] * v[2570] + v[2559] * v[2571]);
			v[2576] = (*cn)*(v[2550] * v[2573] + v[2552] * v[2574] + v[2559] * v[2575]);
			v[2578] = v[2577] * v[3144];
			v[2582] = (*cn)*(v[2550] * v[2579] + v[2552] * v[2580] + v[2559] * v[2581]);
			v[2583] = (*cn)*(v[2024] * v[2550] + v[2025] * v[2552] + v[2026] * v[2559]);
			v[2584] = (*cn)*(v[2027] * v[2550] + v[2028] * v[2552] + v[2029] * v[2559]);
			v[2585] = (*cn)*(v[2030] * v[2550] + v[2031] * v[2552] + v[2032] * v[2559]);
			v[2586] = (*cn)*(v[2033] * v[2550] + v[2034] * v[2552] + v[2035] * v[2559]);
			v[2587] = (*cn)*(v[2036] * v[2550] + v[2037] * v[2552] + v[2038] * v[2559]);
			v[2588] = (*cn)*(v[2039] * v[2550] + v[2040] * v[2552] + v[2041] * v[2559]);
			v[2590] = v[3147];
			v[2592] = v[3146];
			v[2593] = v[3145];
			v[2594] = -v[2590];
			v[2595] = -v[2592];
			v[2596] = -v[2593];
			v[2598] = v[3145] * v[345];
			v[2599] = v[3145] * v[355];
			v[2600] = v[3145] * v[335];
			v[2602] = v[3146] * v[335];
			v[2603] = v[3146] * v[355];
			v[2605] = v[3147] * v[355];
			v[2606] = v[3146] * v[345];
			v[2607] = v[3147] * v[335];
			v[2608] = v[3147] * v[345];
			v[2609] = -(v[3145] * v[319]);
			v[2610] = -(v[3145] * v[329]);
			v[2611] = -(v[309] * v[3145]);
			v[2612] = -(v[309] * v[3146]);
			v[2613] = -(v[3146] * v[329]);
			v[2614] = -(v[3147] * v[329]);
			v[2615] = -(v[3146] * v[319]);
			v[2616] = -(v[309] * v[3147]);
			v[2617] = -(v[3147] * v[319]);
		}
		else {
			v[2596] = 0e0;
			v[2595] = 0e0;
			v[2594] = 0e0;
			v[2593] = 0e0;
			v[2592] = 0e0;
			v[2590] = 0e0;
			v[2588] = 0e0;
			v[2587] = 0e0;
			v[2586] = 0e0;
			v[2585] = 0e0;
			v[2584] = 0e0;
			v[2583] = 0e0;
			v[2582] = 0e0;
			v[2576] = 0e0;
			v[2572] = 0e0;
			v[2611] = 0e0;
			v[2609] = 0e0;
			v[2610] = 0e0;
			v[2612] = 0e0;
			v[2615] = 0e0;
			v[2613] = 0e0;
			v[2616] = 0e0;
			v[2617] = 0e0;
			v[2614] = 0e0;
			v[2600] = 0e0;
			v[2598] = 0e0;
			v[2599] = 0e0;
			v[2602] = 0e0;
			v[2606] = 0e0;
			v[2603] = 0e0;
			v[2607] = 0e0;
			v[2608] = 0e0;
			v[2605] = 0e0;
			v[2578] = 0e0;
			v[2568] = 0e0;
			v[2566] = 0e0;
			v[2564] = -((*epsn)*v[2559]);
			v[2563] = -((*epsn)*v[2552]);
			v[2562] = -((*epsn)*v[2550]);
		};
		v[2738] = v[2406] * v[2588];
		v[2735] = v[2588] * v[2836];
		v[2729] = v[2588] * v[2838];
		v[3160] = v[1507] * v[2587] + v[2738];
		v[2733] = v[2407] * v[2587];
		v[2740] = v[1509] * v[2586];
		v[3159] = v[1508] * v[2586] + v[2733];
		v[2726] = v[2408] * v[2586];
		v[3158] = v[1506] * v[2587] + v[2726];
		v[2680] = v[2409] * v[2585];
		v[2677] = v[2585] * v[2841];
		v[2671] = v[2585] * v[2843];
		v[3157] = v[1513] * v[2584] + v[2680];
		v[2675] = v[2410] * v[2584];
		v[2682] = v[1515] * v[2583];
		v[3156] = v[1514] * v[2583] + v[2675];
		v[2668] = v[2411] * v[2583];
		v[5588] = v[2596];
		v[5589] = v[2595];
		v[5590] = v[2594];
		v[5591] = v[2738] + v[2587] * v[2836] + v[2586] * v[2838];
		v[5592] = v[1506] * v[2586] + v[1507] * v[2588] + v[2733];
		v[5593] = v[1508] * v[2587] + v[1509] * v[2588] + v[2726];
		v[5594] = v[2593];
		v[5595] = v[2592];
		v[5596] = v[2590];
		v[5597] = v[2680] + v[2584] * v[2841] + v[2583] * v[2843];
		v[5598] = v[1512] * v[2583] + v[1513] * v[2585] + v[2675];
		v[5599] = v[1514] * v[2584] + v[1515] * v[2585] + v[2668];
		v[3155] = v[1512] * v[2584] + v[2668];
		v[2572] = v[2572] + 2e0*v[2566] * v[373];
		v[2576] = v[2576] + 2e0*v[2568] * v[372];
		v[2582] = v[2582] + 2e0*v[2578] * v[371];
		v[3148] = ((v[2582] * v[356] + v[2576] * v[357] + v[2572] * v[358])*v[369]) / v[1293];
		v[2564] = v[2564] + v[3148] * v[358] + v[2572] * v[370];
		v[2563] = v[2563] + v[3148] * v[357] + v[2576] * v[370];
		v[2562] = v[2562] + v[3148] * v[356] + v[2582] * v[370];
		v[2619] = -(GBp[2] * v[2564]) - v[2502] * v[768];
		v[2620] = -(GBp[1] * v[2564]) - v[2501] * v[768];
		v[2621] = -(GBp[0] * v[2564]) - v[2503] * v[768];
		v[2622] = GAp[2] * v[2564] + v[2506] * v[768];
		v[2623] = GAp[1] * v[2564] + v[2507] * v[768];
		v[2624] = GAp[0] * v[2564] + v[2508] * v[768];
		v[2625] = -(GBp[2] * v[2563]) - v[2502] * v[767];
		v[2626] = -(GBp[1] * v[2563]) - v[2501] * v[767];
		v[2627] = -(GBp[0] * v[2563]) - v[2503] * v[767];
		v[2628] = GAp[2] * v[2563] + v[2506] * v[767];
		v[2629] = GAp[1] * v[2563] + v[2507] * v[767];
		v[2630] = GAp[0] * v[2563] + v[2508] * v[767];
		v[2631] = -(GBp[2] * v[2562]) - v[2502] * v[766];
		v[2632] = -(GBp[1] * v[2562]) - v[2501] * v[766];
		v[2633] = -(GBp[0] * v[2562]) - v[2503] * v[766];
		v[2634] = GAp[2] * v[2562] + v[2506] * v[766];
		v[2635] = GAp[1] * v[2562] + v[2507] * v[766];
		v[2636] = GAp[0] * v[2562] + v[2508] * v[766];
		v[2637] = v[1872] * v[2583];
		v[2638] = v[1871] * v[2583];
		v[2639] = v[1870] * v[2583];
		v[2640] = v[1877] * v[2584];
		v[2641] = v[2583] * v[342] + v[2584] * v[344];
		v[2642] = v[1875] * v[2584];
		v[2643] = v[2637] + v[2640];
		v[2644] = v[1876] * v[2584] + v[2641] * v[3149];
		v[2645] = v[1880] * v[2585];
		v[2646] = v[2583] * v[336] + v[2585] * v[344];
		v[2647] = v[2584] * v[336] + v[2585] * v[342];
		v[2648] = v[1882] * v[2585] + v[2646] * v[3150];
		v[2649] = v[2644] + v[2648];
		v[2650] = v[1881] * v[2585] + v[2647] * v[3151];
		v[2651] = v[2638] + v[2650];
		v[2652] = v[1887] * v[2586];
		v[2653] = v[1886] * v[2586];
		v[2654] = v[1885] * v[2586];
		v[2655] = v[1892] * v[2587];
		v[2656] = v[2586] * v[316] + v[2587] * v[318];
		v[2657] = v[1890] * v[2587];
		v[2658] = v[2652] + v[2655];
		v[2659] = v[1891] * v[2587] + v[2656] * v[3152];
		v[2660] = v[1895] * v[2588];
		v[2661] = v[2586] * v[310] + v[2588] * v[318];
		v[2662] = v[2587] * v[310] + v[2588] * v[316];
		v[2663] = v[1897] * v[2588] + v[2661] * v[3153];
		v[2664] = v[2659] + v[2663];
		v[2665] = v[1896] * v[2588] + v[2662] * v[3154];
		v[2666] = v[2653] + v[2665];
		v[2667] = QBi[2][2] * v[2619] + QBi[2][1] * v[2620] + QBi[2][0] * v[2621] + (v[2671] + v[3155])*v[344];
		v[2670] = QBi[1][2] * v[2619] + QBi[1][1] * v[2620] + QBi[1][0] * v[2621] + v[2647] * v[2843] + v[3155] * v[342];
		v[2672] = QBi[0][2] * v[2619] + QBi[0][1] * v[2620] + QBi[0][0] * v[2621] + (v[2668] + v[2671])*v[336];
		v[2673] = QBi[2][2] * v[2625] + QBi[2][1] * v[2626] + QBi[2][0] * v[2627] + v[2646] * v[2841] + v[3156] * v[344];
		v[2676] = QBi[1][2] * v[2625] + QBi[1][1] * v[2626] + QBi[1][0] * v[2627] + (v[2677] + v[3156])*v[342];
		v[2678] = QBi[0][2] * v[2625] + QBi[0][1] * v[2626] + QBi[0][0] * v[2627] + (v[2675] + v[2677])*v[336];
		v[2679] = QBi[2][2] * v[2631] + QBi[2][1] * v[2632] + QBi[2][0] * v[2633] + v[1513] * v[2641] + (v[2680] + v[2682]
			)*v[344];
		v[2681] = QBi[1][2] * v[2631] + QBi[1][1] * v[2632] + QBi[1][0] * v[2633] + v[3157] * v[342];
		v[2684] = QBi[0][2] * v[2631] + QBi[0][1] * v[2632] + QBi[0][0] * v[2633] + (v[2682] + v[3157])*v[336];
		v[2685] = -(v[2598] * v[860]);
		v[2686] = -(v[2598] * v[858]);
		v[2687] = -(v[2598] * v[856]);
		v[2688] = -(v[2599] * v[860]);
		v[2689] = -(v[2599] * v[856]);
		v[2690] = -(v[2599] * v[858]);
		v[2691] = -(v[2600] * v[858]);
		v[2692] = -(v[2600] * v[856]);
		v[2693] = -(v[2600] * v[860]);
		v[2694] = -(v[2602] * v[860]);
		v[2695] = -(v[2602] * v[858]);
		v[2696] = -(v[2602] * v[856]);
		v[2697] = -(v[2603] * v[856]);
		v[2698] = -(v[2603] * v[860]);
		v[2699] = -(v[2603] * v[858]);
		v[2700] = -(v[2605] * v[858]);
		v[2701] = -(v[2605] * v[860]);
		v[2702] = -(v[2605] * v[856]);
		v[2703] = v[2691] + v[2694] + v[2697] + v[2700] + 2e0*v[2642] * v[517] - v[2649] * v[520] - v[2643] * v[523];
		v[2704] = -(v[2606] * v[860]);
		v[2705] = -(v[2606] * v[856]);
		v[2706] = -(v[2606] * v[858]);
		v[2707] = -v[2686] - v[2689] - v[2701] - v[2704] - v[2649] * v[517] + 2e0*v[2645] * v[520] + v[2651] * v[523];
		v[2708] = v[2434] * v[2541] + v[258] * v[2681] - v[2691] * v[510] + v[2686] * v[511] - v[2690] * v[512];
		v[2709] = -(v[2607] * v[860]);
		v[2710] = -(v[2607] * v[858]);
		v[2711] = -(v[2607] * v[856]);
		v[2712] = -(v[2608] * v[858]);
		v[2713] = -(v[2608] * v[860]);
		v[2714] = -(v[2608] * v[856]);
		v[2715] = -v[2692] - v[2705] - v[2709] - v[2712] - v[2643] * v[517] + v[2651] * v[520] + 2e0*v[2639] * v[523];
		v[2716] = v[2433] * v[2541] + v[258] * v[2679] - v[2692] * v[510] + v[2687] * v[511] - v[2689] * v[512];
		v[2717] = v[2429] * v[2541] + v[258] * v[2678] - v[2694] * v[510] + v[2704] * v[511] - v[2698] * v[512];
		v[2718] = v[2688] + v[2699];
		v[2719] = v[2427] * v[2541] + v[258] * v[2673] - v[2696] * v[510] + v[2705] * v[511] - v[2697] * v[512];
		v[2720] = v[2423] * v[2541] + v[258] * v[2672] - v[2709] * v[510] + v[2713] * v[511] - v[2701] * v[512];
		v[2721] = v[2422] * v[2541] + v[258] * v[2670] - v[2710] * v[510] + v[2712] * v[511] - v[2700] * v[512];
		v[2722] = v[2695] + v[2711];
		v[2723] = v[2685] + v[2714];
		v[2725] = QAi[2][2] * v[2622] + QAi[2][1] * v[2623] + QAi[2][0] * v[2624] + (v[2729] + v[3158])*v[318];
		v[2728] = QAi[1][2] * v[2622] + QAi[1][1] * v[2623] + QAi[1][0] * v[2624] + v[2662] * v[2838] + v[3158] * v[316];
		v[2730] = QAi[0][2] * v[2622] + QAi[0][1] * v[2623] + QAi[0][0] * v[2624] + (v[2726] + v[2729])*v[310];
		v[2731] = QAi[2][2] * v[2628] + QAi[2][1] * v[2629] + QAi[2][0] * v[2630] + v[2661] * v[2836] + v[3159] * v[318];
		v[2734] = QAi[1][2] * v[2628] + QAi[1][1] * v[2629] + QAi[1][0] * v[2630] + (v[2735] + v[3159])*v[316];
		v[2736] = QAi[0][2] * v[2628] + QAi[0][1] * v[2629] + QAi[0][0] * v[2630] + (v[2733] + v[2735])*v[310];
		v[2737] = QAi[2][2] * v[2634] + QAi[2][1] * v[2635] + QAi[2][0] * v[2636] + v[1507] * v[2656] + (v[2738] + v[2740]
			)*v[318];
		v[2739] = QAi[1][2] * v[2634] + QAi[1][1] * v[2635] + QAi[1][0] * v[2636] + v[316] * v[3160];
		v[2742] = QAi[0][2] * v[2634] + QAi[0][1] * v[2635] + QAi[0][0] * v[2636] + v[310] * (v[2740] + v[3160]);
		v[2743] = v[2609] * v[872];
		v[2744] = v[2609] * v[870];
		v[2745] = v[2609] * v[868];
		v[2746] = v[2610] * v[872];
		v[2747] = v[2610] * v[868];
		v[2748] = v[2610] * v[870];
		v[2749] = v[2611] * v[870];
		v[2750] = v[2611] * v[868];
		v[2751] = v[2611] * v[872];
		v[2752] = v[2612] * v[872];
		v[2753] = v[2612] * v[870];
		v[2754] = v[2612] * v[868];
		v[2755] = v[2613] * v[868];
		v[2756] = v[2613] * v[872];
		v[2757] = v[2613] * v[870];
		v[2758] = v[2614] * v[870];
		v[2759] = v[2614] * v[872];
		v[2760] = v[2614] * v[868];
		v[2761] = v[2749] + v[2752] + v[2755] + v[2758] + 2e0*v[2657] * v[418] - v[2664] * v[421] - v[2658] * v[424];
		v[2762] = v[2615] * v[872];
		v[2763] = v[2615] * v[868];
		v[2764] = v[2615] * v[870];
		v[2765] = -v[2744] - v[2747] - v[2759] - v[2762] - v[2664] * v[418] + 2e0*v[2660] * v[421] + v[2666] * v[424];
		v[2766] = v[2437] * v[2530] + v[218] * v[2739] - v[2749] * v[411] + v[2744] * v[412] - v[2748] * v[413];
		v[2767] = v[2616] * v[872];
		v[2768] = v[2616] * v[870];
		v[2769] = v[2616] * v[868];
		v[2770] = v[2617] * v[870];
		v[2771] = v[2617] * v[872];
		v[2772] = v[2617] * v[868];
		v[2773] = -v[2750] - v[2763] - v[2767] - v[2770] - v[2658] * v[418] + v[2666] * v[421] + 2e0*v[2654] * v[424];
		v[2774] = v[2436] * v[2530] + v[218] * v[2737] - v[2750] * v[411] + v[2745] * v[412] - v[2747] * v[413];
		v[2775] = v[2432] * v[2530] + v[218] * v[2736] - v[2752] * v[411] + v[2762] * v[412] - v[2756] * v[413];
		v[2776] = v[2746] + v[2757];
		v[2777] = v[2430] * v[2530] + v[218] * v[2731] - v[2754] * v[411] + v[2763] * v[412] - v[2755] * v[413];
		v[2778] = v[2426] * v[2530] + v[218] * v[2730] - v[2767] * v[411] + v[2771] * v[412] - v[2759] * v[413];
		v[2779] = v[2425] * v[2530] + v[218] * v[2728] - v[2768] * v[411] + v[2770] * v[412] - v[2758] * v[413];
		v[2780] = v[2753] + v[2769];
		v[2781] = v[2743] + v[2772];
		v[2783] = (-2e0*v[2637] + 2e0*v[2640] - v[2693] * v[513] - 2e0*v[2691] * v[518] - 2e0*v[2692] * v[524]
			- 2e0*v[2694] * v[528] - v[2695] * v[532] - 2e0*v[2696] * v[537] - 2e0*v[2709] * v[541] - 2e0*v[2710] * v[545]
			- v[2711] * v[550]) / 2e0;
		v[2784] = (v[2435] * v[2541] + v[258] * v[2684] - v[2693] * v[510] + v[2685] * v[511] - v[2688] * v[512]) / 2e0;
		v[2786] = -v[2638] + v[2650] + (v[2685] * v[513]) / 2e0 + v[2686] * v[518] + v[2687] * v[524] + v[2704] * v[528] +
			(v[2706] * v[532]) / 2e0 + v[2705] * v[537] + v[2713] * v[541] + v[2712] * v[545] + (v[2714] * v[550]) / 2e0;
		v[2787] = (v[2428] * v[2541] + v[258] * v[2676] - v[2695] * v[510] + v[2706] * v[511] - v[2699] * v[512]) / 2e0;
		v[2788] = (-2e0*v[2644] + 2e0*v[2648] - v[2688] * v[513] - 2e0*v[2690] * v[518] - 2e0*v[2689] * v[524]
			- 2e0*v[2698] * v[528] - v[2699] * v[532] - 2e0*v[2697] * v[537] - 2e0*v[2701] * v[541] - 2e0*v[2700] * v[545]
			- v[2702] * v[550]) / 2e0;
		v[2823] = v[1581] * v[2786] - v[2787] + v[1578] * v[2788] + 8e0*v[1502] * (v[2453] * v[2495] - v[2783] * v[405]) - 2e0*
			(v[2435] * v[2494] + v[2428] * v[2496] + v[2421] * v[2498] + 2e0*v[2434] * v[2518] + 2e0*v[2429] * v[2520]
				+ 2e0*v[2427] * v[2521] + 2e0*v[2422] * v[2523] + 2e0*v[2433] * v[2524] + 2e0*v[2423] * v[2526] + 4e0*v[258] *
				(v[1869] * v[2583] + v[1874] * v[2584] + v[1879] * v[2585] + v[2639] + v[1722] * v[2641] + v[2642] + v[2645]
					+ v[1720] * v[2646] + v[1716] * v[2647]) + 2e0*v[2687] - 2e0*v[2690] - 2e0*v[2696] + 2e0*v[2698]
				+ alphaB[1] * v[2703] - alphaB[0] * v[2707] + 2e0*v[2710] - 2e0*v[2713] - alphaB[2] * v[2715] - v[2722] * v[405]
				- v[2723] * v[408] - v[2718] * v[410] + v[2684] * v[513] + 2e0*v[2681] * v[518] + 2e0*v[2679] * v[524]
				+ 2e0*v[2678] * v[528] + v[2676] * v[532] + 2e0*v[2673] * v[537] + 2e0*v[2672] * v[541] + 2e0*v[2670] * v[545]
				+ v[2667] * v[550])*v[981];
		v[3164] = v[2823] + (-(v[2421] * v[2541]) - v[258] * v[2667] + v[2711] * v[510] - v[2714] * v[511] + v[2702] * v[512])
			/ 2e0;
		v[3163] = (v[2716] + v[2720]) / 2e0;
		v[2791] = v[2719] + v[2721];
		v[2792] = v[2708] + v[2717];
		v[2793] = -(QBi[0][2] * v[2556]) - QBi[1][2] * v[2557] - QBi[2][2] * v[2560] - v[2562] * v[279] - v[2563] * v[282]
			- v[2564] * v[285] + v[2600] * v[561] + v[2598] * v[562] + v[2599] * v[563] + v[2602] * v[576] + v[2606] * v[577]
			+ v[2603] * v[578] + v[2607] * v[591] + v[2608] * v[592] + v[2605] * v[593];
		v[2794] = -(QBi[0][1] * v[2556]) - QBi[1][1] * v[2557] - QBi[2][1] * v[2560] - v[2562] * v[278] - v[2563] * v[281]
			- v[2564] * v[284] + v[2600] * v[558] + v[2598] * v[559] + v[2599] * v[560] + v[2602] * v[573] + v[2606] * v[574]
			+ v[2603] * v[575] + v[2607] * v[588] + v[2608] * v[589] + v[2605] * v[590];
		v[2795] = -(QBi[0][0] * v[2556]) - QBi[1][0] * v[2557] - QBi[2][0] * v[2560] - v[2562] * v[277] - v[2563] * v[280]
			- v[2564] * v[283] + v[2600] * v[555] + v[2598] * v[556] + v[2599] * v[557] + v[2602] * v[570] + v[2606] * v[571]
			+ v[2603] * v[572] + v[2607] * v[585] + v[2608] * v[586] + v[2605] * v[587];
		v[2796] = dGBp[2][1] * v[2793] + dGBp[1][1] * v[2794] + dGBp[0][1] * v[2795] + v[2499] * v[3401] + v[2500] * v[3402];
		v[2797] = dGBp[2][0] * v[2793] + dGBp[1][0] * v[2794] + dGBp[0][0] * v[2795] + v[2499] * v[3403] + v[2500] * v[3404];
		v[2798] = (-2e0*v[2652] + 2e0*v[2655] - v[2751] * v[414] - 2e0*v[2749] * v[419] - 2e0*v[2750] * v[425]
			- 2e0*v[2752] * v[429] - v[2753] * v[433] - 2e0*v[2754] * v[438] - 2e0*v[2767] * v[442] - 2e0*v[2768] * v[446]
			- v[2769] * v[451]) / 2e0;
		v[2799] = (v[2438] * v[2530] + v[218] * v[2742] - v[2751] * v[411] + v[2743] * v[412] - v[2746] * v[413]) / 2e0;
		v[2801] = -v[2653] + v[2665] + (v[2743] * v[414]) / 2e0 + v[2744] * v[419] + v[2745] * v[425] + v[2762] * v[429] +
			(v[2764] * v[433]) / 2e0 + v[2763] * v[438] + v[2771] * v[442] + v[2770] * v[446] + (v[2772] * v[451]) / 2e0;
		v[2802] = (v[2431] * v[2530] + v[218] * v[2734] - v[2753] * v[411] + v[2764] * v[412] - v[2757] * v[413]) / 2e0;
		v[2803] = (-2e0*v[2659] + 2e0*v[2663] - v[2746] * v[414] - 2e0*v[2748] * v[419] - 2e0*v[2747] * v[425]
			- 2e0*v[2756] * v[429] - v[2757] * v[433] - 2e0*v[2755] * v[438] - 2e0*v[2759] * v[442] - 2e0*v[2758] * v[446]
			- v[2760] * v[451]) / 2e0;
		v[2816] = v[1567] * v[2801] - v[2802] + v[1564] * v[2803] + 8e0*v[1500] * (v[2463] * v[2489] - v[2798] * v[399]) - 2e0*
			(v[2438] * v[2488] + v[2431] * v[2490] + v[2424] * v[2492] + 2e0*v[2437] * v[2509] + 2e0*v[2432] * v[2511]
				+ 2e0*v[2430] * v[2512] + 2e0*v[2425] * v[2514] + 2e0*v[2436] * v[2515] + 2e0*v[2426] * v[2517] + 4e0*v[218] *
				(v[1884] * v[2586] + v[1889] * v[2587] + v[1894] * v[2588] + v[2654] + v[1694] * v[2656] + v[2657] + v[2660]
					+ v[1692] * v[2661] + v[1688] * v[2662]) + 2e0*v[2745] - 2e0*v[2748] - 2e0*v[2754] + 2e0*v[2756]
				+ alphaA[1] * v[2761] - alphaA[0] * v[2765] + 2e0*v[2768] - 2e0*v[2771] - alphaA[2] * v[2773] - v[2780] * v[399]
				- v[2781] * v[402] - v[2776] * v[404] + v[2742] * v[414] + 2e0*v[2739] * v[419] + 2e0*v[2737] * v[425]
				+ 2e0*v[2736] * v[429] + v[2734] * v[433] + 2e0*v[2731] * v[438] + 2e0*v[2730] * v[442] + 2e0*v[2728] * v[446]
				+ v[2725] * v[451])*v[966];
		v[3162] = v[2816] + (-(v[2424] * v[2530]) - v[218] * v[2725] + v[2769] * v[411] - v[2772] * v[412] + v[2760] * v[413])
			/ 2e0;
		v[3161] = (v[2774] + v[2778]) / 2e0;
		v[2806] = v[2777] + v[2779];
		v[2807] = v[2766] + v[2775];
		v[5504] = 0e0;
		v[5505] = 0e0;
		v[5506] = 0e0;
		v[5507] = 2e0*v[2813];
		v[5508] = v[2814];
		v[5509] = v[2815];
		v[5510] = 0e0;
		v[5511] = 0e0;
		v[5512] = 0e0;
		v[5513] = 0e0;
		v[5514] = 0e0;
		v[5515] = 0e0;
		v[5516] = 0e0;
		v[5517] = 0e0;
		v[5518] = 0e0;
		v[5519] = v[2814];
		v[5520] = 2e0*v[2817];
		v[5521] = v[2818];
		v[5522] = 0e0;
		v[5523] = 0e0;
		v[5524] = 0e0;
		v[5525] = 0e0;
		v[5526] = 0e0;
		v[5527] = 0e0;
		v[5528] = 0e0;
		v[5529] = 0e0;
		v[5530] = 0e0;
		v[5531] = v[2815];
		v[5532] = v[2818];
		v[5533] = 2e0*v[2819];
		v[5534] = 0e0;
		v[5535] = 0e0;
		v[5536] = 0e0;
		v[5537] = 0e0;
		v[5538] = 0e0;
		v[5539] = 0e0;
		v[5540] = 0e0;
		v[5541] = 0e0;
		v[5542] = 0e0;
		v[5543] = 0e0;
		v[5544] = 0e0;
		v[5545] = 0e0;
		v[5546] = 0e0;
		v[5547] = 0e0;
		v[5548] = 0e0;
		v[5549] = 2e0*v[2820];
		v[5550] = v[2821];
		v[5551] = v[2822];
		v[5552] = 0e0;
		v[5553] = 0e0;
		v[5554] = 0e0;
		v[5555] = 0e0;
		v[5556] = 0e0;
		v[5557] = 0e0;
		v[5558] = 0e0;
		v[5559] = 0e0;
		v[5560] = 0e0;
		v[5561] = v[2821];
		v[5562] = 2e0*v[2824];
		v[5563] = v[2825];
		v[5564] = 0e0;
		v[5565] = 0e0;
		v[5566] = 0e0;
		v[5567] = 0e0;
		v[5568] = 0e0;
		v[5569] = 0e0;
		v[5570] = 0e0;
		v[5571] = 0e0;
		v[5572] = 0e0;
		v[5573] = v[2822];
		v[5574] = v[2825];
		v[5575] = 2e0*v[2826];
		v[5576] = v[2562];
		v[5577] = v[2563];
		v[5578] = v[2564];
		v[5579] = -v[2777] + v[2779] + v[2765] * v[3100] + 2e0*(v[2780] * v[3100] + v[2798] * v[3102]) + alphaA[2] * v[3161]
			+ 2e0*alphaA[0] * v[3162] + v[2807] * v[400] + v[5503 + i2415];
		v[5580] = v[2774] - v[2778] + (alphaA[2] * v[2806]) / 2e0 + (alphaA[0] * v[2807]) / 2e0 - v[2761] * v[3100]
			+ 2e0*alphaA[1] * (-v[2799] + v[2802] + v[3162]) + v[5515 + i2415] + 2e0*(v[2781] * v[3100] - 4e0*v[2801] * v[966]);
		v[5581] = -v[2766] + v[2775] + 2e0*alphaA[2] * (-v[2799] + v[2816]) + v[2773] * v[3100] + 2e0*(v[2776] * v[3100]
			+ v[2803] * v[3102]) + alphaA[0] * v[3161] + v[2806] * v[400] + v[5527 + i2415];
		v[5582] = -v[2562];
		v[5583] = -v[2563];
		v[5584] = -v[2564];
		v[5585] = -v[2719] + v[2721] + v[2707] * v[3103] + 2e0*(v[2722] * v[3103] + v[2783] * v[3105]) + alphaB[2] * v[3163]
			+ 2e0*alphaB[0] * v[3164] + v[2792] * v[406] + v[5539 + i2415];
		v[5586] = v[2716] - v[2720] + (alphaB[2] * v[2791]) / 2e0 + (alphaB[0] * v[2792]) / 2e0 - v[2703] * v[3103]
			+ 2e0*alphaB[1] * (-v[2784] + v[2787] + v[3164]) + v[5551 + i2415] + 2e0*(v[2723] * v[3103] - 4e0*v[2786] * v[981]);
		v[5587] = -v[2708] + v[2717] + 2e0*alphaB[2] * (-v[2784] + v[2823]) + v[2715] * v[3103] + 2e0*(v[2718] * v[3103]
			+ v[2788] * v[3105]) + alphaB[0] * v[3163] + v[2791] * v[406] + v[5563 + i2415];
		v[2808] = QAi[0][0] * v[2553] + QAi[1][0] * v[2554] + QAi[2][0] * v[2555] + v[237] * v[2562] + v[240] * v[2563]
			+ v[243] * v[2564] + v[2611] * v[456] + v[2609] * v[457] + v[2610] * v[458] + v[2612] * v[471] + v[2615] * v[472]
			+ v[2613] * v[473] + v[2616] * v[486] + v[2617] * v[487] + v[2614] * v[488];
		v[2809] = QAi[0][1] * v[2553] + QAi[1][1] * v[2554] + QAi[2][1] * v[2555] + v[238] * v[2562] + v[241] * v[2563]
			+ v[244] * v[2564] + v[2611] * v[459] + v[2609] * v[460] + v[2610] * v[461] + v[2612] * v[474] + v[2615] * v[475]
			+ v[2613] * v[476] + v[2616] * v[489] + v[2617] * v[490] + v[2614] * v[491];
		v[2810] = QAi[0][2] * v[2553] + QAi[1][2] * v[2554] + QAi[2][2] * v[2555] + v[239] * v[2562] + v[242] * v[2563]
			+ v[245] * v[2564] + v[2611] * v[462] + v[2609] * v[463] + v[2610] * v[464] + v[2612] * v[477] + v[2615] * v[478]
			+ v[2613] * v[479] + v[2616] * v[492] + v[2617] * v[493] + v[2614] * v[494];
		v[2811] = dGAp[0][1] * v[2808] + dGAp[1][1] * v[2809] + dGAp[2][1] * v[2810] + v[2504] * v[3405] + v[2505] * v[3406];
		v[2812] = dGAp[0][0] * v[2808] + dGAp[1][0] * v[2809] + dGAp[2][0] * v[2810] + v[2504] * v[3407] + v[2505] * v[3408];
		Rc[i2415 - 1] += v[2471] * v[2499] + v[2470] * v[2500] + v[2468] * v[2504] + v[2469] * v[2505] + v[5463 + i2415];
		for (i2479 = 1; i2479 <= 12; i2479++) {
			Kc[i2415 - 1][i2479 - 1] += v[2796] * v[4211 + i2479] + v[2797] * v[4223 + i2479] + v[2812] * v[4235 + i2479]
				+ v[2811] * v[4247 + i2479] + v[5575 + i2479] + (*a4)*v[5587 + i2479];
		};/* end for */
	};/* end for */
#pragma endregion

	//if (index1 == 45 && index2 == 63 /*&& sub_index1 == 5 && sub_index2 == 2*/ && (db.last_converged_time + db.current_time_step) > 1.30475) {
		//db.PrintPtr(Rc, 12);
		//db.PrintPtr(Kc, 12, 12);
	//}
	//db.PrintPtr(Rc, 12);
	//db.PrintPtr(Kc, 12, 12);

	//db.myprintf("Time: %.6e\n", (db.last_converged_time + db.current_time_step));
	/*db.myprintf("gti: %.e %.6e %.e6\n", gti[0], gti[1], gti[2]);
	db.myprintf("gtupdaded: %.6e %.6e %.6e\n", gtpupdated[0], gtpupdated[1], gtpupdated[2]);*/
	delete[] v;
}

void RigidNURBSSurface_RigidNURBSSurface::PreCalc()
{
	surfA = static_cast<NURBSMultipatchSurface*>(db.cad_data[CAD_AID - 1]);
	surfB = static_cast<NURBSMultipatchSurface*>(db.cad_data[CAD_BID - 1]);
	
	//Marina
	int subs = 0;
	for (int i = 0; i < surfA->n_patches; i++)
	{
		if (sub_index1 < (subs + surfA->patches[i]->subdivisions[0] * surfA->patches[i]->subdivisions[1])) {
			patchA = i;
			for (int j = 0; j < surfA->patches[i]->subdivisions[0]; j++)
			{
				if ((sub_index1 - (subs - 1)) <= (j + 1) * (surfA->patches[i]->subdivisions[1])) {
					subA_u = j;
					subA_v = (surfA->patches[i]->subdivisions[1] - 1) - ((j + 1) * (surfA->patches[i]->subdivisions[1]) - (sub_index1 - (subs - 1)));
					break;
				}
			}
			break;
		}
		subs = subs + surfA->patches[i]->subdivisions[0] * surfA->patches[i]->subdivisions[1];
	}
	subs = 0;
	for (int i = 0; i < surfB->n_patches; i++)
	{
		if (sub_index2 < (subs + surfB->patches[i]->subdivisions[0] * surfB->patches[i]->subdivisions[1])) {
			patchB = i;
			for (int j = 0; j < surfB->patches[i]->subdivisions[0]; j++)
			{
				if ((sub_index2 - (subs - 1)) <= (j + 1) * (surfB->patches[i]->subdivisions[1])) {
					subB_u = j;
					subB_v = (surfB->patches[i]->subdivisions[1] - 1) - ((j + 1) * (surfB->patches[i]->subdivisions[1]) - (sub_index2 - (subs - 1)));
					break;
				}
			}
			break;
		}
		subs = subs + surfB->patches[i]->subdivisions[0] * surfB->patches[i]->subdivisions[1];
	}

	cd->patchA[0] = patchA;
	cd->patchB[0] = patchB;
	cd->copy_patchA[0] = patchA;
	cd->copy_patchB[0] = patchB;

	//Case 7 - no degeneration (not treated)
	//Degeneration basis - canonical basis
	(*cd->P[/*ip*/0])(0, 0) = 1.0;
	(*cd->P[/*ip*/0])(1, 1) = 1.0;
	(*cd->P[/*ip*/0])(2, 2) = 1.0;
	(*cd->P[/*ip*/0])(3, 3) = 1.0;
	(*cd->P_0[/*ip*/0])(0, 0) = 1.0;
	(*cd->P_0[/*ip*/0])(1, 1) = 1.0;
	(*cd->P_0[/*ip*/0])(2, 2) = 1.0;
	(*cd->P_0[/*ip*/0])(3, 3) = 1.0;
	//Degenerated coordinates index (in the new basis)
	cd->deg_control[/*ip*/0][0] = false;
	cd->deg_control[/*ip*/0][1] = false;
	cd->deg_control[/*ip*/0][2] = false;
	cd->deg_control[/*ip*/0][3] = false;
	//Degenerated coordinates values - in case of degeneration, just fill the desired coordinate value
	cd->copy_deg_coordinates[/*ip*/0][0] = 0.0;
	cd->copy_deg_coordinates[/*ip*/0][1] = 0.0;
	cd->copy_deg_coordinates[/*ip*/0][2] = 0.0;
	cd->copy_deg_coordinates[/*ip*/0][3] = 0.0;

	//x1A = surfA->vertices[vertexIDsA[0] - 1].coord_double->getMatrix();
	//x2A = surfA->vertices[vertexIDsA[1] - 1].coord_double->getMatrix();
	//x3A = surfA->vertices[vertexIDsA[2] - 1].coord_double->getMatrix();
	//x1B = surfB->vertices[vertexIDsB[0] - 1].coord_double->getMatrix();
	//x2B = surfB->vertices[vertexIDsB[1] - 1].coord_double->getMatrix();
	//x3B = surfB->vertices[vertexIDsB[2] - 1].coord_double->getMatrix();
	gti = cd->copy_g_t[0]->getMatrix();
	gtpupdated = cd->g_t[0]->getMatrix();
	stick = &cd->copy_stick[0];
	stickupdated = &cd->stick[0];
	invH = cd->invHessian[0];

	//Contact Interface law
	bool scape = false;
	for (int i = 0; i < db.number_contactinterfaces && scape == false; i++)
	{
		if ((db.contactinterfaces[i]->material_1 == material_A && db.contactinterfaces[i]->material_2 == material_B) ||
			(db.contactinterfaces[i]->material_1 == material_B && db.contactinterfaces[i]->material_2 == material_A))
		{
			if (typeid(*db.contactinterfaces[i]) == typeid(Interface_2))
			{
				inter = static_cast<Interface_2*>(db.contactinterfaces[i]);
				scape = true;
			}
		}
	}
	if (scape == false)
		printf("Error in PreCalc of RigidNURBSSurface_RigidNURBSSurface!\n");

	epsn = &inter->epsn;
	cn = &inter->cn;
	mus = &inter->mus;
	mud = &inter->mud;
	epst = &inter->epst;
	ct = &inter->ct;

	//Masses (for damping in contact)
	double mA = db.cad_data[CAD_AID - 1]->volume*db.materials[material_A - 1]->rho;
	double mB = db.cad_data[CAD_BID - 1]->volume*db.materials[material_B - 1]->rho;
	/*
	double eps = DBL_EPSILON;
	if (mA > eps && mB > eps)
		*meq = (mA*mB) / (mA + mB);
	else
	{
		if (mA > eps)
			*meq = mA;
		else
			*meq = mB;
	}
	*/
}

void RigidNURBSSurface_RigidNURBSSurface::SetVariables()
{
	for (int i = 0; i < 3; i++)
	{
		xAi[i] = db.nodes[node_A - 1]->copy_coordinates[i];
		xBi[i] = db.nodes[node_B - 1]->copy_coordinates[i];
		uA[i] = db.nodes[node_A - 1]->displacements[i];
		uB[i] = db.nodes[node_B - 1]->displacements[i];
		alphaA[i] = db.nodes[node_A - 1]->displacements[i + 3];
		alphaB[i] = db.nodes[node_B - 1]->displacements[i + 3];

		duiA[i] = db.nodes[node_A - 1]->copy_vel[i];
		duiB[i] = db.nodes[node_B - 1]->copy_vel[i];
		dduiA[i] = db.nodes[node_A - 1]->copy_accel[i];
		dduiB[i] = db.nodes[node_B - 1]->copy_accel[i];
		dalphaiA[i] = db.nodes[node_A - 1]->copy_vel[i + 3];
		dalphaiB[i] = db.nodes[node_B - 1]->copy_vel[i + 3];
		ddalphaiA[i] = db.nodes[node_A - 1]->copy_accel[i + 3];
		ddalphaiB[i] = db.nodes[node_B - 1]->copy_accel[i + 3];

		for (int j = 0; j < 3; j++)
		{
			QAi[i][j] = (*ptrQAi)(i, j);
			QBi[i][j] = (*ptrQBi)(i, j);
		}
	}
}

void RigidNURBSSurface_RigidNURBSSurface::HessianPhase1(Matrix & mHes)
{
	//TODO
}

void RigidNURBSSurface_RigidNURBSSurface::SurfacePoints()
{
	double z;
	double th;
	Matrix localx;

	//Gamma A
	if (previous_evaluation == false)
	{
		z = cd->convective[0][0];
		th = cd->convective[0][1];
		surfA->patches[cd->patchA[0]]->SurfacePoint(ptrQAp, ptrx0Ap, z, th, *GammaA);
	}
	else
	{
		z = cd->copy_convective[0][0];
		th = cd->copy_convective[0][1];
		surfA->patches[cd->patchA[0]]->SurfacePoint(ptrQAi, ptrx0Ai, z, th, *GammaA);
	}

	//Gamma B
	if (previous_evaluation == false)
	{
		z = cd->convective[0][2];
		th = cd->convective[0][3];
		surfB->patches[cd->patchB[0]]->SurfacePoint(ptrQBp, ptrx0Bp, z, th, *GammaB);
	}
	else
	{
		z = cd->copy_convective[0][2];
		th = cd->copy_convective[0][3];
		surfB->patches[cd->patchB[0]]->SurfacePoint(ptrQBi, ptrx0Bi, z, th, *GammaB);
	}
}

void RigidNURBSSurface_RigidNURBSSurface::Report()
{
	if (active)
	{
		/*if (prev_eligible == false && eligible == true)
		{
			db.myprintf("\n---------- New (active) contact ---------- I1: %d I2: %d \nfaceA: %d curveA: %d pointA: %d\nfaceB: %d curveB: %d pointB: %d\n", index1, index2, faceA->ID, deg_curveA, deg_pointA, faceB->ID, deg_curveB, deg_pointB);
			cd->Plot();
		}
		if (prev_eligible == true && eligible == false)
		{
			db.myprintf("\n---------- Old (unnactive) contact ---------- I1: %d I2: %d \nfaceA: %d curveA: %d pointA: %d\nfaceB: %d curveB: %d pointB: %d\n", index1, index2, faceA->ID, deg_curveA, deg_pointA, faceB->ID, deg_curveB, deg_pointB);
			cd->Plot();
		}*/
		/*
		if (cd->g_n[0] < *gnbb)
			db.myprintf("---------- Barrier activated! ---------- %.1f %c of contact layer is active.\n", 100.0*(1.0-cd->g_n[0]/(*gnb)),37);
		*/
	}
}

void RigidNURBSSurface_RigidNURBSSurface::CompactReport()
{
	db.myprintf("Eligible %d\n", (int)eligible);
	db.myprintf("Deg point A: %d\n", deg_pointA);
	db.myprintf("Deg point B: %d\n", deg_pointB);
	db.myprintf("Deg curve A: %d\n", deg_curveA);
	db.myprintf("Deg curve B: %d\n", deg_curveB);
	db.myprintf("Gap %.6e\n", cd->g_n[0]);
}

void RigidNURBSSurface_RigidNURBSSurface::PredictorTimeStep(double kin)
{
	/**/
}

/*void RigidNURBSSurface_RigidNURBSSurface::AllocSpecificExplicit()
{
	if (alloc_specific_explicit_control == false)
	{
		alloc_specific_explicit_control = true;
	}
}*/

/*void RigidNURBSSurface_RigidNURBSSurface::FreeSpecificExplicit()
{
	if (alloc_specific_explicit_control == true)
	{
		alloc_specific_explicit_control = false;
	}
}*/

void RigidNURBSSurface_RigidNURBSSurface::MountLocalContributionsExplicit(double t)
{
	cAp[0] = cd->convective[0][0];
	cAp[1] = cd->convective[0][1];
	cBp[0] = cd->convective[0][2];
	cBp[1] = cd->convective[0][3];

	Matrix p(4);
	p(0, 0) = cAp[0];
	p(1, 0) = cAp[1];
	p(2, 0) = cBp[0];
	p(3, 0) = cBp[1];

	Matrix patch_p(2);
	patch_p(0, 0) = cd->patchA[0];
	patch_p(1, 0) = cd->patchB[0];

	bool previouscontact = prev_eligible;

	// Verificar se previouscontact é falso
		// Opção a: não havia contato prévio entre as partículas e, portanto, o gti deve ser 0 e o previouscontact deve ser 'false'
		// Opção b: houve mudança de patch e, portanto, o gti deve ser o do patch vizinho que havia contato r o previous contact deve ser 'true'

	Matrix i(4);
	Matrix patch_i(2);

	cAi[0] = cd->copy_convective[0][0];
	cAi[1] = cd->copy_convective[0][1];
	cBi[0] = cd->copy_convective[0][2];
	cBi[1] = cd->copy_convective[0][3];

	i(0, 0) = cAi[0];
	i(1, 0) = cAi[1];
	i(2, 0) = cBi[0];
	i(3, 0) = cBi[1];

	patch_i(0, 0) = cd->copy_patchA[0];
	patch_i(1, 0) = cd->copy_patchB[0];

	if (previouscontact == false) {
		for (int cont = 0; cont < db.gcs->contactPP_list[index1].size(); cont++)
		{
			if ((db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->prev_eligible == true) && (db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->eligible == false) && (db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->index2 == index2))
			{
				gti[0] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[0];
				gti[1] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[1];
				gti[2] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[2];
				previouscontact = true;

				cAi[0] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][0];
				cAi[1] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][1];
				cBi[0] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][2];
				cBi[1] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][3];

				i(0, 0) = cAi[0];
				i(1, 0) = cAi[1];
				i(2, 0) = cBi[0];
				i(3, 0) = cBi[1];

				patch_i(0, 0) = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_patchA[0];
				patch_i(1, 0) = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_patchB[0];
			}
			else
			{

			}
		}
	}

	// Verificar se previouscontact é falso, o que indica que houve mudança de patch (se gira e deixa de ser contato e depois volta, o previouscontact é coerente?)
	// Analisar para as particulas se tinha algum contato anterior no passo anterior (como?)
	// Se sim, pegar informações pertinentes CAi,gti, ni

	/*if (index1 == 0) {
		cout << "InvH" << endl;
		cout << invH[0][0] << " " << invH[0][1] << " " << invH[0][2] << endl;
		cout << invH[1][0] << " " << invH[1][1] << " " << invH[1][2] << endl;
		cout << invH[2][0] << " " << invH[2][1] << " " << invH[2][2] << endl;
		cout << endl;
		cout << cAi[0] << " " << cAi[1] << endl;
		cout << endl;
	}*/

	v = DBG_NEW double[5800];

	double value = 0.0;
	//Zerando matrizes e vetores
	for (int i = 0; i < 12; i++)
	{
		Rc[i] = 0.0;
		for (int j = 0; j < 12; j++)
			Kc[i][j] = 0.0;
	}

	EvaluateNURBSDerivatives_p(p, patch_p);
	EvaluateNURBSDerivatives_i(i, patch_i);
	//EvaluateNURBSDOFsVariables();

	//Avalia contribuições de contato

#pragma region AceGen
	double v01; double v010; double v011; double v012; double v013; double v014;
	double v015; double v016; double v017; double v018; double v019; double v02;
	double v020; double v021; double v022; double v023; double v024; double v025;
	double v026; double v027; double v03; double v04; double v05; double v06; double v07;
	double v08; double v09;
	int b235, b267, b309, b325, b327, b343, b361, b373;
	v[131] = Q0A[0][0] * QAi[0][2] + Q0A[0][1] * QAi[1][2] + Q0A[0][2] * QAi[2][2];
	v[130] = Q0A[0][0] * QAi[0][1] + Q0A[0][1] * QAi[1][1] + Q0A[0][2] * QAi[2][1];
	v[129] = Q0A[0][0] * QAi[0][0] + Q0A[0][1] * QAi[1][0] + Q0A[0][2] * QAi[2][0];
	v[137] = Q0A[1][0] * QAi[0][2] + Q0A[1][1] * QAi[1][2] + Q0A[1][2] * QAi[2][2];
	v[136] = Q0A[1][0] * QAi[0][1] + Q0A[1][1] * QAi[1][1] + Q0A[1][2] * QAi[2][1];
	v[135] = Q0A[1][0] * QAi[0][0] + Q0A[1][1] * QAi[1][0] + Q0A[1][2] * QAi[2][0];
	v[143] = Q0A[2][0] * QAi[0][2] + Q0A[2][1] * QAi[1][2] + Q0A[2][2] * QAi[2][2];
	v[142] = Q0A[2][0] * QAi[0][1] + Q0A[2][1] * QAi[1][1] + Q0A[2][2] * QAi[2][1];
	v[141] = Q0A[2][0] * QAi[0][0] + Q0A[2][1] * QAi[1][0] + Q0A[2][2] * QAi[2][0];
	v[117] = Power(alphaA[0], 2);
	v[115] = (alphaA[0] * alphaA[1]) / 2e0;
	v[110] = Power(alphaA[1], 2);
	v[122] = (alphaA[1] * alphaA[2]) / 2e0;
	v[120] = (alphaA[0] * alphaA[2]) / 2e0;
	v[111] = Power(alphaA[2], 2);
	v[449] = v[110] + v[111];
	v[180] = Q0B[0][0] * QBi[0][2] + Q0B[0][1] * QBi[1][2] + Q0B[0][2] * QBi[2][2];
	v[179] = Q0B[0][0] * QBi[0][1] + Q0B[0][1] * QBi[1][1] + Q0B[0][2] * QBi[2][1];
	v[178] = Q0B[0][0] * QBi[0][0] + Q0B[0][1] * QBi[1][0] + Q0B[0][2] * QBi[2][0];
	v[186] = Q0B[1][0] * QBi[0][2] + Q0B[1][1] * QBi[1][2] + Q0B[1][2] * QBi[2][2];
	v[185] = Q0B[1][0] * QBi[0][1] + Q0B[1][1] * QBi[1][1] + Q0B[1][2] * QBi[2][1];
	v[184] = Q0B[1][0] * QBi[0][0] + Q0B[1][1] * QBi[1][0] + Q0B[1][2] * QBi[2][0];
	v[192] = Q0B[2][0] * QBi[0][2] + Q0B[2][1] * QBi[1][2] + Q0B[2][2] * QBi[2][2];
	v[191] = Q0B[2][0] * QBi[0][1] + Q0B[2][1] * QBi[1][1] + Q0B[2][2] * QBi[2][1];
	v[190] = Q0B[2][0] * QBi[0][0] + Q0B[2][1] * QBi[1][0] + Q0B[2][2] * QBi[2][0];
	v[166] = Power(alphaB[0], 2);
	v[164] = (alphaB[0] * alphaB[1]) / 2e0;
	v[159] = Power(alphaB[1], 2);
	v[171] = (alphaB[1] * alphaB[2]) / 2e0;
	v[169] = (alphaB[0] * alphaB[2]) / 2e0;
	v[160] = Power(alphaB[2], 2);
	v[450] = v[159] + v[160];
	v[109] = 4e0 / (4e0 + v[117] + v[449]);
	v[112] = 1e0 - (v[109] * v[449]) / 2e0;
	v[113] = v[109] * (-alphaA[2] + v[115]);
	v[114] = v[109] * (alphaA[1] + v[120]);
	v[116] = v[109] * (alphaA[2] + v[115]);
	v[118] = 1e0 - (v[109] * (v[111] + v[117])) / 2e0;
	v[119] = v[109] * (-alphaA[0] + v[122]);
	v[121] = v[109] * (-alphaA[1] + v[120]);
	v[123] = v[109] * (alphaA[0] + v[122]);
	v[124] = 1e0 - (v[109] * (v[110] + v[117])) / 2e0;
	v[125] = -(alphaA[2] * v[109]) / 2e0;
	v[126] = (alphaA[1] * v[109]) / 2e0;
	v[127] = -(alphaA[0] * v[109]) / 2e0;
	v[128] = v[112] * v[129] + v[116] * v[130] + v[121] * v[131];
	v[132] = v[113] * v[129] + v[118] * v[130] + v[123] * v[131];
	v[133] = v[114] * v[129] + v[119] * v[130] + v[124] * v[131];
	v[134] = v[112] * v[135] + v[116] * v[136] + v[121] * v[137];
	v[138] = v[113] * v[135] + v[118] * v[136] + v[123] * v[137];
	v[139] = v[114] * v[135] + v[119] * v[136] + v[124] * v[137];
	v[140] = v[112] * v[141] + v[116] * v[142] + v[121] * v[143];
	v[144] = v[113] * v[141] + v[118] * v[142] + v[123] * v[143];
	v[145] = v[114] * v[141] + v[119] * v[142] + v[124] * v[143];
	v[158] = 4e0 / (4e0 + v[166] + v[450]);
	v[161] = 1e0 - (v[158] * v[450]) / 2e0;
	v[162] = v[158] * (-alphaB[2] + v[164]);
	v[163] = v[158] * (alphaB[1] + v[169]);
	v[165] = v[158] * (alphaB[2] + v[164]);
	v[167] = 1e0 - (v[158] * (v[160] + v[166])) / 2e0;
	v[168] = v[158] * (-alphaB[0] + v[171]);
	v[170] = v[158] * (-alphaB[1] + v[169]);
	v[172] = v[158] * (alphaB[0] + v[171]);
	v[173] = 1e0 - (v[158] * (v[159] + v[166])) / 2e0;
	v[174] = -(alphaB[2] * v[158]) / 2e0;
	v[175] = (alphaB[1] * v[158]) / 2e0;
	v[176] = -(alphaB[0] * v[158]) / 2e0;
	v[177] = v[161] * v[178] + v[165] * v[179] + v[170] * v[180];
	v[181] = v[162] * v[178] + v[167] * v[179] + v[172] * v[180];
	v[182] = v[163] * v[178] + v[168] * v[179] + v[173] * v[180];
	v[183] = v[161] * v[184] + v[165] * v[185] + v[170] * v[186];
	v[187] = v[162] * v[184] + v[167] * v[185] + v[172] * v[186];
	v[188] = v[163] * v[184] + v[168] * v[185] + v[173] * v[186];
	v[189] = v[161] * v[190] + v[165] * v[191] + v[170] * v[192];
	v[193] = v[162] * v[190] + v[167] * v[191] + v[172] * v[192];
	v[194] = v[163] * v[190] + v[168] * v[191] + v[173] * v[192];
	v[455] = uA[0] - uB[0] + xAi[0] - xBi[0];
	v[454] = uA[1] - uB[1] + xAi[1] - xBi[1];
	v[453] = uA[2] - uB[2] + xAi[2] - xBi[2];
	v[207] = GAp[0] * v[128] + GAp[1] * v[132] + GAp[2] * v[133] - GBp[0] * v[177] - GBp[1] * v[181] - GBp[2] * v[182] + v[455];
	v[208] = GAp[0] * v[134] + GAp[1] * v[138] + GAp[2] * v[139] - GBp[0] * v[183] - GBp[1] * v[187] - GBp[2] * v[188] + v[454];
	v[209] = GAp[0] * v[140] + GAp[1] * v[144] + GAp[2] * v[145] - GBp[0] * v[189] - GBp[1] * v[193] - GBp[2] * v[194] + v[453];
	v[210] = GAi[0] * v[129] + GAi[1] * v[130] + GAi[2] * v[131] - GBi[0] * v[178] - GBi[1] * v[179] - GBi[2] * v[180] + xAi[0]
		- xBi[0];
	v[211] = GAi[0] * v[135] + GAi[1] * v[136] + GAi[2] * v[137] - GBi[0] * v[184] - GBi[1] * v[185] - GBi[2] * v[186] + xAi[1]
		- xBi[1];
	v[212] = GAi[0] * v[141] + GAi[1] * v[142] + GAi[2] * v[143] - GBi[0] * v[190] - GBi[1] * v[191] - GBi[2] * v[192] + xAi[2]
		- xBi[2];
	v[216] = sqrt((v[207] * v[207]) + (v[208] * v[208]) + (v[209] * v[209]));
	if (v[216] > 0.1e-7) { v01 = 1e0 / v[216]; v02 = (-(v01 / v[216])); v03 = (2e0*v01) / Power(v[216], 2); }
	else {
		v01 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[216])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[216])*(0.2399999997e10
			- 0.1199999994e18*v[216] - 0.3e17*(v[216] * v[216]))));
		v02 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[216] + 0.6e25*Power(v[216], 3)
			+ 0.1799999982e26*(v[216] * v[216]));
		v03 = 0.1e17*(799999997e0 - 0.599999994e17*v[216] - 0.3e17*(v[216] * v[216]));
	};
	v[221] = v01;
	v[222] = v[207] * v[221];
	v[462] = (v[222] * v[222]);
	v[290] = 1e0 - v[462];
	v[223] = v[208] * v[221];
	v[463] = (v[223] * v[223]);
	v[295] = 1e0 - v[463];
	v[224] = v[209] * v[221];
	v[464] = (v[224] * v[224]);
	v[300] = 1e0 - v[464];
	v[225] = sqrt((v[210] * v[210]) + (v[211] * v[211]) + (v[212] * v[212]));
	if (v[225] > 0.1e-7) { v04 = 1e0 / v[225]; v05 = (-(v04 / v[225])); v06 = (2e0*v04) / Power(v[225], 2); }
	else {
		v04 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[225])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[225])*(0.2399999997e10
			- 0.1199999994e18*v[225] - 0.3e17*(v[225] * v[225]))));
		v05 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[225] + 0.6e25*Power(v[225], 3)
			+ 0.1799999982e26*(v[225] * v[225]));
		v06 = 0.1e17*(799999997e0 - 0.599999994e17*v[225] - 0.3e17*(v[225] * v[225]));
	};
	v[230] = v04;
	v[231] = v[210] * v[230];
	v[232] = v[211] * v[230];
	v[233] = v[212] * v[230];
	if (sqrt(Power(v[223] * v[231] - v[222] * v[232], 2) + Power(-(v[224] * v[231]) + v[222] * v[233], 2) + Power
	(v[224] * v[232] - v[223] * v[233], 2)) > 0.1e-7) {
		v[236] = v[224] * v[232] - v[223] * v[233];
		v[237] = -(v[224] * v[231]) + v[222] * v[233];
		v[238] = v[223] * v[231] - v[222] * v[232];
		v[239] = sqrt((v[236] * v[236]) + (v[237] * v[237]) + (v[238] * v[238]));
		if (v[239] > 0.1e-7) { v07 = 1e0 / v[239]; v08 = (-(v07 / v[239])); v09 = (2e0*v07) / Power(v[239], 2); }
		else {
			v07 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[239])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[239])*
				(0.2399999997e10 - 0.1199999994e18*v[239] - 0.3e17*(v[239] * v[239]))));
			v08 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[239] + 0.6e25*Power(v[239], 3)
				+ 0.1799999982e26*(v[239] * v[239]));
			v09 = 0.1e17*(799999997e0 - 0.599999994e17*v[239] - 0.3e17*(v[239] * v[239]));
		};
		v[451] = 2e0*v07*tan(asin(v[239]) / 2e0);
		v[248] = v[236] * v[451];
		v[259] = (v[248] * v[248]);
		v[249] = v[237] * v[451];
		v[257] = (v[248] * v[249]) / 2e0;
		v[252] = (v[249] * v[249]);
		v[250] = v[238] * v[451];
		v[264] = (v[249] * v[250]) / 2e0;
		v[262] = (v[248] * v[250]) / 2e0;
		v[253] = (v[250] * v[250]);
		v[452] = v[252] + v[253];
		v[251] = 4e0 / (4e0 + v[259] + v[452]);
		v[254] = 1e0 - (v[251] * v[452]) / 2e0;
		v[255] = v[251] * (-v[250] + v[257]);
		v[256] = v[251] * (v[249] + v[262]);
		v[258] = v[251] * (v[250] + v[257]);
		v[260] = 1e0 - (v[251] * (v[253] + v[259])) / 2e0;
		v[261] = v[251] * (-v[248] + v[264]);
		v[263] = v[251] * (-v[249] + v[262]);
		v[265] = v[251] * (v[248] + v[264]);
		v[266] = 1e0 - (v[251] * (v[252] + v[259])) / 2e0;
	}
	else {
		v[254] = 1e0;
		v[255] = 0e0;
		v[256] = 0e0;
		v[258] = 0e0;
		v[260] = 1e0;
		v[261] = 0e0;
		v[263] = 0e0;
		v[265] = 0e0;
		v[266] = 1e0;
	};
	if ((previouscontact)) {
		v[271] = GAi[0] * v[140] + GAi[1] * v[144] + GAi[2] * v[145] - GBi[0] * v[189] - GBi[1] * v[193] - GBi[2] * v[194]
			+ gti[0] * v[263] + gti[1] * v[265] + gti[2] * v[266] + v[453];
		v[456] = v[224] * v[271];
		v[270] = GAi[0] * v[134] + GAi[1] * v[138] + GAi[2] * v[139] - GBi[0] * v[183] - GBi[1] * v[187] - GBi[2] * v[188]
			+ gti[0] * v[258] + gti[1] * v[260] + gti[2] * v[261] + v[454];
		v[458] = v[223] * v[270];
		v[269] = GAi[0] * v[128] + GAi[1] * v[132] + GAi[2] * v[133] - GBi[0] * v[177] - GBi[1] * v[181] - GBi[2] * v[182]
			+ gti[0] * v[254] + gti[1] * v[255] + gti[2] * v[256] + v[455];
		v[457] = -(v[222] * v[269]);
		v[268] = v[269] * v[290] - v[222] * (v[456] + v[458]);
		v[272] = v[270] * v[295] + v[223] * (-v[456] + v[457]);
		v[273] = v[271] * v[300] + v[224] * (v[457] - v[458]);
	}
	else {
		v[268] = 0e0;
		v[272] = 0e0;
		v[273] = 0e0;
	};
	v[274] = dalphaiA[0] * v[109] + dalphaiA[1] * v[125] + dalphaiA[2] * v[126];
	v[275] = dalphaiA[1] * v[109] - dalphaiA[0] * v[125] + dalphaiA[2] * v[127];
	v[276] = dalphaiA[2] * v[109] - dalphaiA[0] * v[126] - dalphaiA[1] * v[127];
	v[277] = dalphaiB[0] * v[158] + dalphaiB[1] * v[174] + dalphaiB[2] * v[175];
	v[278] = dalphaiB[1] * v[158] - dalphaiB[0] * v[174] + dalphaiB[2] * v[176];
	v[279] = dalphaiB[2] * v[158] - dalphaiB[0] * v[175] - dalphaiB[1] * v[176];
	v[280] = duiA[0] - duiB[0] + GAp[2] * (-(v[132] * v[274]) + v[128] * v[275]) + GAp[1] * (v[133] * v[274] - v[128] * v[276])
		+ GAp[0] * (-(v[133] * v[275]) + v[132] * v[276]) + GBp[2] * (v[181] * v[277] - v[177] * v[278]) - GBp[1] * (v[182] * v[277]
			- v[177] * v[279]) + GBp[0] * (v[182] * v[278] - v[181] * v[279]);
	v[459] = v[222] * v[280];
	v[281] = duiA[1] - duiB[1] + GAp[2] * (-(v[138] * v[274]) + v[134] * v[275]) + GAp[1] * (v[139] * v[274] - v[134] * v[276])
		+ GAp[0] * (-(v[139] * v[275]) + v[138] * v[276]) + GBp[2] * (v[187] * v[277] - v[183] * v[278]) - GBp[1] * (v[188] * v[277]
			- v[183] * v[279]) + GBp[0] * (v[188] * v[278] - v[187] * v[279]);
	v[460] = v[223] * v[281];
	v[466] = v[224] * (v[459] + v[460]);
	v[291] = v[222] * v[460];
	v[282] = duiA[2] - duiB[2] + GAp[2] * (-(v[144] * v[274]) + v[140] * v[275]) + GAp[1] * (v[145] * v[274] - v[140] * v[276])
		+ GAp[0] * (-(v[145] * v[275]) + v[144] * v[276]) + GBp[2] * (v[193] * v[277] - v[189] * v[278]) - GBp[1] * (v[194] * v[277]
			- v[189] * v[279]) + GBp[0] * (v[194] * v[278] - v[193] * v[279]);
	v[461] = v[224] * v[282];
	v[465] = v[223] * (v[459] + v[461]);
	v[292] = v[222] * v[461];
	v[302] = (*epsn)*v[207];
	v[303] = (*epsn)*v[208];
	v[304] = (*epsn)*v[209];
	v[305] = (*cn)*(v[291] + v[292] + v[280] * v[462]);
	v[306] = (*cn)*(v[281] * v[463] + v[465]);
	v[307] = (*cn)*(v[282] * v[464] + v[466]);
	if (v[222] * (v[302] + v[305]) + v[223] * (v[303] + v[306]) + v[224] * (v[304] + v[307]) > 0e0) {
		v[310] = v[305];
		v[311] = v[306];
		v[312] = v[307];
	}
	else {
		v[310] = -v[302];
		v[311] = -v[303];
		v[312] = -v[304];
	};
	v[313] = v[302] + v[310];
	v[314] = v[303] + v[311];
	v[315] = v[304] + v[312];
	v[316] = (*epst)*v[268];
	v[317] = (*epst)*v[272];
	v[318] = (*epst)*v[273];
	v[322] = (*ct)*(v[280] * v[290] - v[291] - v[292]) + v[316];
	v[323] = v[317] - (*ct)*(-(v[281] * v[295]) + v[465]);
	v[324] = v[318] - (*ct)*(-(v[282] * v[300]) + v[466]);
	if ((*stick)) {
		if (sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324])) <= (*mus)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			v[328] = v[322];
			v[329] = v[323];
			v[330] = v[324];
			v[331] = 1e0;
		}
		else {
			v[332] = sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324]));
			if (v[332] > 0.1e-5) { v010 = 1e0 / v[332]; v011 = (-(v010 / v[332])); v012 = (2e0*v010) / Power(v[332], 2); }
			else {
				v010 = (24000000e0 - (-1e0 + 1000000e0*v[332])*(71999994e0 - 0.71999982e14*v[332] + 0.6e19*Power(v[332], 3)
					+ 0.23999982e20*(v[332] * v[332]))) / 24e0;
				v011 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[332] + 0.6e19*Power(v[332], 3) + 0.17999982e20*
					(v[332] * v[332]));
				v012 = 0.1e13*(7999997e0 - 0.5999994e13*v[332] - 0.3e13*(v[332] * v[332]));
			};
			v[467] = (*mud)*v010*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315]));
			v[328] = v[322] * v[467];
			v[329] = v[323] * v[467];
			v[330] = v[324] * v[467];
			v[331] = 0e0;
		};
		if (sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318])) > (*mus)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			if ((*epst) > 0.1e-5) {
				v013 = 1e0 / (*epst); v014 = (-(v013 / (*epst))); v015 = (2e0*v013) / Power((*epst), 2
				);
			}
			else {
				v013 = (24000000e0 - (-1e0 + 1000000e0*(*epst))*(71999994e0 - 0.71999982e14*(*epst) + 0.23999982e20*Power(
					(*epst), 2) + 0.6e19*Power((*epst), 3))) / 24e0;
				v014 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*(*epst) + 0.17999982e20*Power((*epst), 2)
					+ 0.6e19*Power((*epst), 3));
				v015 = 0.1e13*(7999997e0 - 0.5999994e13*(*epst) - 0.3e13*Power((*epst), 2));
			};
			v[350] = sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318]));
			if (v[350] > 0.1e-5) { v016 = 1e0 / v[350]; v017 = (-(v016 / v[350])); v018 = (2e0*v016) / Power(v[350], 2); }
			else {
				v016 = (24000000e0 - (-1e0 + 1000000e0*v[350])*(71999994e0 - 0.71999982e14*v[350] + 0.6e19*Power(v[350], 3)
					+ 0.23999982e20*(v[350] * v[350]))) / 24e0;
				v017 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[350] + 0.6e19*Power(v[350], 3) + 0.17999982e20*
					(v[350] * v[350]));
				v018 = 0.1e13*(7999997e0 - 0.5999994e13*v[350] - 0.3e13*(v[350] * v[350]));
			};
			v[357] = -((*mud)*v013*v016*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315])));
			v[356] = v[268] + v[316] * v[357];
			v[358] = v[272] + v[317] * v[357];
			v[359] = v[273] + v[318] * v[357];
		}
		else {
			v[356] = 0e0;
			v[358] = 0e0;
			v[359] = 0e0;
		};
	}
	else {
		if (sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324])) <= (*mud)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			v[328] = v[322];
			v[329] = v[323];
			v[330] = v[324];
			v[331] = 1e0;
		}
		else {
			v[362] = sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324]));
			if (v[362] > 0.1e-5) { v019 = 1e0 / v[362]; v020 = (-(v019 / v[362])); v021 = (2e0*v019) / Power(v[362], 2); }
			else {
				v019 = (24000000e0 - (-1e0 + 1000000e0*v[362])*(71999994e0 - 0.71999982e14*v[362] + 0.6e19*Power(v[362], 3)
					+ 0.23999982e20*(v[362] * v[362]))) / 24e0;
				v020 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[362] + 0.6e19*Power(v[362], 3) + 0.17999982e20*
					(v[362] * v[362]));
				v021 = 0.1e13*(7999997e0 - 0.5999994e13*v[362] - 0.3e13*(v[362] * v[362]));
			};
			v[468] = (*mud)*v019*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315]));
			v[328] = v[322] * v[468];
			v[329] = v[323] * v[468];
			v[330] = v[324] * v[468];
			v[331] = 0e0;
		};
		if (sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318])) > (*mud)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			if ((*epst) > 0.1e-5) {
				v022 = 1e0 / (*epst); v023 = (-(v022 / (*epst))); v024 = (2e0*v022) / Power((*epst), 2
				);
			}
			else {
				v022 = (24000000e0 - (-1e0 + 1000000e0*(*epst))*(71999994e0 - 0.71999982e14*(*epst) + 0.23999982e20*Power(
					(*epst), 2) + 0.6e19*Power((*epst), 3))) / 24e0;
				v023 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*(*epst) + 0.17999982e20*Power((*epst), 2)
					+ 0.6e19*Power((*epst), 3));
				v024 = 0.1e13*(7999997e0 - 0.5999994e13*(*epst) - 0.3e13*Power((*epst), 2));
			};
			v[380] = sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318]));
			if (v[380] > 0.1e-5) { v025 = 1e0 / v[380]; v026 = (-(v025 / v[380])); v027 = (2e0*v025) / Power(v[380], 2); }
			else {
				v025 = (24000000e0 - (-1e0 + 1000000e0*v[380])*(71999994e0 - 0.71999982e14*v[380] + 0.6e19*Power(v[380], 3)
					+ 0.23999982e20*(v[380] * v[380]))) / 24e0;
				v026 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[380] + 0.6e19*Power(v[380], 3) + 0.17999982e20*
					(v[380] * v[380]));
				v027 = 0.1e13*(7999997e0 - 0.5999994e13*v[380] - 0.3e13*(v[380] * v[380]));
			};
			v[386] = -((*mud)*v022*v025*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315])));
			v[356] = v[268] + v[316] * v[386];
			v[358] = v[272] + v[317] * v[386];
			v[359] = v[273] + v[318] * v[386];
		}
		else {
			v[356] = 0e0;
			v[358] = 0e0;
			v[359] = 0e0;
		};
	};
	v[471] = v[315] + v[330];
	v[470] = v[314] + v[329];
	v[469] = v[313] + v[328];
	fn[0] = v[313];
	fn[1] = v[314];
	fn[2] = v[315];
	ft[0] = v[328];
	ft[1] = v[329];
	ft[2] = v[330];
	(*stickupdated) = v[331];
	gtpupdated[0] = v[268] - v[356];
	gtpupdated[1] = v[272] - v[358];
	gtpupdated[2] = v[273] - v[359];
	Rc[0] = v[128] * v[469] + v[134] * v[470] + v[140] * v[471];
	Rc[1] = v[132] * v[469] + v[138] * v[470] + v[144] * v[471];
	Rc[2] = v[133] * v[469] + v[139] * v[470] + v[145] * v[471];
	Rc[3] = (-(GAp[2] * v[132]) + GAp[1] * v[133])*v[469] + (-(GAp[2] * v[138]) + GAp[1] * v[139])*v[470] + (-
		(GAp[2] * v[144]) + GAp[1] * v[145])*v[471];
	Rc[4] = (GAp[2] * v[128] - GAp[0] * v[133])*v[469] + (GAp[2] * v[134] - GAp[0] * v[139])*v[470] + (GAp[2] * v[140]
		- GAp[0] * v[145])*v[471];
	Rc[5] = (-(GAp[1] * v[128]) + GAp[0] * v[132])*v[469] + (-(GAp[1] * v[134]) + GAp[0] * v[138])*v[470] + (-
		(GAp[1] * v[140]) + GAp[0] * v[144])*v[471];
	Rc[6] = -(v[177] * v[469]) - v[183] * v[470] - v[189] * v[471];
	Rc[7] = -(v[181] * v[469]) - v[187] * v[470] - v[193] * v[471];
	Rc[8] = -(v[182] * v[469]) - v[188] * v[470] - v[194] * v[471];
	Rc[9] = -((-(GBp[2] * v[181]) + GBp[1] * v[182])*v[469]) - (-(GBp[2] * v[187]) + GBp[1] * v[188])*v[470] - (-
		(GBp[2] * v[193]) + GBp[1] * v[194])*v[471];
	Rc[10] = -((GBp[2] * v[177] - GBp[0] * v[182])*v[469]) - (GBp[2] * v[183] - GBp[0] * v[188])*v[470] - (GBp[2] * v[189]
		- GBp[0] * v[194])*v[471];
	Rc[11] = -((-(GBp[1] * v[177]) + GBp[0] * v[181])*v[469]) - (-(GBp[1] * v[183]) + GBp[0] * v[187])*v[470] - (-
		(GBp[1] * v[189]) + GBp[0] * v[193])*v[471];
	
	/*db.myprintf("Time: %.6e\n", (db.last_converged_time + db.current_time_step));
	db.myprintf("gti: %.e %.6e %.6e\n", ft[0], ft[1], ft[2]);
	db.myprintf("gtupdaded: %.6e %.6e %.6e\n", gtpupdated[0], gtpupdated[1], gtpupdated[2]);*/
	
	delete[]v;
}

void RigidNURBSSurface_RigidNURBSSurface::SetVariablesExplicit(double t)
{
	for (int i = 0; i < 3; i++)
	{
		xAi[i] = db.nodes[node_A - 1]->copy_coordinates[i];
		xBi[i] = db.nodes[node_B - 1]->copy_coordinates[i];

		uA[i] = (*db.nodes[node_A - 1]->u)(i, 0);
		uB[i] = (*db.nodes[node_B - 1]->u)(i, 0);

		alphaA[i] = (*db.nodes[node_A - 1]->alpha)(i, 0);
		alphaB[i] = (*db.nodes[node_B - 1]->alpha)(i, 0);

		duiA[i] = (*db.nodes[node_A - 1]->du)(i, 0);
		duiB[i] = (*db.nodes[node_B - 1]->du)(i, 0);

		dalphaiA[i] = (*db.nodes[node_A - 1]->omega)(i, 0);
		dalphaiB[i] = (*db.nodes[node_B - 1]->omega)(i, 0);


		for (int j = 0; j < 3; j++)
		{
			QAi[i][j] = (*db.nodes[node_A - 1]->Q)(i, j);
			QBi[i][j] = (*db.nodes[node_B - 1]->Q)(i, j);
		}

		for (int j = 0; j < 3; j++)
		{
			Q0A[i][j] = (*ptrQ0A)(i, j);
			Q0B[i][j] = (*ptrQ0B)(i, j);
		}
	}
}

void RigidNURBSSurface_RigidNURBSSurface::FinalUpdateExplicit(double t)
{
	cAp[0] = cd->convective[0][0];
	cAp[1] = cd->convective[0][1];
	cBp[0] = cd->convective[0][2];
	cBp[1] = cd->convective[0][3];

	Matrix p(4);
	p(0, 0) = cAp[0];
	p(1, 0) = cAp[1];
	p(2, 0) = cBp[0];
	p(3, 0) = cBp[1];

	Matrix patch_p(2);
	patch_p(0, 0) = cd->patchA[0];
	patch_p(1, 0) = cd->patchB[0];

	bool previouscontact = prev_eligible;

	// Verificar se previouscontact é falso
		// Opção a: não havia contato prévio entre as partículas e, portanto, o gti deve ser 0 e o previouscontact deve ser 'false'
		// Opção b: houve mudança de patch e, portanto, o gti deve ser o do patch vizinho que havia contato r o previous contact deve ser 'true'

	Matrix i(4);
	Matrix patch_i(2);

	cAi[0] = cd->copy_convective[0][0];
	cAi[1] = cd->copy_convective[0][1];
	cBi[0] = cd->copy_convective[0][2];
	cBi[1] = cd->copy_convective[0][3];

	i(0, 0) = cAi[0];
	i(1, 0) = cAi[1];
	i(2, 0) = cBi[0];
	i(3, 0) = cBi[1];

	patch_i(0, 0) = cd->copy_patchA[0];
	patch_i(1, 0) = cd->copy_patchB[0];

	if (previouscontact == false) {
		for (int cont = 0; cont < db.gcs->contactPP_list[index1].size(); cont++)
		{
			if ((db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->prev_eligible == true) && (db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->eligible == false) && (db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->index2 == index2))
			{
				gti[0] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[0];
				gti[1] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[1];
				gti[2] = static_cast<RigidNURBSSurface_RigidNURBSSurface*>(db.gcs->contactPP_list[index1][cont]->contact_pairs[0])->gti[2];
				previouscontact = true;

				cAi[0] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][0];
				cAi[1] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][1];
				cBi[0] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][2];
				cBi[1] = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_convective[0][3];

				i(0, 0) = cAi[0];
				i(1, 0) = cAi[1];
				i(2, 0) = cBi[0];
				i(3, 0) = cBi[1];

				patch_i(0, 0) = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_patchA[0];
				patch_i(1, 0) = db.gcs->contactPP_list[index1][cont]->contact_pairs[0]->cd->copy_patchB[0];
			}
			else
			{

			}
		}
	}

	// Verificar se previouscontact é falso, o que indica que houve mudança de patch (se gira e deixa de ser contato e depois volta, o previouscontact é coerente?)
	// Analisar para as particulas se tinha algum contato anterior no passo anterior (como?)
	// Se sim, pegar informações pertinentes CAi,gti, ni

	/*if (index1 == 0) {
		cout << "InvH" << endl;
		cout << invH[0][0] << " " << invH[0][1] << " " << invH[0][2] << endl;
		cout << invH[1][0] << " " << invH[1][1] << " " << invH[1][2] << endl;
		cout << invH[2][0] << " " << invH[2][1] << " " << invH[2][2] << endl;
		cout << endl;
		cout << cAi[0] << " " << cAi[1] << endl;
		cout << endl;
	}*/

	v = DBG_NEW double[5800];

	double value = 0.0;
	//Zerando matrizes e vetores
	for (int i = 0; i < 12; i++)
	{
		Rc[i] = 0.0;
		for (int j = 0; j < 12; j++)
			Kc[i][j] = 0.0;
	}

	EvaluateNURBSDerivatives_p(p, patch_p);
	EvaluateNURBSDerivatives_i(i, patch_i);
	//EvaluateNURBSDOFsVariables();

	//Avalia contribuições de contato

#pragma region AceGen
	double v01; double v010; double v011; double v012; double v013; double v014;
	double v015; double v016; double v017; double v018; double v019; double v02;
	double v020; double v021; double v022; double v023; double v024; double v025;
	double v026; double v027; double v03; double v04; double v05; double v06; double v07;
	double v08; double v09;
	int b235, b267, b309, b325, b327, b343, b361, b373;
	v[131] = Q0A[0][0] * QAi[0][2] + Q0A[0][1] * QAi[1][2] + Q0A[0][2] * QAi[2][2];
	v[130] = Q0A[0][0] * QAi[0][1] + Q0A[0][1] * QAi[1][1] + Q0A[0][2] * QAi[2][1];
	v[129] = Q0A[0][0] * QAi[0][0] + Q0A[0][1] * QAi[1][0] + Q0A[0][2] * QAi[2][0];
	v[137] = Q0A[1][0] * QAi[0][2] + Q0A[1][1] * QAi[1][2] + Q0A[1][2] * QAi[2][2];
	v[136] = Q0A[1][0] * QAi[0][1] + Q0A[1][1] * QAi[1][1] + Q0A[1][2] * QAi[2][1];
	v[135] = Q0A[1][0] * QAi[0][0] + Q0A[1][1] * QAi[1][0] + Q0A[1][2] * QAi[2][0];
	v[143] = Q0A[2][0] * QAi[0][2] + Q0A[2][1] * QAi[1][2] + Q0A[2][2] * QAi[2][2];
	v[142] = Q0A[2][0] * QAi[0][1] + Q0A[2][1] * QAi[1][1] + Q0A[2][2] * QAi[2][1];
	v[141] = Q0A[2][0] * QAi[0][0] + Q0A[2][1] * QAi[1][0] + Q0A[2][2] * QAi[2][0];
	v[117] = Power(alphaA[0], 2);
	v[115] = (alphaA[0] * alphaA[1]) / 2e0;
	v[110] = Power(alphaA[1], 2);
	v[122] = (alphaA[1] * alphaA[2]) / 2e0;
	v[120] = (alphaA[0] * alphaA[2]) / 2e0;
	v[111] = Power(alphaA[2], 2);
	v[449] = v[110] + v[111];
	v[180] = Q0B[0][0] * QBi[0][2] + Q0B[0][1] * QBi[1][2] + Q0B[0][2] * QBi[2][2];
	v[179] = Q0B[0][0] * QBi[0][1] + Q0B[0][1] * QBi[1][1] + Q0B[0][2] * QBi[2][1];
	v[178] = Q0B[0][0] * QBi[0][0] + Q0B[0][1] * QBi[1][0] + Q0B[0][2] * QBi[2][0];
	v[186] = Q0B[1][0] * QBi[0][2] + Q0B[1][1] * QBi[1][2] + Q0B[1][2] * QBi[2][2];
	v[185] = Q0B[1][0] * QBi[0][1] + Q0B[1][1] * QBi[1][1] + Q0B[1][2] * QBi[2][1];
	v[184] = Q0B[1][0] * QBi[0][0] + Q0B[1][1] * QBi[1][0] + Q0B[1][2] * QBi[2][0];
	v[192] = Q0B[2][0] * QBi[0][2] + Q0B[2][1] * QBi[1][2] + Q0B[2][2] * QBi[2][2];
	v[191] = Q0B[2][0] * QBi[0][1] + Q0B[2][1] * QBi[1][1] + Q0B[2][2] * QBi[2][1];
	v[190] = Q0B[2][0] * QBi[0][0] + Q0B[2][1] * QBi[1][0] + Q0B[2][2] * QBi[2][0];
	v[166] = Power(alphaB[0], 2);
	v[164] = (alphaB[0] * alphaB[1]) / 2e0;
	v[159] = Power(alphaB[1], 2);
	v[171] = (alphaB[1] * alphaB[2]) / 2e0;
	v[169] = (alphaB[0] * alphaB[2]) / 2e0;
	v[160] = Power(alphaB[2], 2);
	v[450] = v[159] + v[160];
	v[109] = 4e0 / (4e0 + v[117] + v[449]);
	v[112] = 1e0 - (v[109] * v[449]) / 2e0;
	v[113] = v[109] * (-alphaA[2] + v[115]);
	v[114] = v[109] * (alphaA[1] + v[120]);
	v[116] = v[109] * (alphaA[2] + v[115]);
	v[118] = 1e0 - (v[109] * (v[111] + v[117])) / 2e0;
	v[119] = v[109] * (-alphaA[0] + v[122]);
	v[121] = v[109] * (-alphaA[1] + v[120]);
	v[123] = v[109] * (alphaA[0] + v[122]);
	v[124] = 1e0 - (v[109] * (v[110] + v[117])) / 2e0;
	v[125] = -(alphaA[2] * v[109]) / 2e0;
	v[126] = (alphaA[1] * v[109]) / 2e0;
	v[127] = -(alphaA[0] * v[109]) / 2e0;
	v[128] = v[112] * v[129] + v[116] * v[130] + v[121] * v[131];
	v[132] = v[113] * v[129] + v[118] * v[130] + v[123] * v[131];
	v[133] = v[114] * v[129] + v[119] * v[130] + v[124] * v[131];
	v[134] = v[112] * v[135] + v[116] * v[136] + v[121] * v[137];
	v[138] = v[113] * v[135] + v[118] * v[136] + v[123] * v[137];
	v[139] = v[114] * v[135] + v[119] * v[136] + v[124] * v[137];
	v[140] = v[112] * v[141] + v[116] * v[142] + v[121] * v[143];
	v[144] = v[113] * v[141] + v[118] * v[142] + v[123] * v[143];
	v[145] = v[114] * v[141] + v[119] * v[142] + v[124] * v[143];
	v[158] = 4e0 / (4e0 + v[166] + v[450]);
	v[161] = 1e0 - (v[158] * v[450]) / 2e0;
	v[162] = v[158] * (-alphaB[2] + v[164]);
	v[163] = v[158] * (alphaB[1] + v[169]);
	v[165] = v[158] * (alphaB[2] + v[164]);
	v[167] = 1e0 - (v[158] * (v[160] + v[166])) / 2e0;
	v[168] = v[158] * (-alphaB[0] + v[171]);
	v[170] = v[158] * (-alphaB[1] + v[169]);
	v[172] = v[158] * (alphaB[0] + v[171]);
	v[173] = 1e0 - (v[158] * (v[159] + v[166])) / 2e0;
	v[174] = -(alphaB[2] * v[158]) / 2e0;
	v[175] = (alphaB[1] * v[158]) / 2e0;
	v[176] = -(alphaB[0] * v[158]) / 2e0;
	v[177] = v[161] * v[178] + v[165] * v[179] + v[170] * v[180];
	v[181] = v[162] * v[178] + v[167] * v[179] + v[172] * v[180];
	v[182] = v[163] * v[178] + v[168] * v[179] + v[173] * v[180];
	v[183] = v[161] * v[184] + v[165] * v[185] + v[170] * v[186];
	v[187] = v[162] * v[184] + v[167] * v[185] + v[172] * v[186];
	v[188] = v[163] * v[184] + v[168] * v[185] + v[173] * v[186];
	v[189] = v[161] * v[190] + v[165] * v[191] + v[170] * v[192];
	v[193] = v[162] * v[190] + v[167] * v[191] + v[172] * v[192];
	v[194] = v[163] * v[190] + v[168] * v[191] + v[173] * v[192];
	v[455] = uA[0] - uB[0] + xAi[0] - xBi[0];
	v[454] = uA[1] - uB[1] + xAi[1] - xBi[1];
	v[453] = uA[2] - uB[2] + xAi[2] - xBi[2];
	v[207] = GAp[0] * v[128] + GAp[1] * v[132] + GAp[2] * v[133] - GBp[0] * v[177] - GBp[1] * v[181] - GBp[2] * v[182] + v[455];
	v[208] = GAp[0] * v[134] + GAp[1] * v[138] + GAp[2] * v[139] - GBp[0] * v[183] - GBp[1] * v[187] - GBp[2] * v[188] + v[454];
	v[209] = GAp[0] * v[140] + GAp[1] * v[144] + GAp[2] * v[145] - GBp[0] * v[189] - GBp[1] * v[193] - GBp[2] * v[194] + v[453];
	v[210] = GAi[0] * v[129] + GAi[1] * v[130] + GAi[2] * v[131] - GBi[0] * v[178] - GBi[1] * v[179] - GBi[2] * v[180] + xAi[0]
		- xBi[0];
	v[211] = GAi[0] * v[135] + GAi[1] * v[136] + GAi[2] * v[137] - GBi[0] * v[184] - GBi[1] * v[185] - GBi[2] * v[186] + xAi[1]
		- xBi[1];
	v[212] = GAi[0] * v[141] + GAi[1] * v[142] + GAi[2] * v[143] - GBi[0] * v[190] - GBi[1] * v[191] - GBi[2] * v[192] + xAi[2]
		- xBi[2];
	v[216] = sqrt((v[207] * v[207]) + (v[208] * v[208]) + (v[209] * v[209]));
	if (v[216] > 0.1e-7) { v01 = 1e0 / v[216]; v02 = (-(v01 / v[216])); v03 = (2e0*v01) / Power(v[216], 2); }
	else {
		v01 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[216])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[216])*(0.2399999997e10
			- 0.1199999994e18*v[216] - 0.3e17*(v[216] * v[216]))));
		v02 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[216] + 0.6e25*Power(v[216], 3)
			+ 0.1799999982e26*(v[216] * v[216]));
		v03 = 0.1e17*(799999997e0 - 0.599999994e17*v[216] - 0.3e17*(v[216] * v[216]));
	};
	v[221] = v01;
	v[222] = v[207] * v[221];
	v[462] = (v[222] * v[222]);
	v[290] = 1e0 - v[462];
	v[223] = v[208] * v[221];
	v[463] = (v[223] * v[223]);
	v[295] = 1e0 - v[463];
	v[224] = v[209] * v[221];
	v[464] = (v[224] * v[224]);
	v[300] = 1e0 - v[464];
	v[225] = sqrt((v[210] * v[210]) + (v[211] * v[211]) + (v[212] * v[212]));
	if (v[225] > 0.1e-7) { v04 = 1e0 / v[225]; v05 = (-(v04 / v[225])); v06 = (2e0*v04) / Power(v[225], 2); }
	else {
		v04 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[225])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[225])*(0.2399999997e10
			- 0.1199999994e18*v[225] - 0.3e17*(v[225] * v[225]))));
		v05 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[225] + 0.6e25*Power(v[225], 3)
			+ 0.1799999982e26*(v[225] * v[225]));
		v06 = 0.1e17*(799999997e0 - 0.599999994e17*v[225] - 0.3e17*(v[225] * v[225]));
	};
	v[230] = v04;
	v[231] = v[210] * v[230];
	v[232] = v[211] * v[230];
	v[233] = v[212] * v[230];
	if (sqrt(Power(v[223] * v[231] - v[222] * v[232], 2) + Power(-(v[224] * v[231]) + v[222] * v[233], 2) + Power
	(v[224] * v[232] - v[223] * v[233], 2)) > 0.1e-7) {
		v[236] = v[224] * v[232] - v[223] * v[233];
		v[237] = -(v[224] * v[231]) + v[222] * v[233];
		v[238] = v[223] * v[231] - v[222] * v[232];
		v[239] = sqrt((v[236] * v[236]) + (v[237] * v[237]) + (v[238] * v[238]));
		if (v[239] > 0.1e-7) { v07 = 1e0 / v[239]; v08 = (-(v07 / v[239])); v09 = (2e0*v07) / Power(v[239], 2); }
		else {
			v07 = (12500000e0 / 3e0)*(24e0 - (-0.1e-7 + v[239])*(0.24e10 - 2e0*(-1e0 + 100000000e0*v[239])*
				(0.2399999997e10 - 0.1199999994e18*v[239] - 0.3e17*(v[239] * v[239]))));
			v08 = (-50000000e0 / 3e0)*(0.3599999994e10 - 0.4799999982e18*v[239] + 0.6e25*Power(v[239], 3)
				+ 0.1799999982e26*(v[239] * v[239]));
			v09 = 0.1e17*(799999997e0 - 0.599999994e17*v[239] - 0.3e17*(v[239] * v[239]));
		};
		v[451] = 2e0*v07*tan(asin(v[239]) / 2e0);
		v[248] = v[236] * v[451];
		v[259] = (v[248] * v[248]);
		v[249] = v[237] * v[451];
		v[257] = (v[248] * v[249]) / 2e0;
		v[252] = (v[249] * v[249]);
		v[250] = v[238] * v[451];
		v[264] = (v[249] * v[250]) / 2e0;
		v[262] = (v[248] * v[250]) / 2e0;
		v[253] = (v[250] * v[250]);
		v[452] = v[252] + v[253];
		v[251] = 4e0 / (4e0 + v[259] + v[452]);
		v[254] = 1e0 - (v[251] * v[452]) / 2e0;
		v[255] = v[251] * (-v[250] + v[257]);
		v[256] = v[251] * (v[249] + v[262]);
		v[258] = v[251] * (v[250] + v[257]);
		v[260] = 1e0 - (v[251] * (v[253] + v[259])) / 2e0;
		v[261] = v[251] * (-v[248] + v[264]);
		v[263] = v[251] * (-v[249] + v[262]);
		v[265] = v[251] * (v[248] + v[264]);
		v[266] = 1e0 - (v[251] * (v[252] + v[259])) / 2e0;
	}
	else {
		v[254] = 1e0;
		v[255] = 0e0;
		v[256] = 0e0;
		v[258] = 0e0;
		v[260] = 1e0;
		v[261] = 0e0;
		v[263] = 0e0;
		v[265] = 0e0;
		v[266] = 1e0;
	};
	if ((previouscontact)) {
		v[271] = GAi[0] * v[140] + GAi[1] * v[144] + GAi[2] * v[145] - GBi[0] * v[189] - GBi[1] * v[193] - GBi[2] * v[194]
			+ gti[0] * v[263] + gti[1] * v[265] + gti[2] * v[266] + v[453];
		v[456] = v[224] * v[271];
		v[270] = GAi[0] * v[134] + GAi[1] * v[138] + GAi[2] * v[139] - GBi[0] * v[183] - GBi[1] * v[187] - GBi[2] * v[188]
			+ gti[0] * v[258] + gti[1] * v[260] + gti[2] * v[261] + v[454];
		v[458] = v[223] * v[270];
		v[269] = GAi[0] * v[128] + GAi[1] * v[132] + GAi[2] * v[133] - GBi[0] * v[177] - GBi[1] * v[181] - GBi[2] * v[182]
			+ gti[0] * v[254] + gti[1] * v[255] + gti[2] * v[256] + v[455];
		v[457] = -(v[222] * v[269]);
		v[268] = v[269] * v[290] - v[222] * (v[456] + v[458]);
		v[272] = v[270] * v[295] + v[223] * (-v[456] + v[457]);
		v[273] = v[271] * v[300] + v[224] * (v[457] - v[458]);
	}
	else {
		v[268] = 0e0;
		v[272] = 0e0;
		v[273] = 0e0;
	};
	v[274] = dalphaiA[0] * v[109] + dalphaiA[1] * v[125] + dalphaiA[2] * v[126];
	v[275] = dalphaiA[1] * v[109] - dalphaiA[0] * v[125] + dalphaiA[2] * v[127];
	v[276] = dalphaiA[2] * v[109] - dalphaiA[0] * v[126] - dalphaiA[1] * v[127];
	v[277] = dalphaiB[0] * v[158] + dalphaiB[1] * v[174] + dalphaiB[2] * v[175];
	v[278] = dalphaiB[1] * v[158] - dalphaiB[0] * v[174] + dalphaiB[2] * v[176];
	v[279] = dalphaiB[2] * v[158] - dalphaiB[0] * v[175] - dalphaiB[1] * v[176];
	v[280] = duiA[0] - duiB[0] + GAp[2] * (-(v[132] * v[274]) + v[128] * v[275]) + GAp[1] * (v[133] * v[274] - v[128] * v[276])
		+ GAp[0] * (-(v[133] * v[275]) + v[132] * v[276]) + GBp[2] * (v[181] * v[277] - v[177] * v[278]) - GBp[1] * (v[182] * v[277]
			- v[177] * v[279]) + GBp[0] * (v[182] * v[278] - v[181] * v[279]);
	v[459] = v[222] * v[280];
	v[281] = duiA[1] - duiB[1] + GAp[2] * (-(v[138] * v[274]) + v[134] * v[275]) + GAp[1] * (v[139] * v[274] - v[134] * v[276])
		+ GAp[0] * (-(v[139] * v[275]) + v[138] * v[276]) + GBp[2] * (v[187] * v[277] - v[183] * v[278]) - GBp[1] * (v[188] * v[277]
			- v[183] * v[279]) + GBp[0] * (v[188] * v[278] - v[187] * v[279]);
	v[460] = v[223] * v[281];
	v[466] = v[224] * (v[459] + v[460]);
	v[291] = v[222] * v[460];
	v[282] = duiA[2] - duiB[2] + GAp[2] * (-(v[144] * v[274]) + v[140] * v[275]) + GAp[1] * (v[145] * v[274] - v[140] * v[276])
		+ GAp[0] * (-(v[145] * v[275]) + v[144] * v[276]) + GBp[2] * (v[193] * v[277] - v[189] * v[278]) - GBp[1] * (v[194] * v[277]
			- v[189] * v[279]) + GBp[0] * (v[194] * v[278] - v[193] * v[279]);
	v[461] = v[224] * v[282];
	v[465] = v[223] * (v[459] + v[461]);
	v[292] = v[222] * v[461];
	v[302] = (*epsn)*v[207];
	v[303] = (*epsn)*v[208];
	v[304] = (*epsn)*v[209];
	v[305] = (*cn)*(v[291] + v[292] + v[280] * v[462]);
	v[306] = (*cn)*(v[281] * v[463] + v[465]);
	v[307] = (*cn)*(v[282] * v[464] + v[466]);
	if (v[222] * (v[302] + v[305]) + v[223] * (v[303] + v[306]) + v[224] * (v[304] + v[307]) > 0e0) {
		v[310] = v[305];
		v[311] = v[306];
		v[312] = v[307];
	}
	else {
		v[310] = -v[302];
		v[311] = -v[303];
		v[312] = -v[304];
	};
	v[313] = v[302] + v[310];
	v[314] = v[303] + v[311];
	v[315] = v[304] + v[312];
	v[316] = (*epst)*v[268];
	v[317] = (*epst)*v[272];
	v[318] = (*epst)*v[273];
	v[322] = (*ct)*(v[280] * v[290] - v[291] - v[292]) + v[316];
	v[323] = v[317] - (*ct)*(-(v[281] * v[295]) + v[465]);
	v[324] = v[318] - (*ct)*(-(v[282] * v[300]) + v[466]);
	if ((*stick)) {
		if (sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324])) <= (*mus)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			v[328] = v[322];
			v[329] = v[323];
			v[330] = v[324];
			v[331] = 1e0;
		}
		else {
			v[332] = sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324]));
			if (v[332] > 0.1e-5) { v010 = 1e0 / v[332]; v011 = (-(v010 / v[332])); v012 = (2e0*v010) / Power(v[332], 2); }
			else {
				v010 = (24000000e0 - (-1e0 + 1000000e0*v[332])*(71999994e0 - 0.71999982e14*v[332] + 0.6e19*Power(v[332], 3)
					+ 0.23999982e20*(v[332] * v[332]))) / 24e0;
				v011 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[332] + 0.6e19*Power(v[332], 3) + 0.17999982e20*
					(v[332] * v[332]));
				v012 = 0.1e13*(7999997e0 - 0.5999994e13*v[332] - 0.3e13*(v[332] * v[332]));
			};
			v[467] = (*mud)*v010*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315]));
			v[328] = v[322] * v[467];
			v[329] = v[323] * v[467];
			v[330] = v[324] * v[467];
			v[331] = 0e0;
		};
		if (sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318])) > (*mus)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			if ((*epst) > 0.1e-5) {
				v013 = 1e0 / (*epst); v014 = (-(v013 / (*epst))); v015 = (2e0*v013) / Power((*epst), 2
				);
			}
			else {
				v013 = (24000000e0 - (-1e0 + 1000000e0*(*epst))*(71999994e0 - 0.71999982e14*(*epst) + 0.23999982e20*Power(
					(*epst), 2) + 0.6e19*Power((*epst), 3))) / 24e0;
				v014 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*(*epst) + 0.17999982e20*Power((*epst), 2)
					+ 0.6e19*Power((*epst), 3));
				v015 = 0.1e13*(7999997e0 - 0.5999994e13*(*epst) - 0.3e13*Power((*epst), 2));
			};
			v[350] = sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318]));
			if (v[350] > 0.1e-5) { v016 = 1e0 / v[350]; v017 = (-(v016 / v[350])); v018 = (2e0*v016) / Power(v[350], 2); }
			else {
				v016 = (24000000e0 - (-1e0 + 1000000e0*v[350])*(71999994e0 - 0.71999982e14*v[350] + 0.6e19*Power(v[350], 3)
					+ 0.23999982e20*(v[350] * v[350]))) / 24e0;
				v017 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[350] + 0.6e19*Power(v[350], 3) + 0.17999982e20*
					(v[350] * v[350]));
				v018 = 0.1e13*(7999997e0 - 0.5999994e13*v[350] - 0.3e13*(v[350] * v[350]));
			};
			v[357] = -((*mud)*v013*v016*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315])));
			v[356] = v[268] + v[316] * v[357];
			v[358] = v[272] + v[317] * v[357];
			v[359] = v[273] + v[318] * v[357];
		}
		else {
			v[356] = 0e0;
			v[358] = 0e0;
			v[359] = 0e0;
		};
	}
	else {
		if (sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324])) <= (*mud)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			v[328] = v[322];
			v[329] = v[323];
			v[330] = v[324];
			v[331] = 1e0;
		}
		else {
			v[362] = sqrt((v[322] * v[322]) + (v[323] * v[323]) + (v[324] * v[324]));
			if (v[362] > 0.1e-5) { v019 = 1e0 / v[362]; v020 = (-(v019 / v[362])); v021 = (2e0*v019) / Power(v[362], 2); }
			else {
				v019 = (24000000e0 - (-1e0 + 1000000e0*v[362])*(71999994e0 - 0.71999982e14*v[362] + 0.6e19*Power(v[362], 3)
					+ 0.23999982e20*(v[362] * v[362]))) / 24e0;
				v020 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[362] + 0.6e19*Power(v[362], 3) + 0.17999982e20*
					(v[362] * v[362]));
				v021 = 0.1e13*(7999997e0 - 0.5999994e13*v[362] - 0.3e13*(v[362] * v[362]));
			};
			v[468] = (*mud)*v019*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315]));
			v[328] = v[322] * v[468];
			v[329] = v[323] * v[468];
			v[330] = v[324] * v[468];
			v[331] = 0e0;
		};
		if (sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318])) > (*mud)*sqrt((v[313] * v[313]) +
			(v[314] * v[314]) + (v[315] * v[315]))) {
			if ((*epst) > 0.1e-5) {
				v022 = 1e0 / (*epst); v023 = (-(v022 / (*epst))); v024 = (2e0*v022) / Power((*epst), 2
				);
			}
			else {
				v022 = (24000000e0 - (-1e0 + 1000000e0*(*epst))*(71999994e0 - 0.71999982e14*(*epst) + 0.23999982e20*Power(
					(*epst), 2) + 0.6e19*Power((*epst), 3))) / 24e0;
				v023 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*(*epst) + 0.17999982e20*Power((*epst), 2)
					+ 0.6e19*Power((*epst), 3));
				v024 = 0.1e13*(7999997e0 - 0.5999994e13*(*epst) - 0.3e13*Power((*epst), 2));
			};
			v[380] = sqrt((v[316] * v[316]) + (v[317] * v[317]) + (v[318] * v[318]));
			if (v[380] > 0.1e-5) { v025 = 1e0 / v[380]; v026 = (-(v025 / v[380])); v027 = (2e0*v025) / Power(v[380], 2); }
			else {
				v025 = (24000000e0 - (-1e0 + 1000000e0*v[380])*(71999994e0 - 0.71999982e14*v[380] + 0.6e19*Power(v[380], 3)
					+ 0.23999982e20*(v[380] * v[380]))) / 24e0;
				v026 = (-500000e0 / 3e0)*(35999994e0 - 0.47999982e14*v[380] + 0.6e19*Power(v[380], 3) + 0.17999982e20*
					(v[380] * v[380]));
				v027 = 0.1e13*(7999997e0 - 0.5999994e13*v[380] - 0.3e13*(v[380] * v[380]));
			};
			v[386] = -((*mud)*v022*v025*sqrt((v[313] * v[313]) + (v[314] * v[314]) + (v[315] * v[315])));
			v[356] = v[268] + v[316] * v[386];
			v[358] = v[272] + v[317] * v[386];
			v[359] = v[273] + v[318] * v[386];
		}
		else {
			v[356] = 0e0;
			v[358] = 0e0;
			v[359] = 0e0;
		};
	};
	v[471] = v[315] + v[330];
	v[470] = v[314] + v[329];
	v[469] = v[313] + v[328];
	fn[0] = v[313];
	fn[1] = v[314];
	fn[2] = v[315];
	ft[0] = v[328];
	ft[1] = v[329];
	ft[2] = v[330];
	(*stickupdated) = v[331];
	gtpupdated[0] = v[268] - v[356];
	gtpupdated[1] = v[272] - v[358];
	gtpupdated[2] = v[273] - v[359];
	/*Rc[0] = v[128] * v[469] + v[134] * v[470] + v[140] * v[471];
	Rc[1] = v[132] * v[469] + v[138] * v[470] + v[144] * v[471];
	Rc[2] = v[133] * v[469] + v[139] * v[470] + v[145] * v[471];
	Rc[3] = (-(GAp[2] * v[132]) + GAp[1] * v[133])*v[469] + (-(GAp[2] * v[138]) + GAp[1] * v[139])*v[470] + (-
		(GAp[2] * v[144]) + GAp[1] * v[145])*v[471];
	Rc[4] = (GAp[2] * v[128] - GAp[0] * v[133])*v[469] + (GAp[2] * v[134] - GAp[0] * v[139])*v[470] + (GAp[2] * v[140]
		- GAp[0] * v[145])*v[471];
	Rc[5] = (-(GAp[1] * v[128]) + GAp[0] * v[132])*v[469] + (-(GAp[1] * v[134]) + GAp[0] * v[138])*v[470] + (-
		(GAp[1] * v[140]) + GAp[0] * v[144])*v[471];
	Rc[6] = -(v[177] * v[469]) - v[183] * v[470] - v[189] * v[471];
	Rc[7] = -(v[181] * v[469]) - v[187] * v[470] - v[193] * v[471];
	Rc[8] = -(v[182] * v[469]) - v[188] * v[470] - v[194] * v[471];
	Rc[9] = -((-(GBp[2] * v[181]) + GBp[1] * v[182])*v[469]) - (-(GBp[2] * v[187]) + GBp[1] * v[188])*v[470] - (-
		(GBp[2] * v[193]) + GBp[1] * v[194])*v[471];
	Rc[10] = -((GBp[2] * v[177] - GBp[0] * v[182])*v[469]) - (GBp[2] * v[183] - GBp[0] * v[188])*v[470] - (GBp[2] * v[189]
		- GBp[0] * v[194])*v[471];
	Rc[11] = -((-(GBp[1] * v[177]) + GBp[0] * v[181])*v[469]) - (-(GBp[1] * v[183]) + GBp[0] * v[187])*v[470] - (-
		(GBp[1] * v[189]) + GBp[0] * v[193])*v[471];*/

	delete[]v;
}

void RigidNURBSSurface_RigidNURBSSurface::AllocSpecific()
{
	if (alloc_specific_control == false)
	{
		alloc_specific_control = true;
	}
}

void RigidNURBSSurface_RigidNURBSSurface::FreeSpecific()
{
	if (alloc_specific_control == true)
	{
		alloc_specific_control = false;
	}
}


void RigidNURBSSurface_RigidNURBSSurface::DefaultValues()
{
	//Tolerance for precision of convective coordinates
	tol_convective = 1e-12;
	//Tolerance for precision of a small number (machine precision related)
	tol_small_1 = 1e-12;
	//Tolerance for precision of eigenvalues extraction
	tol_eig = 1e-14;
	//Factor to be used to modify the TR Dogleg Path when ascending directions are found
	tol_ascent = 1e-4;
	//Maximum iterations for searching minimum points
	max_it_1 = 50;
	//Maximum iterations for searching saddle points
	max_it_2 = 50;
	//Flag to write convergence report for LCP's
	//write_report = false;
	//Percentage of extension on the range of validity of convective coordinates to consider a possible solution of LCP still as "strong"
	perc = 0.5;

	convective_range = Matrix(4);
	convective_max = Matrix(4);
	convective_min = Matrix(4);

	seq_number = 0;

	alloc_control = false;
}

void RigidNURBSSurface_RigidNURBSSurface::InitialGuess(SSContactData * c_data)
{
	cd->convective[0][0] = (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][0] + surfA->patches[patchA]->parameter_sub[subA_u][subA_v][1]) / 2;
	cd->convective[0][1] = (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][3] + surfA->patches[patchA]->parameter_sub[subA_u][subA_v][4]) / 2;
	cd->convective[0][2] = (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][0] + surfB->patches[patchB]->parameter_sub[subB_u][subB_v][1]) / 2;
	cd->convective[0][3] = (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][3] + surfB->patches[patchB]->parameter_sub[subB_u][subB_v][4]) / 2;

	cd->patchA[0] = patchA;
	cd->patchB[0] = patchB;

	/*
	for (int ip = 1; ip < c_data->n_solutions; ip++)
	{
		//Preenchendo as coordenadas convectivas:
		c_data->patchA[ip] = c_data->patchA[0];
		c_data->patchB[ip] = c_data->patchB[0];
		c_data->convective[ip][0] = c_data->convective[0][0];
		c_data->convective[ip][1] = c_data->convective[0][1];
		c_data->convective[ip][2] = c_data->convective[0][2];
		c_data->convective[ip][3] = c_data->convective[0][3];
	}
	*/
}

int RigidNURBSSurface_RigidNURBSSurface::CharacterizeCriticalPoint(Matrix * solution, Matrix & patch)
{

	//0 - mínimo estrito
	//1 - mínimo não estrito (intersecção)
	//2 - transição mínimo-sela (just-touch)
	//3 - saddle 2 negative eigenvalues
	//4 - other
	Matrix xk(4);
	Matrix Gra(4);
	Matrix Hes(4, 4);
	Matrix P(4, 4);
	Matrix D(4, 4);
	for (int i = 0; i < 4; i++)
		xk(i, 0) = (*solution)(i, 0);
	double ob = ObjectivePhase1(xk, patch);
	//Hessiana da função objetivo
	HessianPhase1(xk, patch, Hes);
	//Calculando direções principais e curvaturas principais da função objetivo
	fulleigen1(Hes, P, D, tol_eig);

	double max_eig = -1e100;
	for (int i = 0; i < 4; i++)
	{
		if (D(i, i) > max_eig)
			max_eig = D(i, i);
	}
	double tol_intersect = max_eig * tol_convective*tol_convective;
	double tol_small = max_eig * tol_small_1;

	//mínimo não estrito (intersecção)

	if (ob < tol_intersect)
	{
		//if (write_report)
			//fprintf(f_TR_report[seq_number], "Intersection found (tolerance %.6e). Eigenvalues are %.6e\t%.6e\t%.6e\t%.6e\n", tol_intersect, D(0, 0), D(1, 1), D(2, 2), D(3, 3));
		return 1;
	}
	//mínimo estrito
	if (D(0, 0) >= tol_small && D(1, 1) >= tol_small && D(2, 2) >= tol_small && D(3, 3) >= tol_small)
	{
		//if (write_report)
			//fprintf(f_TR_report[seq_number], "Strict minimum found. Eigenvalues are %.6e\t%.6e\t%.6e\t%.6e\n", D(0, 0), D(1, 1), D(2, 2), D(3, 3));
		return 0;
	}
	////transição mínimo-sela (just-touch)
	//if (D(0, 0) >= -tol_small && D(0, 0) <= +tol_small && D(1, 1) >= -tol_small && D(1, 1) <= +tol_small && D(2, 2) >= tol_small && D(3, 3) >= tol_small)
	//{
	//	if (write_report)
	//		fprintf(f_TR_report, "Just-touch found. Eigenvalues are %.6e\t%.6e\t%.6e\t%.6e\n", D(0, 0), D(1, 1), D(2, 2), D(3, 3));
	//	return 2;
	//}
	//transição mínimo-sela (just-touch)
	if (D(0, 0) <= tol_small && D(1, 1) <= tol_small && D(2, 2) >= tol_small && D(3, 3) >= tol_small)
	{
		//if (write_report)
			//fprintf(f_TR_report[seq_number], "Saddle found. Eigenvalues are %.6e\t%.6e\t%.6e\t%.6e\n", D(0, 0), D(1, 1), D(2, 2), D(3, 3));
		return 3;
	}
	//if (write_report)
		//fprintf(f_TR_report[seq_number], "Other critical point found. Eigenvalues are %.6e\t%.6e\t%.6e\t%.6e. Tolerance is %.6e.\n", D(0, 0), D(1, 1), D(2, 2), D(3, 3), tol_small);
	return 4;
}

int RigidNURBSSurface_RigidNURBSSurface::CharacterizeCriticalPointDegenerated(Matrix * solution, Matrix & patch)
{
	int order = cd->P_0[0]->getColumns();

	//0 - mínimo estrito
	//1 - mínimo não estrito (intersecção)
	//2 - transição mínimo-sela (just-touch) X
	//3 - saddle 2 negative eigenvalues X
	//4 - other
	Matrix xk(4);
	Matrix Hes(4, 4);
	Matrix dHes(order, order);
	Matrix P(order, order);
	Matrix D(order, order);
	for (int i = 0; i < 4; i++)
		xk(i, 0) = (*solution)(i, 0);
	double ob = ObjectivePhase1(xk, patch);
	//Hessiana da função objetivo
	HessianPhase1(xk, patch, Hes);
	dHes = transp(*cd->P_0[0])*Hes*(*cd->P_0[0]);
	fulleigen1(dHes, P, D, tol_eig);
	/*if (print)
	{
		if (dHes.getLines() == 3)
			db.myprintf("CharacterizeCriticalPointDegenerated:\nEingenvalues are %.6e  %.6e  %.6e\n", D(0, 0), D(1, 1), D(2, 2));
		if (dHes.getLines() == 2)
			db.myprintf("CharacterizeCriticalPointDegenerated:\nEingenvalues are %.6e  %.6e\n", D(0, 0), D(1, 1));
	}*/

	double max_eig = -1e100;
	for (int i = 0; i < order; i++)
	{
		if (D(i, i) > max_eig)
			max_eig = D(i, i);
	}
	double tol_intersect = max_eig * tol_convective*tol_convective;
	double tol_small = max_eig * tol_small_1;

	//mínimo não estrito (intersecção)
	if (ob < tol_intersect)
	{
		//if (write_report)
			//fprintf(f_TR_report[seq_number], "Intersection found. Eigenvalues are %.6e\t%.6e\t%.6e\n", D(0, 0), D(1, 1), D(2, 2));
		return 1;
	}
	//mínimo estrito
	for (int i = 0; i < order; i++)
	{
		if (D(i, i) <= tol_small) {
			break;
		}
		if (i == order - 1) {
			return 0;
		}
	}

	return 4;
}

double RigidNURBSSurface_RigidNURBSSurface::ObjectivePhase1(Matrix & mc, Matrix & patch)
{
	//AceGen variables or pointers
	double v[2000];
	EvaluateNURBSDerivatives_p(mc, patch);
	EvaluateNURBSDOFsVariables();

	double Ob;

	v[172] = Power(alphaA[0], 2);
	v[170] = 0.5e0*alphaA[0] * alphaA[1];
	v[165] = Power(alphaA[1], 2);
	v[177] = 0.5e0*alphaA[1] * alphaA[2];
	v[175] = 0.5e0*alphaA[0] * alphaA[2];
	v[166] = Power(alphaA[2], 2);
	v[774] = v[165] + v[166];
	v[188] = Power(alphaB[0], 2);
	v[186] = 0.5e0*alphaB[0] * alphaB[1];
	v[181] = Power(alphaB[1], 2);
	v[193] = 0.5e0*alphaB[1] * alphaB[2];
	v[191] = 0.5e0*alphaB[0] * alphaB[2];
	v[182] = Power(alphaB[2], 2);
	v[775] = v[181] + v[182];
	v[164] = 4e0 / (4e0 + v[172] + v[774]);
	v[167] = 1e0 - 0.5e0*v[164] * v[774];
	v[168] = v[164] * (-alphaA[2] + v[170]);
	v[169] = v[164] * (alphaA[1] + v[175]);
	v[171] = v[164] * (alphaA[2] + v[170]);
	v[173] = 1e0 - 0.5e0*v[164] * (v[166] + v[172]);
	v[174] = v[164] * (-alphaA[0] + v[177]);
	v[176] = v[164] * (-alphaA[1] + v[175]);
	v[178] = v[164] * (alphaA[0] + v[177]);
	v[179] = 1e0 - 0.5e0*v[164] * (v[165] + v[172]);
	v[180] = 4e0 / (4e0 + v[188] + v[775]);
	v[183] = 1e0 - 0.5e0*v[180] * v[775];
	v[184] = v[180] * (-alphaB[2] + v[186]);
	v[185] = v[180] * (alphaB[1] + v[191]);
	v[187] = v[180] * (alphaB[2] + v[186]);
	v[189] = 1e0 - 0.5e0*v[180] * (v[182] + v[188]);
	v[190] = v[180] * (-alphaB[0] + v[193]);
	v[192] = v[180] * (-alphaB[1] + v[191]);
	v[194] = v[180] * (alphaB[0] + v[193]);
	v[195] = 1e0 - 0.5e0*v[180] * (v[181] + v[188]);
	(Ob) = 0.5e0*(Power(uA[0] - uB[0] + GAp[0] * (QAi[0][0] * v[167] + QAi[1][0] * v[168] + QAi[2][0] * v[169]) + GAp[1] *
		(QAi[0][1] * v[167] + QAi[1][1] * v[168] + QAi[2][1] * v[169]) + GAp[2] * (QAi[0][2] * v[167] + QAi[1][2] * v[168]
			+ QAi[2][2] * v[169]) - GBp[0] * (QBi[0][0] * v[183] + QBi[1][0] * v[184] + QBi[2][0] * v[185]) - GBp[1] *
			(QBi[0][1] * v[183] + QBi[1][1] * v[184] + QBi[2][1] * v[185]) - GBp[2] * (QBi[0][2] * v[183] + QBi[1][2] * v[184]
				+ QBi[2][2] * v[185]) + xAi[0] - xBi[0], 2) + Power(uA[1] - uB[1] + GAp[0] * (QAi[0][0] * v[171] + QAi[1][0] * v[173]
					+ QAi[2][0] * v[174]) + GAp[1] * (QAi[0][1] * v[171] + QAi[1][1] * v[173] + QAi[2][1] * v[174]) + GAp[2] *
					(QAi[0][2] * v[171] + QAi[1][2] * v[173] + QAi[2][2] * v[174]) - GBp[0] * (QBi[0][0] * v[187] + QBi[1][0] * v[189]
						+ QBi[2][0] * v[190]) - GBp[1] * (QBi[0][1] * v[187] + QBi[1][1] * v[189] + QBi[2][1] * v[190]) - GBp[2] *
						(QBi[0][2] * v[187] + QBi[1][2] * v[189] + QBi[2][2] * v[190]) + xAi[1] - xBi[1], 2) + Power(uA[2] - uB[2] + GAp[0] *
					(QAi[0][0] * v[176] + QAi[1][0] * v[178] + QAi[2][0] * v[179]) + GAp[1] * (QAi[0][1] * v[176] + QAi[1][1] * v[178]
						+ QAi[2][1] * v[179]) + GAp[2] * (QAi[0][2] * v[176] + QAi[1][2] * v[178] + QAi[2][2] * v[179]) - GBp[0] *
						(QBi[0][0] * v[192] + QBi[1][0] * v[194] + QBi[2][0] * v[195]) - GBp[1] * (QBi[0][1] * v[192] + QBi[1][1] * v[194]
							+ QBi[2][1] * v[195]) - GBp[2] * (QBi[0][2] * v[192] + QBi[1][2] * v[194] + QBi[2][2] * v[195]) + xAi[2] - xBi[2], 2));

	return Ob;
}

void RigidNURBSSurface_RigidNURBSSurface::GradientPhase1(Matrix & mc, Matrix & patch, Matrix & mGra)
{
	//AceGen variables or pointers
	double v[2000];
	EvaluateNURBSDerivatives_p(mc, patch);
	EvaluateNURBSDOFsVariables();

	double Gra[4];

	v[172] = Power(alphaA[0], 2);
	v[170] = 0.5e0*alphaA[0] * alphaA[1];
	v[165] = Power(alphaA[1], 2);
	v[177] = 0.5e0*alphaA[1] * alphaA[2];
	v[175] = 0.5e0*alphaA[0] * alphaA[2];
	v[166] = Power(alphaA[2], 2);
	v[774] = v[165] + v[166];
	v[188] = Power(alphaB[0], 2);
	v[186] = 0.5e0*alphaB[0] * alphaB[1];
	v[181] = Power(alphaB[1], 2);
	v[193] = 0.5e0*alphaB[1] * alphaB[2];
	v[191] = 0.5e0*alphaB[0] * alphaB[2];
	v[182] = Power(alphaB[2], 2);
	v[775] = v[181] + v[182];
	v[164] = 4e0 / (4e0 + v[172] + v[774]);
	v[167] = 1e0 - 0.5e0*v[164] * v[774];
	v[168] = v[164] * (-alphaA[2] + v[170]);
	v[169] = v[164] * (alphaA[1] + v[175]);
	v[171] = v[164] * (alphaA[2] + v[170]);
	v[173] = 1e0 - 0.5e0*v[164] * (v[166] + v[172]);
	v[174] = v[164] * (-alphaA[0] + v[177]);
	v[176] = v[164] * (-alphaA[1] + v[175]);
	v[178] = v[164] * (alphaA[0] + v[177]);
	v[179] = 1e0 - 0.5e0*v[164] * (v[165] + v[172]);
	v[180] = 4e0 / (4e0 + v[188] + v[775]);
	v[183] = 1e0 - 0.5e0*v[180] * v[775];
	v[184] = v[180] * (-alphaB[2] + v[186]);
	v[185] = v[180] * (alphaB[1] + v[191]);
	v[187] = v[180] * (alphaB[2] + v[186]);
	v[189] = 1e0 - 0.5e0*v[180] * (v[182] + v[188]);
	v[190] = v[180] * (-alphaB[0] + v[193]);
	v[192] = v[180] * (-alphaB[1] + v[191]);
	v[194] = v[180] * (alphaB[0] + v[193]);
	v[195] = 1e0 - 0.5e0*v[180] * (v[181] + v[188]);
	v[196] = QAi[0][0] * v[167] + QAi[1][0] * v[168] + QAi[2][0] * v[169];
	v[197] = QAi[0][1] * v[167] + QAi[1][1] * v[168] + QAi[2][1] * v[169];
	v[198] = QAi[0][2] * v[167] + QAi[1][2] * v[168] + QAi[2][2] * v[169];
	v[199] = QAi[0][0] * v[171] + QAi[1][0] * v[173] + QAi[2][0] * v[174];
	v[200] = QAi[0][1] * v[171] + QAi[1][1] * v[173] + QAi[2][1] * v[174];
	v[201] = QAi[0][2] * v[171] + QAi[1][2] * v[173] + QAi[2][2] * v[174];
	v[202] = QAi[0][0] * v[176] + QAi[1][0] * v[178] + QAi[2][0] * v[179];
	v[203] = QAi[0][1] * v[176] + QAi[1][1] * v[178] + QAi[2][1] * v[179];
	v[204] = QAi[0][2] * v[176] + QAi[1][2] * v[178] + QAi[2][2] * v[179];
	v[205] = QBi[0][0] * v[183] + QBi[1][0] * v[184] + QBi[2][0] * v[185];
	v[206] = QBi[0][1] * v[183] + QBi[1][1] * v[184] + QBi[2][1] * v[185];
	v[207] = QBi[0][2] * v[183] + QBi[1][2] * v[184] + QBi[2][2] * v[185];
	v[208] = QBi[0][0] * v[187] + QBi[1][0] * v[189] + QBi[2][0] * v[190];
	v[209] = QBi[0][1] * v[187] + QBi[1][1] * v[189] + QBi[2][1] * v[190];
	v[210] = QBi[0][2] * v[187] + QBi[1][2] * v[189] + QBi[2][2] * v[190];
	v[211] = QBi[0][0] * v[192] + QBi[1][0] * v[194] + QBi[2][0] * v[195];
	v[212] = QBi[0][1] * v[192] + QBi[1][1] * v[194] + QBi[2][1] * v[195];
	v[213] = QBi[0][2] * v[192] + QBi[1][2] * v[194] + QBi[2][2] * v[195];
	v[776] = 2e0*(uA[0] - uB[0] + GAp[0] * v[196] + GAp[1] * v[197] + GAp[2] * v[198] - GBp[0] * v[205] - GBp[1] * v[206]
		- GBp[2] * v[207] + xAi[0] - xBi[0]);
	v[777] = 2e0*(uA[1] - uB[1] + GAp[0] * v[199] + GAp[1] * v[200] + GAp[2] * v[201] - GBp[0] * v[208] - GBp[1] * v[209]
		- GBp[2] * v[210] + xAi[1] - xBi[1]);
	v[778] = 2e0*(uA[2] - uB[2] + GAp[0] * v[202] + GAp[1] * v[203] + GAp[2] * v[204] - GBp[0] * v[211] - GBp[1] * v[212]
		- GBp[2] * v[213] + xAi[2] - xBi[2]);
	Gra[0] = 0.5e0*((dGAp[0][0] * v[196] + dGAp[1][0] * v[197] + dGAp[2][0] * v[198])*v[776] + (dGAp[0][0] * v[199]
		+ dGAp[1][0] * v[200] + dGAp[2][0] * v[201])*v[777] + (dGAp[0][0] * v[202] + dGAp[1][0] * v[203] + dGAp[2][0] * v[204]
			)*v[778]);
	Gra[1] = 0.5e0*((dGAp[0][1] * v[196] + dGAp[1][1] * v[197] + dGAp[2][1] * v[198])*v[776] + (dGAp[0][1] * v[199]
		+ dGAp[1][1] * v[200] + dGAp[2][1] * v[201])*v[777] + (dGAp[0][1] * v[202] + dGAp[1][1] * v[203] + dGAp[2][1] * v[204]
			)*v[778]);
	Gra[2] = 0.5e0*((-(dGBp[0][0] * v[205]) - dGBp[1][0] * v[206] - dGBp[2][0] * v[207])*v[776] + (-
		(dGBp[0][0] * v[208]) - dGBp[1][0] * v[209] - dGBp[2][0] * v[210])*v[777] + (-(dGBp[0][0] * v[211])
			- dGBp[1][0] * v[212] - dGBp[2][0] * v[213])*v[778]);
	Gra[3] = 0.5e0*((-(dGBp[0][1] * v[205]) - dGBp[1][1] * v[206] - dGBp[2][1] * v[207])*v[776] + (-
		(dGBp[0][1] * v[208]) - dGBp[1][1] * v[209] - dGBp[2][1] * v[210])*v[777] + (-(dGBp[0][1] * v[211])
			- dGBp[1][1] * v[212] - dGBp[2][1] * v[213])*v[778]);

	for (int i = 0; i < 4; i++)
		mGra(i, 0) = Gra[i];
}

void RigidNURBSSurface_RigidNURBSSurface::HessianPhase1(Matrix & mc, Matrix & patch, Matrix & mHes)
{
	//AceGen variables or pointers
	double v[2000];
	EvaluateNURBSDerivatives_p(mc, patch);
	EvaluateNURBSDOFsVariables();

	double Hes[4][4];

	v[172] = Power(alphaA[0], 2);
	v[170] = 0.5e0*alphaA[0] * alphaA[1];
	v[165] = Power(alphaA[1], 2);
	v[177] = 0.5e0*alphaA[1] * alphaA[2];
	v[175] = 0.5e0*alphaA[0] * alphaA[2];
	v[166] = Power(alphaA[2], 2);
	v[774] = v[165] + v[166];
	v[188] = Power(alphaB[0], 2);
	v[186] = 0.5e0*alphaB[0] * alphaB[1];
	v[181] = Power(alphaB[1], 2);
	v[193] = 0.5e0*alphaB[1] * alphaB[2];
	v[191] = 0.5e0*alphaB[0] * alphaB[2];
	v[182] = Power(alphaB[2], 2);
	v[775] = v[181] + v[182];
	v[164] = 4e0 / (4e0 + v[172] + v[774]);
	v[167] = 1e0 - 0.5e0*v[164] * v[774];
	v[168] = v[164] * (-alphaA[2] + v[170]);
	v[169] = v[164] * (alphaA[1] + v[175]);
	v[171] = v[164] * (alphaA[2] + v[170]);
	v[173] = 1e0 - 0.5e0*v[164] * (v[166] + v[172]);
	v[174] = v[164] * (-alphaA[0] + v[177]);
	v[176] = v[164] * (-alphaA[1] + v[175]);
	v[178] = v[164] * (alphaA[0] + v[177]);
	v[179] = 1e0 - 0.5e0*v[164] * (v[165] + v[172]);
	v[180] = 4e0 / (4e0 + v[188] + v[775]);
	v[183] = 1e0 - 0.5e0*v[180] * v[775];
	v[184] = v[180] * (-alphaB[2] + v[186]);
	v[185] = v[180] * (alphaB[1] + v[191]);
	v[187] = v[180] * (alphaB[2] + v[186]);
	v[189] = 1e0 - 0.5e0*v[180] * (v[182] + v[188]);
	v[190] = v[180] * (-alphaB[0] + v[193]);
	v[192] = v[180] * (-alphaB[1] + v[191]);
	v[194] = v[180] * (alphaB[0] + v[193]);
	v[195] = 1e0 - 0.5e0*v[180] * (v[181] + v[188]);
	v[196] = QAi[0][0] * v[167] + QAi[1][0] * v[168] + QAi[2][0] * v[169];
	v[197] = QAi[0][1] * v[167] + QAi[1][1] * v[168] + QAi[2][1] * v[169];
	v[198] = QAi[0][2] * v[167] + QAi[1][2] * v[168] + QAi[2][2] * v[169];
	v[228] = dGAp[0][1] * v[196] + dGAp[1][1] * v[197] + dGAp[2][1] * v[198];
	v[227] = dGAp[0][0] * v[196] + dGAp[1][0] * v[197] + dGAp[2][0] * v[198];
	v[199] = QAi[0][0] * v[171] + QAi[1][0] * v[173] + QAi[2][0] * v[174];
	v[200] = QAi[0][1] * v[171] + QAi[1][1] * v[173] + QAi[2][1] * v[174];
	v[201] = QAi[0][2] * v[171] + QAi[1][2] * v[173] + QAi[2][2] * v[174];
	v[230] = dGAp[0][1] * v[199] + dGAp[1][1] * v[200] + dGAp[2][1] * v[201];
	v[229] = dGAp[0][0] * v[199] + dGAp[1][0] * v[200] + dGAp[2][0] * v[201];
	v[202] = QAi[0][0] * v[176] + QAi[1][0] * v[178] + QAi[2][0] * v[179];
	v[203] = QAi[0][1] * v[176] + QAi[1][1] * v[178] + QAi[2][1] * v[179];
	v[204] = QAi[0][2] * v[176] + QAi[1][2] * v[178] + QAi[2][2] * v[179];
	v[232] = dGAp[0][1] * v[202] + dGAp[1][1] * v[203] + dGAp[2][1] * v[204];
	v[231] = dGAp[0][0] * v[202] + dGAp[1][0] * v[203] + dGAp[2][0] * v[204];
	v[282] = 2e0*(v[227] * v[228] + v[229] * v[230] + v[231] * v[232]);
	v[205] = QBi[0][0] * v[183] + QBi[1][0] * v[184] + QBi[2][0] * v[185];
	v[206] = QBi[0][1] * v[183] + QBi[1][1] * v[184] + QBi[2][1] * v[185];
	v[207] = QBi[0][2] * v[183] + QBi[1][2] * v[184] + QBi[2][2] * v[185];
	v[234] = dGBp[0][1] * v[205] + dGBp[1][1] * v[206] + dGBp[2][1] * v[207];
	v[233] = dGBp[0][0] * v[205] + dGBp[1][0] * v[206] + dGBp[2][0] * v[207];
	v[208] = QBi[0][0] * v[187] + QBi[1][0] * v[189] + QBi[2][0] * v[190];
	v[209] = QBi[0][1] * v[187] + QBi[1][1] * v[189] + QBi[2][1] * v[190];
	v[210] = QBi[0][2] * v[187] + QBi[1][2] * v[189] + QBi[2][2] * v[190];
	v[236] = dGBp[0][1] * v[208] + dGBp[1][1] * v[209] + dGBp[2][1] * v[210];
	v[235] = dGBp[0][0] * v[208] + dGBp[1][0] * v[209] + dGBp[2][0] * v[210];
	v[211] = QBi[0][0] * v[192] + QBi[1][0] * v[194] + QBi[2][0] * v[195];
	v[212] = QBi[0][1] * v[192] + QBi[1][1] * v[194] + QBi[2][1] * v[195];
	v[213] = QBi[0][2] * v[192] + QBi[1][2] * v[194] + QBi[2][2] * v[195];
	v[238] = dGBp[0][1] * v[211] + dGBp[1][1] * v[212] + dGBp[2][1] * v[213];
	v[271] = -1e0*(v[228] * v[234] + v[230] * v[236] + v[232] * v[238]);
	v[270] = -1e0*(v[227] * v[234] + v[229] * v[236] + v[231] * v[238]);
	v[237] = dGBp[0][0] * v[211] + dGBp[1][0] * v[212] + dGBp[2][0] * v[213];
	v[277] = 2e0*(v[233] * v[234] + v[235] * v[236] + v[237] * v[238]);
	v[275] = -1e0*(v[228] * v[233] + v[230] * v[235] + v[232] * v[237]);
	v[274] = -1e0*(v[227] * v[233] + v[229] * v[235] + v[231] * v[237]);
	v[776] = 2e0*(uA[0] - uB[0] + GAp[0] * v[196] + GAp[1] * v[197] + GAp[2] * v[198] - GBp[0] * v[205] - GBp[1] * v[206]
		- GBp[2] * v[207] + xAi[0] - xBi[0]);
	v[777] = 2e0*(uA[1] - uB[1] + GAp[0] * v[199] + GAp[1] * v[200] + GAp[2] * v[201] - GBp[0] * v[208] - GBp[1] * v[209]
		- GBp[2] * v[210] + xAi[1] - xBi[1]);
	v[778] = 2e0*(uA[2] - uB[2] + GAp[0] * v[202] + GAp[1] * v[203] + GAp[2] * v[204] - GBp[0] * v[211] - GBp[1] * v[212]
		- GBp[2] * v[213] + xAi[2] - xBi[2]);
	Hes[0][0] = 0.5e0*(2e0*(v[227] * v[227]) + 2e0*(v[229] * v[229]) + 2e0*(v[231] * v[231]) + (ddGAp[0][0][0] * v[196]
		+ ddGAp[1][0][0] * v[197] + ddGAp[2][0][0] * v[198])*v[776] + (ddGAp[0][0][0] * v[199] + ddGAp[1][0][0] * v[200]
			+ ddGAp[2][0][0] * v[201])*v[777] + (ddGAp[0][0][0] * v[202] + ddGAp[1][0][0] * v[203] + ddGAp[2][0][0] * v[204]
				)*v[778]);
	Hes[0][1] = 0.5e0*(v[282] + (ddGAp[0][0][1] * v[196] + ddGAp[1][0][1] * v[197] + ddGAp[2][0][1] * v[198])*v[776] +
		(ddGAp[0][0][1] * v[199] + ddGAp[1][0][1] * v[200] + ddGAp[2][0][1] * v[201])*v[777] + (ddGAp[0][0][1] * v[202]
			+ ddGAp[1][0][1] * v[203] + ddGAp[2][0][1] * v[204])*v[778]);
	Hes[0][2] = v[274];
	Hes[0][3] = v[270];
	Hes[1][0] = 0.5e0*(v[282] + (ddGAp[0][1][0] * v[196] + ddGAp[1][1][0] * v[197] + ddGAp[2][1][0] * v[198])*v[776] +
		(ddGAp[0][1][0] * v[199] + ddGAp[1][1][0] * v[200] + ddGAp[2][1][0] * v[201])*v[777] + (ddGAp[0][1][0] * v[202]
			+ ddGAp[1][1][0] * v[203] + ddGAp[2][1][0] * v[204])*v[778]);
	Hes[1][1] = 0.5e0*(2e0*(v[228] * v[228]) + 2e0*(v[230] * v[230]) + 2e0*(v[232] * v[232]) + (ddGAp[0][1][1] * v[196]
		+ ddGAp[1][1][1] * v[197] + ddGAp[2][1][1] * v[198])*v[776] + (ddGAp[0][1][1] * v[199] + ddGAp[1][1][1] * v[200]
			+ ddGAp[2][1][1] * v[201])*v[777] + (ddGAp[0][1][1] * v[202] + ddGAp[1][1][1] * v[203] + ddGAp[2][1][1] * v[204]
				)*v[778]);
	Hes[1][2] = v[275];
	Hes[1][3] = v[271];
	Hes[2][0] = v[274];
	Hes[2][1] = v[275];
	Hes[2][2] = 0.5e0*(2e0*(v[233] * v[233]) + 2e0*(v[235] * v[235]) + 2e0*(v[237] * v[237]) + (-
		(ddGBp[0][0][0] * v[205]) - ddGBp[1][0][0] * v[206] - ddGBp[2][0][0] * v[207])*v[776] + (-
		(ddGBp[0][0][0] * v[208]) - ddGBp[1][0][0] * v[209] - ddGBp[2][0][0] * v[210])*v[777] + (-
			(ddGBp[0][0][0] * v[211]) - ddGBp[1][0][0] * v[212] - ddGBp[2][0][0] * v[213])*v[778]);
	Hes[2][3] = 0.5e0*(v[277] + (-(ddGBp[0][0][1] * v[205]) - ddGBp[1][0][1] * v[206] - ddGBp[2][0][1] * v[207]
		)*v[776] + (-(ddGBp[0][0][1] * v[208]) - ddGBp[1][0][1] * v[209] - ddGBp[2][0][1] * v[210])*v[777] + (-
		(ddGBp[0][0][1] * v[211]) - ddGBp[1][0][1] * v[212] - ddGBp[2][0][1] * v[213])*v[778]);
	Hes[3][0] = v[270];
	Hes[3][1] = v[271];
	Hes[3][2] = 0.5e0*(v[277] + (-(ddGBp[0][1][0] * v[205]) - ddGBp[1][1][0] * v[206] - ddGBp[2][1][0] * v[207]
		)*v[776] + (-(ddGBp[0][1][0] * v[208]) - ddGBp[1][1][0] * v[209] - ddGBp[2][1][0] * v[210])*v[777] + (-
		(ddGBp[0][1][0] * v[211]) - ddGBp[1][1][0] * v[212] - ddGBp[2][1][0] * v[213])*v[778]);
	Hes[3][3] = 0.5e0*(2e0*(v[234] * v[234]) + 2e0*(v[236] * v[236]) + 2e0*(v[238] * v[238]) + (-
		(ddGBp[0][1][1] * v[205]) - ddGBp[1][1][1] * v[206] - ddGBp[2][1][1] * v[207])*v[776] + (-
		(ddGBp[0][1][1] * v[208]) - ddGBp[1][1][1] * v[209] - ddGBp[2][1][1] * v[210])*v[777] + (-
			(ddGBp[0][1][1] * v[211]) - ddGBp[1][1][1] * v[212] - ddGBp[2][1][1] * v[213])*v[778]);

	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			mHes(i, j) = Hes[i][j];
}

bool RigidNURBSSurface_RigidNURBSSurface::FindMinimumSolution(SSContactData * c_data, Matrix * solution, Matrix & patch, int & return_info, bool &conv_total)
{

	//Marina
	conv_total = true;

	//Dados - trust region
	double Deltamax = 1e4;			//máximo raio da trust region permitido
	double Deltak = 0.1;			//atual raio de trust region
	double etha = 0.15;				//valor entre 0 e 0.15 - indica que a aproximação é ruim e veta o incremento
	double rhok = 0.0;				//razão entre a diferença na função objetivo e a diferença da aproximação utilizada
	double actual_reduction = 0.0;
	double predicted_reduction = 0.0;
	int max_it = max_it_1;
	double last_reduction = 0.0;
	double reduction = 0.0;
	Matrix Hes(4, 4);
	Matrix Gra(4, 1);
	Matrix pGra(4, 1);
	Matrix pk(4);
	Matrix pb(4);
	Matrix pc(4);
	Matrix xk(4);
	Matrix pt(2); //Marina
	Matrix P(4, 4);
	Matrix D(4, 4);
	Matrix cHes(4, 4);

	//Inicialização do método - chute inicial
	for (int i = 0; i < 4; i++)
		xk(i, 0) = (*solution)(i, 0);
	pt(0, 0) = patch(0, 0); //Marina
	pt(1, 0) = patch(1, 0); //Marina

	//Criterio de parada
	HessianPhase1(xk, pt, Hes);
	fulleigen1(Hes, P, D, tol_eig);
	double max_eig = -1e100;
	for (int i = 0; i < 4; i++)
	{
		if (D(i, i) > max_eig)
			max_eig = D(i, i);
	}
	double tol_ortho = tol_convective * abs(max_eig);
	double tol_small = tol_small_1;

	//Critério para identificar uma intersecção
	double tol_intersect = max_eig * tol_convective*tol_convective;

	//if (write_report)
		//fprintf(f_TR_report[seq_number], "FindMinimumSolution\n");
	char c = 'I';

	int it = 1;
	//Objetivo
	double ob = ObjectivePhase1(xk, pt);
	//Gradiente
	GradientPhase1(xk, pt, Gra);
	//Hessiana
	HessianPhase1(xk, pt, Hes);
	//Erro - forçando primeira entrada
	double error = tol_ortho + 1.0;
	//Initial guess report
	//if (write_report)
		//fprintf(f_TR_report[seq_number], "%d\t%d\t%.12e\t%.12e\t%d\t%.12e\t%.12e\t%.6e\t%.6e\t%.6e\t%c\t%.6e\t%.6e\t%.6e\n", it, static_cast<int>(pt(0, 0)), xk(0, 0), xk(1, 0), static_cast<int>(pt(1, 0)), xk(2, 0), xk(3, 0), ob, error, Deltak, c, rhok, actual_reduction, predicted_reduction);
	/////////////////////////////////////////////////////BEGIN///////////////////////////////////////////////

	if (ob <= tol_intersect) {
		//cout << "stop";
	}
	while ((error > tol_ortho || (norm(pk) > tol_convective && ob > tol_intersect)) && it <= max_it)
	{
		//Determinação do ponto de Cauchy
		double gragra = (transp(Gra)*Gra)(0, 0);
		double grahesgra = (transp(Gra)*Hes*Gra)(0, 0);
		double normgra = norm(Gra);
		Matrix pc;	//direção do Cauchy point
		/////////////////Ponto de Cauchy///////////////////////
		if (grahesgra <= 0.0)
			pc = -(Deltak / normgra)*Gra;
		else
			pc = -gragra / grahesgra * Gra;
		double normpc = norm(pc);
		//Cauchy point outside the TR - use a fraction of it
		if ((normpc + tol_convective) >= Deltak)
		{
			pk = (Deltak / normpc)*pc; //Steep descent
			c = 'C';
		}
		else//Cauchy point inside the TR
		{
			//Calculando direções principais e curvaturas principais da função objetivo
			cHes = Hes;
			fulleigen1(cHes, P, D, tol_eig);
			//Escrevendo gradiente nas direções principais
			pGra = transp(P)*Gra;
			//Determinação do menor autovalor (min_eig)
			double min_eig = 1e100;
			for (int i = 0; i < 4; i++)
			{
				if (D(i, i) < min_eig)
					min_eig = D(i, i);
			}
			//Construção da direção de busca
			//Direção de busca baseada em NR - modificada pelo menor autovalor
			zeros(&pb);
			//Se o menor autovalor é menor ou igual a zero (tol_small) - modifica a direção de NR para garantir direção descendente
			if (min_eig < tol_small)
			{
				for (int i = 0; i < 4; i++)
					pb(i, 0) = -pGra(i, 0) / (D(i, i) - (min_eig - abs(min_eig)*tol_ascent));
			}
			//Se o menor autovalor é maior que zero (tol_small) - direção de NR é escolhida
			else
			{
				for (int i = 0; i < 4; i++)
					pb(i, 0) = -pGra(i, 0) / D(i, i);
			}
			//Escrevendo direção de busca nas coordenadas originais

			pb = P * pb;
			double normpb = norm(pb);
			double thetak;
			//Newton point inside the TR -  use it
			if (normpb <= Deltak)
			{
				pk = pb;
				c = 'N';
			}
			else
			{
				////////////////////////////Dogleg path//////////////////////////
				double a1, b1, c1;
				a1 = norm(pb - pc)*norm(pb - pc);
				b1 = 2 * (transp(pc)*(pb - pc))(0, 0);
				c1 = normpc * normpc - Deltak * Deltak;
				thetak = (-b1 + sqrt(b1*b1 - 4 * a1*c1)) / (2 * a1);
				//Determinação do path
				pk = pc + thetak * (pb - pc);
				c = 'D';
			}
		}

		//////////////////////////UPDATING SOLUTION////////////////////////////////
		//Cálculo de rhok
		actual_reduction = ObjectivePhase1(xk, pt) - ObjectivePhase1(xk + pk, pt);
		predicted_reduction = -(transp(Gra)*pk + 0.5*transp(pk)*Hes*pk)(0, 0);
		rhok = actual_reduction / predicted_reduction;

		if (abs(actual_reduction / ObjectivePhase1(xk, pt)) < tol_ascent)
			rhok = 1.0;

		if (abs(predicted_reduction) < tol_small || abs(actual_reduction) < tol_small)
			rhok = 1.0;

		if (rhok >= 0)
		{
			//low reduction
			if (rhok < 0.25)
				Deltak = 0.25*norm(pk);
			else
			{
				if (rhok > 0.75 && ((norm(pk) + tol_convective) >= Deltak && (norm(pk) - tol_convective) <= Deltak))//high reduction and testing the limits of the trust region
				{
					//augments the radius of TR
					if (2.0 * Deltak < Deltamax)
						Deltak = 2.0 * Deltak;
					else
						Deltak = Deltamax;
				}
			}
			if (rhok >= etha)
			{
				xk = xk + pk;
				if (xk(0, 0) < surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order] || xk(0, 0) > surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] || xk(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order] || xk(1, 0) > surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] || xk(2, 0) < surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order] || xk(2, 0) > surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] || xk(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order] || xk(3, 0) > surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim]) {
					conv_total = false;
					for (int i = 0; i < 4; i++)
						(*solution)(i, 0) = xk(i, 0);
					break;
				}
				else {
				}
			}


		}
		else
			Deltak = Deltak / 2.0;
		//Incrementa iterações
		it++;
		//Objetivo
		ob = ObjectivePhase1(xk, pt);
		//Gradiente
		GradientPhase1(xk, pt, Gra);
		//Hessiana
		HessianPhase1(xk, pt, Hes);
		//Erro - norma do gradiente
		error = norm(Gra);
		//if (write_report)
			//fprintf(f_TR_report[seq_number], "%d\t%d\t%.12e\t%.12e\t%d\t%.12e\t%.12e\t%.6e\t%.6e\t%.6e\t%c\t%.6e\t%.6e\t%.6e\n", it, static_cast<int>(pt(0, 0)), xk(0, 0), xk(1, 0), static_cast<int>(pt(1, 0)), xk(2, 0), xk(3, 0), ob, error, Deltak, c, rhok, actual_reduction, predicted_reduction);
	}
	//if (write_report)
		//fprintf(f_TR_report[seq_number], "Error\t%.6e\tTolerance\t%.6e\n", error, tol_ortho);

	//Retorno da função
	if (error < tol_ortho /*&& VerifyConvectiveRange(xk, patch) == 0*/)
	{
		for (int i = 0; i < 4; i++)
			(*solution)(i, 0) = xk(i, 0);
		return true;
	}
	else
		for (int i = 0; i < 4; i++)
			(*solution)(i, 0) = xk(i, 0);
		return false;
	return false;
}

bool RigidNURBSSurface_RigidNURBSSurface::GeneralFindMinimumSolution(SSContactData * c_data, Matrix * solution, Matrix & patch, int & return_info, int &number_patchesA, int &number_patchesB)
{

	int uv = 0;
	double tol = 0.0;
	double err = 0.0;
	bool convv = true;
	bool duoA = false;
	bool duoB = false;
	int patch_aux[2];
	int patch_duo[2];
	int patch_old[2];
	patch_aux[0] = 0;
	patch_aux[1] = 0;
	patch_duo[0] = 0;
	patch_duo[1] = 0;
	patch_old[0] = 0;
	patch_old[1] = 0;
	Matrix pointA(3); // Ponto no sistema local de coordenadas (superfície A)
	Matrix pointB(3); // Ponto no sistema local de coordenadas (superfície B)
	Matrix point_c(3); // Ponto no sistema local de coordenadas - conferência
	Matrix point_aux(3); // Ponto no sistema local de coordenadas - auxiliar

	double u = 0.0;
	double v = 0.0;
	double u_aux = 0.0;
	double v_aux = 0.0;
	double uA_final = (*solution)(0, 0);
	double vA_final = (*solution)(1, 0);
	int patchA_final = patch(0, 0);
	double uB_final = (*solution)(2, 0);
	double vB_final = (*solution)(3, 0);
	int patchB_final = patch(1, 0);

	double d = 0;

	int *used_patchesA;
	used_patchesA = new int[surfA->n_patches];
	int *used_patchesB;
	used_patchesB = new int[surfB->n_patches];
	for (int i = 0; i < surfA->n_patches; i++)
	{
		used_patchesA[i] = 0;
	}
	for (int i = 0; i < surfB->n_patches; i++)
	{
		used_patchesB[i] = 0;
	}

	bool conv_total = true;
	bool flag = FindMinimumSolution(c_data, solution, patch, return_info, conv_total);
	int iter = 0;

	used_patchesA[static_cast<int>(patch(0, 0))] = 1;
	used_patchesB[static_cast<int>(patch(1, 0))] = 1;

	while (flag == false && conv_total == false && iter < 5) {
		// Análise da superfície A
		if (((*solution)(0, 0) < surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) || ((*solution)(0, 0) > surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim])) {
			if (((*solution)(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) || ((*solution)(1, 0) > surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim])) {
				duoA = true;
				if (((*solution)(0, 0) < surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order])) {
					u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order];
					uA_final = u;
					patch_aux[0] = (surfA->patches[patch(0, 0)]->connectivity[0]) - 1;
				}
				else {
					u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim];
					uA_final = u;
					patch_aux[0] = (surfA->patches[patch(0, 0)]->connectivity[1]) - 1;
				}
				if (((*solution)(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order])) {
					v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order];
					vA_final = v;
					patch_duo[0] = (surfA->patches[patch(0, 0)]->connectivity[2] - 1);
				}
				else {
					v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim];
					vA_final = v;
					patch_duo[0] = (surfA->patches[patch(0, 0)]->connectivity[3] - 1);
				}
			}
			else {
				v = (*solution)(1, 0);
				if (((*solution)(0, 0) < surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order])) {
					u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order];
					uA_final = u;
					patch_aux[0] = (surfA->patches[patch(0, 0)]->connectivity[0] - 1);
				}
				else {
					u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim];
					uA_final = u;
					patch_aux[0] = (surfA->patches[patch(0, 0)]->connectivity[1] - 1);
				}
			}
			surfA->patches[patch(0, 0)]->NURBSPoint(u, v, pointA);
			if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patch(0, 0)) {
				uv = 0;
				u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
				v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
				{
					v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patch(0, 0)) {
				uv = 0;
				u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
				v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
				{
					v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patch(0, 0)) {
				uv = 1;
				v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
				u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
				{
					u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patch(0, 0)) {
				uv = 1;
				v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
				u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
				{
					u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			(*solution)(0, 0) = u;
			(*solution)(1, 0) = v;
			patch_old[0] = patch(0, 0);
			patch(0, 0) = patch_aux[0];
			surfA->patches[patch_aux[0]]->PointInversion(pointA, (*solution)(0, 0), (*solution)(1, 0), point_c, convv, tol, err, uv);
		}
		else {
			u = (*solution)(0, 0);
			if (((*solution)(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) || ((*solution)(1, 0) > surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim])) {
				if (((*solution)(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order])) {
					v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order];
					vA_final = v;
					patch_aux[0] = (surfA->patches[patch(0, 0)]->connectivity[2] - 1);
				}
				else {
					v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim];
					vA_final = v;
					patch_aux[0] = (surfA->patches[patch(0, 0)]->connectivity[3] - 1);
				}
				surfA->patches[patch(0, 0)]->NURBSPoint(u, v, pointA);
				if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patch(0, 0)) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patch(0, 0)) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patch(0, 0)) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patch(0, 0)) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				(*solution)(0, 0) = u;
				(*solution)(1, 0) = v;
				patch_old[0] = patch(0, 0);
				patch(0, 0) = patch_aux[0];
				surfA->patches[patch_aux[0]]->PointInversion(pointA, (*solution)(0, 0), (*solution)(1, 0), point_c, convv, tol, err, uv);
			}
			else {
				v = (*solution)(1, 0);
				patch_aux[0] = patch(0, 0);
				patch_old[0] = patch(0, 0);
			}
		}

		// Análise da superfície B
		if (((*solution)(2, 0) < surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) || ((*solution)(2, 0) > surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim])) {
			if (((*solution)(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) || ((*solution)(3, 0) > surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim])) {
				duoB = true;
				if (((*solution)(2, 0) < surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order])) {
					u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order];
					uB_final = u;
					patch_aux[1] = (surfB->patches[patch(1, 0)]->connectivity[0] - 1);
				}
				else {
					u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim];
					uB_final = u;
					patch_aux[1] = (surfB->patches[patch(1, 0)]->connectivity[1] - 1);
				}
				if (((*solution)(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order])) {
					v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order];
					vB_final = v;
					patch_duo[1] = (surfB->patches[patch(1, 0)]->connectivity[2] - 1);
				}
				else {
					v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim];
					vB_final = v;
					patch_duo[1] = (surfB->patches[patch(1, 0)]->connectivity[3] - 1);
				}
			}
			else {
				v = (*solution)(3, 0);
				if (((*solution)(2, 0) < surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order])) {
					u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order];
					uB_final = u;
					patch_aux[1] = (surfB->patches[patch(1, 0)]->connectivity[0] - 1);
				}
				else {
					u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim];
					uB_final = u;
					patch_aux[1] = (surfB->patches[patch(1, 0)]->connectivity[1] - 1);
				}
			}
			surfB->patches[patch(1, 0)]->NURBSPoint(u, v, pointB);
			if ((surfB->patches[patch_aux[1]]->connectivity[0] - 1) == patch(1, 0)) {
				uv = 0;
				u = surfB->patches[patch_aux[1]]->U_knot_vector[surfB->patches[patch_aux[1]]->U_order];
				v = (surfB->patches[patch_aux[1]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[1]]->parameter_sub[0][0][4]) / 2;
				surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[1]; j++)
				{
					v_aux = (surfB->patches[patch_aux[1]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[1]]->parameter_sub[0][j][4]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfB->patches[patch_aux[1]]->connectivity[1] - 1) == patch(1, 0)) {
				uv = 0;
				u = surfB->patches[patch_aux[1]]->U_knot_vector[surfB->patches[patch_aux[1]]->U_dim];
				v = (surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][0][4]) / 2;
				surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[1]; j++)
				{
					v_aux = (surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][j][4]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfB->patches[patch_aux[1]]->connectivity[2] - 1) == patch(1, 0)) {
				uv = 1;
				v = surfB->patches[patch_aux[1]]->V_knot_vector[surfB->patches[patch_aux[1]]->V_order];
				u = (surfB->patches[patch_aux[1]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[1]]->parameter_sub[0][0][1]) / 2;
				surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[0]; j++)
				{
					u_aux = (surfB->patches[patch_aux[1]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[1]]->parameter_sub[j][0][1]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			else if ((surfB->patches[patch_aux[1]]->connectivity[3] - 1) == patch(1, 0)) {
				uv = 1;
				v = surfB->patches[patch_aux[1]]->V_knot_vector[surfB->patches[patch_aux[1]]->V_dim];
				u = (surfB->patches[patch_aux[1]]->parameter_sub[0][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[1]]->parameter_sub[0][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][1]) / 2;
				surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[0]; j++)
				{
					u_aux = (surfB->patches[patch_aux[1]]->parameter_sub[j][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[1]]->parameter_sub[j][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][1]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			(*solution)(2, 0) = u;
			(*solution)(3, 0) = v;
			patch_old[1] = patch(1, 0);
			patch(1, 0) = patch_aux[1];
			surfB->patches[patch_aux[1]]->PointInversion(pointB, (*solution)(2, 0), (*solution)(3, 0), point_c, convv, tol, err, uv);
		}
		else {
			u = (*solution)(2, 0);
			if (((*solution)(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) || ((*solution)(3, 0) > surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim])) {
				if (((*solution)(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order])) {
					v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order];
					vB_final = v;
					patch_aux[1] = (surfB->patches[patch(1, 0)]->connectivity[2] - 1);
				}
				else {
					v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim];
					vB_final = v;
					patch_aux[1] = (surfB->patches[patch(1, 0)]->connectivity[3] - 1);
				}
				surfB->patches[patch(1, 0)]->NURBSPoint(u, v, pointB);
				if ((surfB->patches[patch_aux[1]]->connectivity[0] - 1) == patch(1, 0)) {
					uv = 0;
					u = surfB->patches[patch_aux[1]]->U_knot_vector[surfB->patches[patch_aux[1]]->U_order];
					v = (surfB->patches[patch_aux[1]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[1]]->parameter_sub[0][0][4]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[1]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[1]]->parameter_sub[0][j][4]) / 2;
						surfB->patches[patch_aux[1]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[1]]->connectivity[1] - 1) == patch(1, 0)) {
					uv = 0;
					u = surfB->patches[patch_aux[1]]->U_knot_vector[surfB->patches[patch_aux[1]]->U_dim];
					v = (surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][0][4]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[1]]->parameter_sub[surfB->patches[patch_aux[1]]->subdivisions[0] - 1][j][4]) / 2;
						surfB->patches[patch_aux[1]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[1]]->connectivity[2] - 1) == patch(1, 0)) {
					uv = 1;
					v = surfB->patches[patch_aux[1]]->V_knot_vector[surfB->patches[patch_aux[1]]->V_order];
					u = (surfB->patches[patch_aux[1]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[1]]->parameter_sub[0][0][1]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[1]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[1]]->parameter_sub[j][0][1]) / 2;
						surfB->patches[patch_aux[1]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[1]]->connectivity[3] - 1) == patch(1, 0)) {
					uv = 1;
					v = surfB->patches[patch_aux[1]]->V_knot_vector[surfB->patches[patch_aux[1]]->V_dim];
					u = (surfB->patches[patch_aux[1]]->parameter_sub[0][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[1]]->parameter_sub[0][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][1]) / 2;
					surfB->patches[patch_aux[1]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[1]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[1]]->parameter_sub[j][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[1]]->parameter_sub[j][surfB->patches[patch_aux[1]]->subdivisions[1] - 1][1]) / 2;
						surfB->patches[patch_aux[1]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				(*solution)(2, 0) = u;
				(*solution)(3, 0) = v;
				patch_old[1] = patch(1, 0);
				patch(1, 0) = patch_aux[1];
				surfB->patches[patch_aux[1]]->PointInversion(pointB, (*solution)(2, 0), (*solution)(3, 0), point_c, convv, tol, err, uv);
			}
			else {
				v = (*solution)(3, 0);
				patch_aux[1] = patch(1, 0);
				patch_old[1] = patch(1, 0);
			}
		}

		flag = FindMinimumSolution(c_data, solution, patch, return_info, conv_total);
		used_patchesA[static_cast<int>(patch(0, 0))] = 1;
		used_patchesB[static_cast<int>(patch(1, 0))] = 1;

		iter++;
	}

	number_patchesA = 0;
	number_patchesB = 0;
	for (int i = 0; i < surfA->n_patches; i++)
	{
		if (used_patchesA[i] == 1)
			number_patchesA++;
	}
	for (int i = 0; i < surfB->n_patches; i++)
	{
		if (used_patchesB[i] == 1)
			number_patchesB++;
	}

	delete []used_patchesA;
	delete []used_patchesB;

	if (flag == false) {
		return false;
	}
	else {
		//Surface A and B
		if (((*solution)(0, 0) >= surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) && ((*solution)(0, 0) <= surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim]) && ((*solution)(1, 0) >= surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) && ((*solution)(1, 0) <= surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim]) && ((*solution)(2, 0) >= surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) && ((*solution)(2, 0) <= surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim]) && ((*solution)(3, 0) >= surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) && ((*solution)(3, 0) <= surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim])) {
			return true;
		}
		else {
			return false;
		}
	}
}

bool RigidNURBSSurface_RigidNURBSSurface::GeneralNURBSPointProjection(double &zeta, double &theta, int &patch, double p[3], int surf)
{
	/*-----------------------------------------------------------------------------------------------------------------*/
	// Verificar se a superfície é um plano
	// Derivadas das superfícies no ponto inicial (intersecção ou ponto de sela anterior)
	// Superfície A ou B
	int d_n = 2;
	Matrix** data;
	data = new Matrix*[d_n + 1];
	double der_zeta_zeta;
	double der_zeta_theta;
	double der_theta_theta;
	for (int i = 0; i < d_n + 1; i++)
	{
		data[i] = new Matrix[d_n + 1];
		for (int j = 0; j < d_n + 1; j++)
			data[i][j] = Matrix(3);
	}
	if (surf == 0) {
		surfA->patches[patch]->NURBSDerivatives(zeta, theta, data, d_n);
		der_zeta_zeta = sqrt(data[2][0](0, 0) * data[2][0](0, 0) + data[2][0](1, 0) * data[2][0](1, 0) + data[2][0](2, 0) * data[2][0](2, 0));
		der_zeta_theta = sqrt(data[1][1](0, 0) * data[1][1](0, 0) + data[1][1](1, 0) * data[1][1](1, 0) + data[1][1](2, 0) * data[1][1](2, 0));
		der_theta_theta = sqrt(data[0][2](0, 0) * data[0][2](0, 0) + data[0][2](1, 0) * data[0][2](1, 0) + data[0][2](2, 0) * data[0][2](2, 0));
	}
	else {
		surfB->patches[patch]->NURBSDerivatives(zeta, theta, data, d_n);
		der_zeta_zeta = sqrt(data[2][0](0, 0) * data[2][0](0, 0) + data[2][0](1, 0) * data[2][0](1, 0) + data[2][0](2, 0) * data[2][0](2, 0));
		der_zeta_theta = sqrt(data[1][1](0, 0) * data[1][1](0, 0) + data[1][1](1, 0) * data[1][1](1, 0) + data[1][1](2, 0) * data[1][1](2, 0));
		der_theta_theta = sqrt(data[0][2](0, 0) * data[0][2](0, 0) + data[0][2](1, 0) * data[0][2](1, 0) + data[0][2](2, 0) * data[0][2](2, 0));
	}
	
	bool plane = false;

	if (der_zeta_zeta < tol_small_1 /*&& der_zeta_theta < tol_small_1*/ && der_theta_theta < tol_small_1) {
		plane = true;
	}

	for (int i = 0; i < d_n + 1; i++)
	{
		delete[]data[i];
	}
	delete[]data;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Degeneração
	int s_free = cd->P_0[0]->getColumns();
	int s_freeA = 0;
	int s_freeB = 0;
	for (int i = 0; i < s_free; i++)
	{
		if ((*cd->P_0[0])(0, i) == 1 || (*cd->P_0[0])(1, i) == 1) {
			s_freeA++;
		}
		if ((*cd->P_0[0])(2, i) == 1 || (*cd->P_0[0])(3, i) == 1) {
			s_freeB++;
		}
	}
	Matrix *P_0_A = new Matrix(2, s_freeA);
	for (int i = 0; i < s_freeA; i++)
	{
		(*P_0_A)(0, i) = (*cd->P_0[0])(0, i);
		(*P_0_A)(1, i) = (*cd->P_0[0])(1, i);
	}
	Matrix *P_0_B = new Matrix(2, s_freeB);
	for (int i = 0; i < s_freeB; i++)
	{
		(*P_0_B)(0, i) = (*cd->P_0[0])(2, i + s_freeA);
		(*P_0_B)(1, i) = (*cd->P_0[0])(3, i + s_freeA);
	}
	/*-----------------------------------------------------------------------------------------------------------------*/
	
	/*-----------------------------------------------------------------------------------------------------------------*/
	// Convergência da função de suporte
	bool conv_proj = false;
	bool conv_total = true;
	/*-----------------------------------------------------------------------------------------------------------------*/

	// Variáveis para casos de mudança de patch
	int uv = 0;
	double tol = 0.0;
	double err = 0.0;
	bool convv = true;
	bool duoA = false;
	bool duoB = false;
	int patch_aux[2];
	int patch_duo[2];
	int patch_old[2];
	patch_aux[0] = 0;
	patch_aux[1] = 0;
	patch_duo[0] = 0;
	patch_duo[1] = 0;
	patch_old[0] = 0;
	patch_old[1] = 0;
	Matrix point(3); // Ponto no sistema local de coordenadas (superfície A)
	Matrix point_c(3); // Ponto no sistema local de coordenadas - conferência
	Matrix point_aux(3); // Ponto no sistema local de coordenadas - auxiliar

	double u = 0.0;
	double v = 0.0;
	double u_aux = 0.0;
	double v_aux = 0.0;

	double d = 0;

	double uf = zeta;
	double vf = theta;

	double *p_f;
	p_f = new double[3];
	p_f[0] = 0.0;
	p_f[1] = 0.0;
	p_f[2] = 0.0;

	bool conv = true;

	//double objective = 0.0;

	if (surf == 0) {
		surfA->patches[(patch)]->NURBSPointProjection(p, uf, vf, p_f, conv, tol, err, conv_total, P_0_A);
	}
	else {
		surfB->patches[(patch)]->NURBSPointProjection(p, uf, vf, p_f, conv, tol, err, conv_total, P_0_B);
	}

	int iter = 0;

	if (surf == 0) {
		while (conv_total == false && iter < 5 && s_freeA == 2 && plane == false) {
			// Análise da superfície A
			if ((uf < surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order]) || (uf > surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_dim])) {
				if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order]) || (vf > surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim])) {
					duoA = true;
					if ((uf < surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order])) {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order];
						patch_aux[0] = (surfA->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_dim];
						patch_aux[0] = (surfA->patches[patch]->connectivity[1] - 1);
					}
					if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order])) {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order];
						patch_duo[0] = (surfA->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim];
						patch_duo[0] = (surfA->patches[patch]->connectivity[3] - 1);
					}
				}
				else {
					v = vf;
					if ((uf < surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order])) {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order];
						patch_aux[0] = (surfA->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_dim];
						patch_aux[0] = (surfA->patches[patch]->connectivity[1] - 1);
					}
				}
				surfA->patches[patch]->NURBSPoint(u, v, point);
				if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				uf = u;
				vf = v;
				patch_old[0] = patch;
				patch = patch_aux[0];
				surfA->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
			}
			else {
				u = uf;
				if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order]) || (vf > surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim])) {
					if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order])) {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order];
						patch_aux[0] = (surfA->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim];
						patch_aux[0] = (surfA->patches[patch]->connectivity[3] - 1);
					}
					surfA->patches[patch]->NURBSPoint(u, v, point);
					if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
						uv = 0;
						u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
						v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
						uv = 0;
						u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
						v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
						uv = 1;
						v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
						u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
						uv = 1;
						v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
						u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					uf = u;
					vf = v;
					patch_old[0] = patch;
					patch = patch_aux[0];
					surfA->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
				}
				else {
					v = vf;
					patch_aux[0] = patch;
					patch_old[0] = patch;
				}
			}

			surfA->patches[(patch)]->NURBSPointProjection(p, uf, vf, p_f, conv, tol, err, conv_total, P_0_A);

			iter++;
		}
	}
	else {
		while (conv_total == false && iter < 5 && s_freeB == 2 && plane == false) {
			// Análise da superfície B
			if ((uf < surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order]) || (uf > surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_dim])) {
				if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order]) || (vf > surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim])) {
					duoA = true;
					if ((uf < surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order])) {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order];
						patch_aux[0] = (surfB->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_dim];
						patch_aux[0] = (surfB->patches[patch]->connectivity[1] - 1);
					}
					if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order])) {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order];
						patch_duo[0] = (surfB->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim];
						patch_duo[0] = (surfB->patches[patch]->connectivity[3] - 1);
					}
				}
				else {
					v = vf;
					if ((uf < surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order])) {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order];
						patch_aux[0] = (surfB->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_dim];
						patch_aux[0] = (surfB->patches[patch]->connectivity[1] - 1);
					}
				}
				surfB->patches[patch]->NURBSPoint(u, v, point);
				if ((surfB->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
					uv = 0;
					u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_order];
					v = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
					uv = 0;
					u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_dim];
					v = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
					uv = 1;
					v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_order];
					u = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
					uv = 1;
					v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_dim];
					u = (surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				uf = u;
				vf = v;
				patch_old[0] = patch;
				patch = patch_aux[0];
				surfB->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
			}
			else {
				u = uf;
				if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order]) || (vf > surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim])) {
					if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order])) {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order];
						patch_aux[0] = (surfB->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim];
						patch_aux[0] = (surfB->patches[patch]->connectivity[3] - 1);
					}
					surfB->patches[patch]->NURBSPoint(u, v, point);
					if ((surfB->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
						uv = 0;
						u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_order];
						v = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfB->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
						uv = 0;
						u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_dim];
						v = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfB->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
						uv = 1;
						v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_order];
						u = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					else if ((surfB->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
						uv = 1;
						v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_dim];
						u = (surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					uf = u;
					vf = v;
					patch_old[0] = patch;
					patch = patch_aux[0];
					surfB->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
				}
				else {
					v = vf;
					patch_aux[0] = patch;
					patch_old[0] = patch;
				}
			}

			surfB->patches[(patch)]->NURBSPointProjection(p, uf, vf, p_f, conv, tol, err, conv_total, P_0_B);

			iter++;
		}
	}

	conv_proj = conv;

	if (conv_proj == false || conv_total == false) {
		zeta = uf;
		theta = vf;
		delete[]p_f;
		return false;
	}
	else {
		zeta = uf;
		theta = vf;
		delete[]p_f;
	}

	return true;
}

bool RigidNURBSSurface_RigidNURBSSurface::FindMinimumSolutionCSO(SSContactData * c_data, Matrix * solution, Matrix * patches, int type_initial_estimate)
{
	/*-----------------------------------------------------------------------------------------------------------------*/
	// Degeneração
	int s_free = cd->P_0[0]->getColumns();
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Convergência
	bool converged = true;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Verificar se todos os parâmetros são fixos
	if (s_free == 0) {
		return converged;
	}
	else {
		// Variáveis iniciais
		inv_QAp = transp(*ptrQAp);
		inv_QBp = transp(*ptrQBp);

		bool conv = true;
		bool conv_sup = true;
		bool conv_sup_test = true;
		
		bool conv_total1 = true;
		bool conv_total2 = true;
		bool sf = true; // retorno da 'support function'
		bool sf_test = true; // retorno da 'support function' teste

		// Parâmetros iniciais das superfícies
		double *zetaA = new double((*solution)(0, 0));
		double *thetaA = new double((*solution)(1, 0));
		double *zetaB = new double((*solution)(2, 0));
		double *thetaB = new double((*solution)(3, 0));
		int *patchA = new int((*patches)(0, 0));
		int *patchB = new int((*patches)(1, 0));

		// Direção de busca da penetração máxima
		double v_dir[3];
		double rho;
		double phi;

		// Derivadas das superfícies no ponto inicial (intersecção ou ponto de sela anterior)
		// Superfície A
		int dA = 2;
		Matrix** dataA;
		dataA = new Matrix*[dA + 1];
		for (int i = 0; i < dA + 1; i++)
		{
			dataA[i] = new Matrix[dA + 1];
			for (int j = 0; j < dA + 1; j++)
				dataA[i][j] = Matrix(3);
		}
		surfA->patches[*patchA]->NURBSDerivatives(*zetaA, *thetaA, dataA, dA);
		double der_zeta_zeta_A = sqrt(dataA[2][0](0, 0) * dataA[2][0](0, 0) + dataA[2][0](1, 0) * dataA[2][0](1, 0) + dataA[2][0](2, 0) * dataA[2][0](2, 0));
		double der_zeta_theta_A = sqrt(dataA[1][1](0, 0) * dataA[1][1](0, 0) + dataA[1][1](1, 0) * dataA[1][1](1, 0) + dataA[1][1](2, 0) * dataA[1][1](2, 0));
		double der_theta_theta_A = sqrt(dataA[0][2](0, 0) * dataA[0][2](0, 0) + dataA[0][2](1, 0) * dataA[0][2](1, 0) + dataA[0][2](2, 0) * dataA[0][2](2, 0));

		// Superfície B
		int dB = 2;
		Matrix** dataB;
		dataB = new Matrix*[dB + 1];
		for (int i = 0; i < dB + 1; i++)
		{
			dataB[i] = new Matrix[dB + 1];
			for (int j = 0; j < dB + 1; j++)
				dataB[i][j] = Matrix(3);
		}
		surfB->patches[*patchB]->NURBSDerivatives(*zetaB, *thetaB, dataB, dB);
		double der_zeta_zeta_B = sqrt(dataB[2][0](0, 0) * dataB[2][0](0, 0) + dataB[2][0](1, 0) * dataB[2][0](1, 0) + dataB[2][0](2, 0) * dataB[2][0](2, 0));
		double der_zeta_theta_B = sqrt(dataB[1][1](0, 0) * dataB[1][1](0, 0) + dataB[1][1](1, 0) * dataB[1][1](1, 0) + dataB[1][1](2, 0) * dataB[1][1](2, 0));
		double der_theta_theta_B = sqrt(dataB[0][2](0, 0) * dataB[0][2](0, 0) + dataB[0][2](1, 0) * dataB[0][2](1, 0) + dataB[0][2](2, 0) * dataB[0][2](2, 0));

		/*-----------------------------------------------------------------------------------------------------------------*/
		// Degeneração por superfície
		int s_freeA = 0;
		int s_freeB = 0;
		for (int i = 0; i < s_free; i++)
		{
			if ((*cd->P_0[0])(0, i) == 1 || (*cd->P_0[0])(1, i) == 1) {
				s_freeA++;
			}
			if ((*cd->P_0[0])(2, i) == 1 || (*cd->P_0[0])(3, i) == 1) {
				s_freeB++;
			}
		}
		/*-----------------------------------------------------------------------------------------------------------------*/

		// Caso particular: plano B com partícula A + degeneração do plano B
		if (der_zeta_zeta_B < tol_small_1 /*&& der_zeta_theta_B < tol_small_1*/ && der_theta_theta_B < tol_small_1 && (der_zeta_zeta_A > tol_small_1 /*|| der_zeta_theta_A > tol_small_1*/ || der_theta_theta_A > tol_small_1) && s_freeB == 0) {

			// Ponto do plano B no sistema global de coordenadas
			Matrix NURBSPoint(3);

			double *fB;
			fB = new double[3];
			fB[0] = 0.0;
			fB[1] = 0.0;
			fB[2] = 0.0;

			surfB->patches[*patchB]->NURBSPoint(*zetaB, *thetaB, NURBSPoint);
			fB[0] = (*ptrQBp)(0, 0) * NURBSPoint(0, 0) + (*ptrQBp)(0, 1) * NURBSPoint(1, 0) + (*ptrQBp)(0, 2) * NURBSPoint(2, 0) + (*ptrx0Bp)(0, 0);
			fB[1] = (*ptrQBp)(1, 0) * NURBSPoint(0, 0) + (*ptrQBp)(1, 1) * NURBSPoint(1, 0) + (*ptrQBp)(1, 2) * NURBSPoint(2, 0) + (*ptrx0Bp)(1, 0);
			fB[2] = (*ptrQBp)(2, 0) * NURBSPoint(0, 0) + (*ptrQBp)(2, 1) * NURBSPoint(1, 0) + (*ptrQBp)(2, 2) * NURBSPoint(2, 0) + (*ptrx0Bp)(2, 0);

			// Ponto no sistema de coordenadas da superfície A
			double *fA;
			fA = new double[3];

			fA[0] = inv_QAp(0, 0) * (fB[0] - (*ptrx0Ap)(0, 0)) + inv_QAp(0, 1) * (fB[1] - (*ptrx0Ap)(1, 0)) + inv_QAp(0, 2) * (fB[2] - (*ptrx0Ap)(2, 0));
			fA[1] = inv_QAp(1, 0) * (fB[0] - (*ptrx0Ap)(0, 0)) + inv_QAp(1, 1) * (fB[1] - (*ptrx0Ap)(1, 0)) + inv_QAp(1, 2) * (fB[2] - (*ptrx0Ap)(2, 0));
			fA[2] = inv_QAp(2, 0) * (fB[0] - (*ptrx0Ap)(0, 0)) + inv_QAp(2, 1) * (fB[1] - (*ptrx0Ap)(1, 0)) + inv_QAp(2, 2) * (fB[2] - (*ptrx0Ap)(2, 0));

			conv_total2 = GeneralNURBSPointProjection(*zetaA, *thetaA, *patchA, fA, 0);

			if (conv_total2) {
				(*solution)(0, 0) = *zetaA;
				(*solution)(1, 0) = *thetaA;
				(*solution)(2, 0) = *zetaB;
				(*solution)(3, 0) = *thetaB;
				(*patches)(0, 0) = *patchA;
				(*patches)(1, 0) = *patchB;
				}
			else {
				(*solution)(0, 0) = *zetaA;
				(*solution)(1, 0) = *thetaA;
				(*solution)(2, 0) = *zetaB;
				(*solution)(3, 0) = *thetaB;
				(*patches)(0, 0) = *patchA;
				(*patches)(1, 0) = *patchB;
				converged = false;
			}
			
			delete[]fB;

			delete[]fA;

			for (int i = 0; i < dA + 1; i++)
			{
				delete[]dataA[i];
			}
			delete[]dataA;
			for (int i = 0; i < dB + 1; i++)
			{
				delete[]dataB[i];
			}
			delete[]dataB;
			delete zetaA;
			delete thetaA;
			delete zetaB;
			delete thetaB;
			delete patchA;
			delete patchB;

			return converged;
		}
		// Caso particular: plano A com partícula B
		else if (der_zeta_zeta_A < tol_small_1 /*&& der_zeta_theta_A < tol_small_1*/ && der_theta_theta_A < tol_small_1 && (der_zeta_zeta_B > tol_small_1 /*|| der_zeta_theta_B > tol_small_1*/ || der_theta_theta_B > tol_small_1) && s_freeA != 0) {

			double tol = 0.0;
			double err = 0.0;

			// Avaliação da normal do plano A
			Matrix *nA;
			nA = new Matrix(3);
			surfA->patches[*patchA]->NormalExt(ptrQAp, zetaA, thetaA, nA);

			// Direção de penetração máxima
			v_dir[0] = -(*nA)(0, 0);
			v_dir[1] = -(*nA)(1, 0);
			v_dir[2] = -(*nA)(2, 0);

			rho = atan2(v_dir[1], v_dir[0]); // Direção de penetração máxima (coordenadas esféricas)
			phi = atan2(sqrt(v_dir[0] * v_dir[0] + v_dir[1] * v_dir[1]), v_dir[2]); // Direção de penetração máxima (coordenadas esféricas)

			double *fB;
			fB = new double[3];
			fB[0] = 0.0;
			fB[1] = 0.0;
			fB[2] = 0.0;

			conv = true;
			sf = SupportFunction(rho, phi, *zetaB, *thetaB, fB, *patchB, conv_sup, 1, conv_total1);

			if (conv_sup) {
				double p_f[3];
				p_f[0] = 0.0;
				p_f[1] = 0.0;
				p_f[2] = 0.0;

				// Ponto da superfície B no sistema global de coordenadas 
				p_f[0] = fB[0];
				p_f[1] = fB[1];
				p_f[2] = fB[2];

				// Ponto no sistema de coordenadas da superfície A
				double *fA;
				fA = new double[3];
				fA[0] = inv_QAp(0, 0) * (p_f[0] - (*ptrx0Ap)(0, 0)) + inv_QAp(0, 1) * (p_f[1] - (*ptrx0Ap)(1, 0)) + inv_QAp(0, 2) * (p_f[2] - (*ptrx0Ap)(2, 0));
				fA[1] = inv_QAp(1, 0) * (p_f[0] - (*ptrx0Ap)(0, 0)) + inv_QAp(1, 1) * (p_f[1] - (*ptrx0Ap)(1, 0)) + inv_QAp(1, 2) * (p_f[2] - (*ptrx0Ap)(2, 0));
				fA[2] = inv_QAp(2, 0) * (p_f[0] - (*ptrx0Ap)(0, 0)) + inv_QAp(2, 1) * (p_f[1] - (*ptrx0Ap)(1, 0)) + inv_QAp(2, 2) * (p_f[2] - (*ptrx0Ap)(2, 0));

				double *point;
				point = new double[3];
				point[0] = 0.0;
				point[1] = 0.0;
				point[2] = 0.0;

				conv_total2 = GeneralNURBSPointProjection(*zetaA, *thetaA, *patchA, fA, 0);

				if (conv_total1 && conv_total2) {
					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
				}
				else {
					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
					converged = false;
				}
				delete[]fA;
				delete[]point;
			}
			else {
				converged = false;
			}

			delete nA;
			delete[]fB;
			for (int i = 0; i < dA + 1; i++)
			{
				delete[]dataA[i];
			}
			delete[]dataA;
			for (int i = 0; i < dB + 1; i++)
			{
				delete[]dataB[i];
			}
			delete[]dataB;
			delete zetaA;
			delete thetaA;
			delete zetaB;
			delete thetaB;
			delete patchA;
			delete patchB;

			return converged;
		}
		// Caso particular: plano B com partícula A
		else if (der_zeta_zeta_B < tol_small_1 /*&& der_zeta_theta_B < tol_small_1*/ && der_theta_theta_B < tol_small_1 && (der_zeta_zeta_A > tol_small_1 /*|| der_zeta_theta_A > tol_small_1*/ || der_theta_theta_A > tol_small_1) && s_freeB != 0) {

			double tol = 0.0;
			double err = 0.0;

			//Avaliação da normal do plano B
			Matrix *nB;
			nB = new Matrix(3);
			surfB->patches[*patchB]->NormalExt(ptrQBp, zetaB, thetaB, nB);

			//Estimativa inicial da direção de penetração máxima
			v_dir[0] = -(*nB)(0, 0);
			v_dir[1] = -(*nB)(1, 0);
			v_dir[2] = -(*nB)(2, 0);

			rho = atan2(v_dir[1], v_dir[0]); // Estimativa inicial da direção de penetração máxima (coordenadas esféricas)
			phi = atan2(sqrt(v_dir[0] * v_dir[0] + v_dir[1] * v_dir[1]), v_dir[2]); // Estimativa inicial da direção de penetração máxima (coordenadas esféricas)

			double *fA;
			fA = new double[3];
			fA[0] = 0.0;
			fA[1] = 0.0;
			fA[2] = 0.0;

			conv = true;

			sf = SupportFunction(rho, phi, *zetaA, *thetaA, fA, *patchA, conv_sup, 0, conv_total1);

			if (conv_sup) {
				double p_f[3];
				p_f[0] = 0.0;
				p_f[1] = 0.0;
				p_f[2] = 0.0;

				// Ponto da superfície A no sistema global de coordenadas 
				p_f[0] = fA[0];
				p_f[1] = fA[1];
				p_f[2] = fA[2];

				// Ponto no sistema de coordenadas da superfície B
				double *fB;
				fB = new double[3];

				fB[0] = inv_QBp(0, 0) * (p_f[0] - (*ptrx0Bp)(0, 0)) + inv_QBp(0, 1) * (p_f[1] - (*ptrx0Bp)(1, 0)) + inv_QBp(0, 2) * (p_f[2] - (*ptrx0Bp)(2, 0));
				fB[1] = inv_QBp(1, 0) * (p_f[0] - (*ptrx0Bp)(0, 0)) + inv_QBp(1, 1) * (p_f[1] - (*ptrx0Bp)(1, 0)) + inv_QBp(1, 2) * (p_f[2] - (*ptrx0Bp)(2, 0));
				fB[2] = inv_QBp(2, 0) * (p_f[0] - (*ptrx0Bp)(0, 0)) + inv_QBp(2, 1) * (p_f[1] - (*ptrx0Bp)(1, 0)) + inv_QBp(2, 2) * (p_f[2] - (*ptrx0Bp)(2, 0));

				double *point;
				point = new double[3];
				point[0] = 0.0;
				point[1] = 0.0;
				point[2] = 0.0;

				conv_total2 = GeneralNURBSPointProjection(*zetaB, *thetaB, *patchB, fB, 1);

				if (conv_total1 && conv_total2) {
					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
				}
				else {
					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
					converged = false;
				}
				delete[]fB;
				delete[]point;
			}
			else {
				converged = false;
			}

			delete nB;
			delete[]fA;
			for (int i = 0; i < dA + 1; i++)
			{
				delete[]dataA[i];
			}
			delete[]dataA;
			for (int i = 0; i < dB + 1; i++)
			{
				delete[]dataB[i];
			}
			delete[]dataB;
			delete zetaA;
			delete thetaA;
			delete zetaB;
			delete thetaB;
			delete patchA;
			delete patchB;

			return converged;
		}
		// Nenhuma das superfícies é um plano
		else {
			// Estimativa inicial partindo do ponto de intersecção entre as superfícies
			if (type_initial_estimate == 1) {
				// Avaliação das normais das superfícies no ponto de intersecção
				Matrix *nA;
				nA = new Matrix(3);
				Matrix *nB;
				nB = new Matrix(3);
				surfA->patches[*patchA]->NormalExt(ptrQAp, zetaA, thetaA, nA);
				surfB->patches[*patchB]->NormalExt(ptrQBp, zetaB, thetaB, nB);

				// Estimativa inicial da direção de penetração máxima
				v_dir[0] = ((*nA)(0, 0) - (*nB)(0, 0)) / sqrt(((*nA)(0, 0) - (*nB)(0, 0))*((*nA)(0, 0) - (*nB)(0, 0)) + ((*nA)(1, 0) - (*nB)(1, 0))*((*nA)(1, 0) - (*nB)(1, 0)) + ((*nA)(2, 0) - (*nB)(2, 0))*((*nA)(2, 0) - (*nB)(2, 0)));
				v_dir[1] = ((*nA)(1, 0) - (*nB)(1, 0)) / sqrt(((*nA)(0, 0) - (*nB)(0, 0))*((*nA)(0, 0) - (*nB)(0, 0)) + ((*nA)(1, 0) - (*nB)(1, 0))*((*nA)(1, 0) - (*nB)(1, 0)) + ((*nA)(2, 0) - (*nB)(2, 0))*((*nA)(2, 0) - (*nB)(2, 0)));
				v_dir[2] = ((*nA)(2, 0) - (*nB)(2, 0)) / sqrt(((*nA)(0, 0) - (*nB)(0, 0))*((*nA)(0, 0) - (*nB)(0, 0)) + ((*nA)(1, 0) - (*nB)(1, 0))*((*nA)(1, 0) - (*nB)(1, 0)) + ((*nA)(2, 0) - (*nB)(2, 0))*((*nA)(2, 0) - (*nB)(2, 0)));

				rho = atan2(v_dir[1], v_dir[0]); // Estimativa inicial da direção de penetração máxima (coordenadas esféricas)
				phi = atan2(sqrt(v_dir[0] * v_dir[0] + v_dir[1] * v_dir[1]), v_dir[2]); // Estimativa inicial da direção de penetração máxima (coordenadas esféricas)

				delete nA;
				delete nB;

			// Estimativa inicial partindo de pontos de contato anteriores
			}
			else if (type_initial_estimate == 2) {
				Matrix *pA;
				pA = new Matrix(3);
				Matrix *pB;
				pB = new Matrix(3);
				surfA->patches[*patchA]->SurfacePoint(ptrQAp, ptrx0Ap, *zetaA, *thetaA, *pA);
				surfB->patches[*patchB]->SurfacePoint(ptrQBp, ptrx0Bp, *zetaB, *thetaB, *pB);

				// Estimativa inicial da direção de penetração máxima
				v_dir[0] = ((*pA)(0, 0) - (*pB)(0, 0)) / sqrt(((*pA)(0, 0) - (*pB)(0, 0))*((*pA)(0, 0) - (*pB)(0, 0)) + ((*pA)(1, 0) - (*pB)(1, 0))*((*pA)(1, 0) - (*pB)(1, 0)) + ((*pA)(2, 0) - (*pB)(2, 0))*((*pA)(2, 0) - (*pB)(2, 0)));
				v_dir[1] = ((*pA)(1, 0) - (*pB)(1, 0)) / sqrt(((*pA)(0, 0) - (*pB)(0, 0))*((*pA)(0, 0) - (*pB)(0, 0)) + ((*pA)(1, 0) - (*pB)(1, 0))*((*pA)(1, 0) - (*pB)(1, 0)) + ((*pA)(2, 0) - (*pB)(2, 0))*((*pA)(2, 0) - (*pB)(2, 0)));
				v_dir[2] = ((*pA)(2, 0) - (*pB)(2, 0)) / sqrt(((*pA)(0, 0) - (*pB)(0, 0))*((*pA)(0, 0) - (*pB)(0, 0)) + ((*pA)(1, 0) - (*pB)(1, 0))*((*pA)(1, 0) - (*pB)(1, 0)) + ((*pA)(2, 0) - (*pB)(2, 0))*((*pA)(2, 0) - (*pB)(2, 0)));

				rho = atan2(v_dir[1], v_dir[0]); // Estimativa inicial da direção de penetração máxima (coordenadas esféricas)
				phi = atan2(sqrt(v_dir[0] * v_dir[0] + v_dir[1] * v_dir[1]), v_dir[2]); // Estimativa inicial da direção de penetração máxima (coordenadas esféricas)

				delete pA;
				delete pB;
			}

			double obj1 = 0.0;
			double obj2 = 0.0;

			//Superfície A
			double *pA_g = new double[3];
			pA_g[0] = 0.0;
			pA_g[1] = 0.0;
			pA_g[2] = 0.0;

			// Superfície B
			double *pB_g = new double[3];
			pB_g[0] = 0.0;
			pB_g[1] = 0.0;
			pB_g[2] = 0.0;

			sf = SupportFunction(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, pA_g, pB_g, *patchA, *patchB, obj1, conv_sup);

			// Gradiente e matriz hessiana
			Matrix grad(2);
			Matrix tm(2, 2);
			GradientHessianObjectiveFunctionCSO(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, *patchA, *patchB, grad, tm);

			double g[2];
			g[0] = -grad(0, 0);
			g[1] = -grad(1, 0);
			double g_n = sqrt(g[0] * g[0] + g[1] * g[1]); // Norma do gradiente

			Matrix P(2, 2);
			Matrix D(2, 2);
			fulleigen1(tm, P, D, tol_eig); // Autovalores
			double max_eig = D(0, 0);
			double min_eig = D(1, 1);
			int index = 1;
			if (D(1, 1) > max_eig) {
				min_eig = D(0, 0);
				max_eig = D(1, 1);
				index = 0;
			}

			// Tolerância no erro
			double error = pow(10, -12) * abs(max_eig);

			if (error < pow(10, -12) || isnan(error)) {
				error = pow(10, -12);
			}

			// Outras variáveis
			double delta_rho = 0.0; //Passo de rho
			double delta_phi = 0.0; //Passo de phi

			double delta_rho_b = 0.1; //Passo de rho - Newton
			double delta_phi_b = 0.1; //Passo de phi - Newton

			double delta_rho_u = 0.1; //Passo de rho - Steepest descent direction
			double delta_phi_u = 0.1; //Passo de phi - Steepest descent direction

			double step_n = sqrt(delta_rho * delta_rho + delta_phi * delta_phi); //Norma do passo

			double delta_max = 0.1; //Valor máximo para o passo no método de região de confiança

			double delta = delta_max / 10; //Estimativa inicial para o passo no método de região de confiança

			double eta = 0.25;

			double rt = 0.0; //Relação entre a redução verdadeira e a redução prevista (método de região de confiança)

			double rho_test = rho + delta_rho;
			double phi_test = phi + delta_phi;

			int patchA_test = *patchA;

			double zetaA_test = *zetaA;

			double thetaA_test = *thetaA;

			int patchB_test = *patchB;

			double zetaB_test = *zetaB;

			double thetaB_test = *thetaB;

			double *pA_g_test = new double[3];
			pA_g_test[0] = 0.0;
			pA_g_test[1] = 0.0;
			pA_g_test[2] = 0.0;

			double *pB_g_test = new double[3];
			pB_g_test[0] = 0.0;
			pB_g_test[1] = 0.0;
			pB_g_test[2] = 0.0;

			sf_test = SupportFunction(rho_test, phi_test, zetaA_test, thetaA_test, zetaB_test, thetaB_test, pA_g_test, pB_g_test, patchA_test, patchB_test, obj2, conv_sup_test);

			double qmk = obj1;

			double qmk_s = obj1 + g[0] * delta_rho + g[1] * delta_phi + 0.5 * (delta_rho * (tm(0, 0) * delta_rho + tm(0, 1) * delta_phi) + delta_phi * (tm(1, 0) * delta_rho + tm(1, 1) * delta_phi));

			double cp_rho = 0.0;
			double cp_phi = 0.0;

			double tau = 0.0;
			double gbg = 0.0;

			// Polinômio 2o grau
			double a_pol = 0.0;
			double b_pol = 0.0;
			double c_pol = 0.0;
			double x1_pol = 0.0;
			double x2_pol = 0.0;

			// Minimização em subespaço bidimensional - variáveis
			double A[2][2];
			A[0][0] = 0.0;
			A[0][1] = 0.0;
			A[1][0] = 0.0;
			A[1][1] = 0.0;

			double M[2][2];
			M[0][0] = 0.0;
			M[0][1] = 0.0;
			M[1][0] = 0.0;
			M[1][1] = 0.0;

			double w[2];
			w[0] = 0.0;
			w[1] = 0.0;

			double w_n = sqrt(w[0] * w[0] + w[1] * w[1]);

			double U[2];
			U[0] = 0.0;
			U[1] = 0.0;

			double G[2][2];
			G[0][0] = 0.0;
			G[0][1] = 0.0;
			G[1][0] = 0.0;
			G[1][1] = 0.0;

			double c1 = 0.0;
			double c2 = 0.0;
			double c3 = 0.0;
			double c4 = 0.0;
			double c5 = 0.0;

			double l = 0.0;
			double o = 0.0;

			double lf = 0.0; // Variável final da minimização em subespaço bidimensional
			double of = 0.0; // Variável final da minimização em subespaço bidimensional

			double quadr1 = 0.0; // Modelo quadrático

			double quadr2 = 0.0; // Modelo quadrático

			double alpha = 0.0;
			double gamma = 0.0;

			double q[2]; //Direção de curvatura negativa
			q[0] = 0.0;
			q[1] = 0.0;

			bool first = true;

			int iter = 1; // Iterações

			bool in = false;

			// Newton com TR
			while (sf && (g_n > error || step_n > error))
			{
				//cout << g_n << " " << iter << endl;
				//cout << step_n << " " << delta << endl;
				in = true;

				// Se a matriz hessiana é positivo definida
				if (min_eig > tol_eig)
				{
					delta_phi_b = (g[1] - g[0] * tm(1, 0) / tm(0, 0)) / (tm(1, 1) - tm(0, 1) * tm(1, 0) / tm(0, 0));
					delta_rho_b = (g[0] - tm(0, 1) * delta_phi_b) / tm(0, 0);
					step_n = sqrt(delta_rho_b * delta_rho_b + delta_phi_b * delta_phi_b);

					// O passo está dentro da região de confiança?
					// Sim
					if (step_n <= delta) {
						delta_rho = delta_rho_b;
						delta_phi = delta_phi_b;
						step_n = sqrt(delta_rho * delta_rho + delta_phi * delta_phi);
						//c = 'N';
					}
					// Não
					else {
						//Dogleg method
						gbg = g[0] * (tm(0, 0) * g[0] + tm(0, 1) * g[1]) + g[1] * (tm(1, 0) * g[0] + tm(1, 1) * g[1]);

						delta_rho_u = pow(g_n, 2) / gbg * g[0];

						delta_phi_u = pow(g_n, 2) / gbg * g[1];

						a_pol = (pow((delta_rho_b - delta_rho_u), 2) + pow((delta_phi_b - delta_phi_u), 2));
						if (a_pol < pow(10, -15)) {
							a_pol = 0;
						}
						b_pol = (2 * delta_rho_u * (delta_rho_b - delta_rho_u) - 2 * pow((delta_rho_b - delta_rho_u), 2) + 2 * delta_phi_u * (delta_phi_b - delta_phi_u) - 2 * pow((delta_phi_b - delta_phi_u), 2));
						c_pol = (pow((delta_rho_u), 2) - 2 * delta_rho_u * (delta_rho_b - delta_rho_u) + pow((delta_rho_b - delta_rho_u), 2) + pow((delta_phi_u), 2) - 2 * delta_phi_u * (delta_phi_b - delta_phi_u) + pow((delta_phi_b - delta_phi_u), 2) - delta * delta);
						x1_pol = (-b_pol + sqrt(b_pol * b_pol - 4 * a_pol * c_pol)) / (2 * a_pol);
						x2_pol = (-b_pol - sqrt(b_pol * b_pol - 4 * a_pol * c_pol)) / (2 * a_pol);

						// Raiz quadrada de número negativo: o passo pertence ao primeiro segmento de linha
						if (isnan(x1_pol) || x1_pol < 1.0 || a_pol == 0) {
							tau = sqrt(delta * delta / (delta_rho_u * delta_rho_u + delta_phi_u * delta_phi_u));
							delta_rho = tau * delta_rho_u;
							delta_phi = tau * delta_phi_u;
							step_n = delta;
							//c = 'D';
						}
						// Caso contrário, o passo pertence ao segundo segmento de linha
						else {
							if (x1_pol >= 1.0 && x1_pol <= 2.0) {
								tau = x1_pol;
							}
							else {
								tau = x2_pol;
							}
							delta_rho = delta_rho_u + (tau - 1) * (delta_rho_b - delta_rho_u);
							delta_phi = delta_phi_u + (tau - 1) * (delta_phi_b - delta_phi_u);
							step_n = delta;
							//c = 'D';
						}
					}
				}

				// Se a matriz hessiana é singular
				else if (abs(min_eig) < tol_eig || isnan(min_eig))
				{
					// Cauchy point
					cp_rho = delta / g_n * g[0];
					cp_phi = delta / g_n * g[1];

					gbg = g[0] * (tm(0, 0) * g[0] + tm(0, 1) * g[1]) + g[1] * (tm(1, 0) * g[0] + tm(1, 1)* g[1]);

					if (gbg <= 0) {
						tau = 1.0;
					}
					else {
						tau = g_n * g_n * g_n / (delta * gbg);
						if (tau > 1.0) {
							tau = 1.0;
						}
					}

					delta_rho = tau * cp_rho;
					delta_phi = tau * cp_phi;
					step_n = sqrt(delta_rho * delta_rho + delta_phi * delta_phi);
				}

				// Se a matriz hessiana é indefinida
				else {

					alpha = 1.5 * abs(min_eig);

					Matrix B(2, 2);
					B(0, 0) = tm(0, 0) + alpha;
					B(0, 1) = tm(0, 1);
					B(1, 0) = tm(1, 0);
					B(1, 1) = tm(1, 1) + alpha;

					fulleigen1(B, P, D, tol_eig);
					max_eig = D(0, 0);
					min_eig = D(1, 1);
					index = 1;
					if (D(1, 1) > max_eig) {
						min_eig = D(0, 0);
						max_eig = D(1, 1);
						index = 0;
					}

					// Se B é positivo definida
					if (min_eig > tol_eig || abs(min_eig) < tol_eig) {

						delta_phi_b = (g[1] - g[0] * B(1, 0) / B(0, 0)) / (B(1, 1) - B(0, 1) * B(1, 0) / B(0, 0));
						delta_rho_b = (g[0] - B(0, 1) * delta_phi_b) / B(0, 0);
						step_n = sqrt(delta_rho_b * delta_rho_b + delta_phi_b * delta_phi_b);

						// O passo está dentro da região de confiança?
						// Sim
						if (step_n <= delta) {
							q[0] = P(0, index);
							q[1] = P(1, index);

							gamma = -(delta_rho_b * q[0] + delta_phi_b * q[1]) + sqrt(pow((delta_rho_b * q[0] + delta_phi_b * q[1]), 2) + delta * delta - step_n * step_n);

							delta_rho = delta_rho_b + gamma * q[0];
							delta_phi = delta_phi_b + gamma * q[1];
							step_n = sqrt(delta_rho * delta_rho + delta_phi * delta_phi);
						}
						// Não
						else {
							// Subproblema do espaço bidimensional

							// -g
							A[0][0] = g[0];
							A[1][0] = g[1];

							// -step_newton
							A[0][1] = delta_rho_b;
							A[1][1] = delta_phi_b;

							M[0][0] = -A[0][0] / g_n;
							M[1][0] = -A[1][0] / g_n;

							w[0] = delta_rho_b - (delta_rho_b * (-g[0]) + delta_phi_b * (-g[1])) / (g_n * g_n) * (-g[0]);
							w[1] = delta_phi_b - (delta_rho_b * (-g[0]) + delta_phi_b * (-g[1])) / (g_n * g_n) * (-g[1]);

							w_n = sqrt(w[0] * w[0] + w[1] * w[1]);

							M[0][1] = w[0] / w_n;
							M[1][1] = w[1] / w_n;

							U[0] = M[0][0] * (-g[0]) + M[1][0] * (-g[1]);
							U[1] = M[0][1] * (-g[0]) + M[1][1] * (-g[1]);

							G[0][0] = (M[0][0] * tm(0, 0) + M[1][0] * tm(1, 0)) * M[0][0] + (M[0][0] * tm(0, 1) + M[1][0] * tm(1, 1)) * M[1][0];
							G[0][1] = (M[0][0] * tm(0, 0) + M[1][0] * tm(1, 0)) * M[0][1] + (M[0][0] * tm(0, 1) + M[1][0] * tm(1, 1)) * M[1][1];
							G[1][0] = (M[0][1] * tm(0, 0) + M[1][1] * tm(1, 0)) * M[0][0] + (M[0][1] * tm(0, 1) + M[1][1] * tm(1, 1)) * M[1][0];
							G[1][1] = (M[0][1] * tm(0, 0) + M[1][1] * tm(1, 0)) * M[0][1] + (M[0][1] * tm(0, 1) + M[1][1] * tm(1, 1)) * M[1][1];

							//Polinômio de 4o grau
							c1 = delta * (-G[0][1] * delta + U[0]);
							c2 = 2 * delta * (-(-G[0][0] + G[1][1]) * delta + U[1]);
							c3 = 6 * delta * delta * G[0][1];
							c4 = 2 * delta * ((-G[0][0] + G[1][1]) * delta + U[1]);
							c5 = -G[0][1] * delta * delta - U[0] * delta;

							// https://github.com/sasamil/Quartic

							complex<double>* solutions = solve_quartic(c2 / c1, c3 / c1, c4 / c1, c5 / c1);

							first = true;

							l = 0.0;
							o = 0.0;

							lf = 0.0;
							of = 0.0;

							for (int i = 0; i < 4; i++)
							{
								if (solutions[i].imag() != 0.0) {

								}
								else {
									l = 2 * delta * solutions[i].real() / (1 + solutions[i].real() * solutions[i].real());
									o = delta * (1 - solutions[i].real() * solutions[i].real()) / (1 + solutions[i].real() * solutions[i].real());
									if (i == 0 || first == true) {
										lf = l;
										of = o;
										//objk = new ObjectiveFunction(n1, p01, Q1, Q1_i, n2, p02, Q2, Q2_i, rho, phi, type);
										quadr1 = obj1 + U[0] * l + U[1] * o + 0.5 * (l * (l * G[0][0] + o * G[1][0]) + o * (l * G[0][1] + o * G[1][1]));
										first = false;
									}
									else {
										//objk = new ObjectiveFunction(n1, p01, Q1, Q1_i, n2, p02, Q2, Q2_i, rho, phi, type);
										quadr2 = obj1 + U[0] * l + U[1] * o + 0.5 * (l * (l * G[0][0] + o * G[1][0]) + o * (l * G[0][1] + o * G[1][1]));
										if (quadr2 < quadr1) {
											quadr1 = quadr2;
											lf = l;
											of = o;
										}
									}
								}
							}

							delta_rho = M[0][0] * lf + M[0][1] * of;
							delta_phi = M[1][0] * lf + M[1][1] * of;
							step_n = delta;
							//c = 'B';

							delete[]solutions;
						}
					}
					else {
						cout << "ERROR" << endl;
					}
				}

				rho_test = rho + delta_rho;
				phi_test = phi + delta_phi;
				conv_sup_test = true;
				sf_test = SupportFunction(rho_test, phi_test, zetaA_test, thetaA_test, zetaB_test, thetaB_test, pA_g_test, pB_g_test, patchA_test, patchB_test, obj2, conv_sup_test);
				if (conv_sup_test == false) {
					break;
				}

				qmk = obj1;
				qmk_s = obj1 + (-g[0]) * delta_rho + (-g[1]) * delta_phi + 0.5 * (delta_rho * (tm(0, 0) * delta_rho + tm(0, 1) * delta_phi) + delta_phi * (tm(1, 0) * delta_rho + tm(1, 1) * delta_phi));

				// Verificação da função modelo quadrática
				rt = (obj1 - obj2) / (qmk - qmk_s);

				if (abs(qmk - qmk_s) < pow(10, -12)) {
					rho = rho + delta_rho;
					phi = phi + delta_phi;
					conv_sup = true;
					sf = SupportFunction(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, pA_g, pB_g, *patchA, *patchB, obj1, conv_sup);
					iter++;
					break;
				}

				//if ((abs(qmk - qmk_s) < pow(10, -12) || abs(obj1 - obj2) < pow(10, -12))) {
					//rt = 1;
				//}
				//else {
					if (rt < 0.25 || isnan(rt)/*|| (objk->obj - objk_s->obj) < 0.0*/) {
						delta = 0.25 * delta;
					}
					else {
						if (rt > 0.75 && step_n == delta) {
							delta = 2 * delta;
							if (delta > delta_max) {
								delta = delta_max;
							}
						}
						else {
						}
					}
				//}


				if (rt > eta) {
					rho = rho + delta_rho;
					phi = phi + delta_phi;

					conv_sup = true;
					sf = SupportFunction(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, pA_g, pB_g, *patchA, *patchB, obj1, conv_sup);

					if (conv_sup == false) {
						break;
					}

					GradientHessianObjectiveFunctionCSO(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, *patchA, *patchB, grad, tm);

					g[0] = -grad(0, 0);
					g[1] = -grad(1, 0);

					g_n = sqrt(g[0] * g[0] + g[1] * g[1]); //Norma do gradiente

					if (isnan(g_n)) {
						cout << "polo" << endl;
					}

					fulleigen1(tm, P, D, tol_eig); //Autovalores
					max_eig = D(0, 0);
					min_eig = D(1, 1);
					index = 1;
					if (D(1, 1) > max_eig) {
						min_eig = D(0, 0);
						max_eig = D(1, 1);
						index = 0;
					}

					iter++;
					if (iter > 50) {
						break;
					}
				}
				else {
					iter++;
					if (iter > 50) {
						break;
					}
				}
			}

			converged = true;

			if (in) {
				if (iter > 50 || conv_sup == false || conv_sup_test == false) {
					converged = false;
					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
				}
				else {
					conv_sup = true;
					sf = SupportFunction(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, pA_g, pB_g, *patchA, *patchB, obj1, conv_sup);

					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
				}
			}
			else {
				if (sf == false) {
					conv_sup = false;
					converged = false;
					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
				}
				else {
					conv_sup = true;
					SupportFunction(rho, phi, *zetaA, *thetaA, *zetaB, *thetaB, pA_g, pB_g, *patchA, *patchB, obj1, conv_sup);

					(*solution)(0, 0) = *zetaA;
					(*solution)(1, 0) = *thetaA;
					(*solution)(2, 0) = *zetaB;
					(*solution)(3, 0) = *thetaB;
					(*patches)(0, 0) = *patchA;
					(*patches)(1, 0) = *patchB;
					/* (completar) */
				}
			}

			delete zetaA;
			delete thetaA;
			delete zetaB;
			delete thetaB;
			delete patchA;
			delete patchB;
			delete[]pA_g;
			delete[]pB_g;
			delete[]pA_g_test;
			delete[]pB_g_test;
			for (int i = 0; i < dA + 1; i++)
			{
				delete[]dataA[i];
			}
			delete[]dataA;
			for (int i = 0; i < dB + 1; i++)
			{
				delete[]dataB[i];
			}
			delete[]dataB;

			return converged;
		}
	}
}

int RigidNURBSSurface_RigidNURBSSurface::VerifyConvectiveRange(SSContactData * c_data, Matrix & mc, Matrix & patch)
{
	//Retornos:
	//0 - Range fisico da superficie (subpatch)
	//4 - Fora do range fisico da superficie - proximo
	//2 - Fora do range fisico da superficie - distante (nao strong) 

	//Variaveis de medicao de range de coordenadas convectivas
	double range_u1;
	double range_v1;
	double range_u2;
	double range_v2;

	int return_vector[4];
	for (int i = 0; i < 4; i++)
		return_vector[i] = 0;
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	range_u1 = perc * (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][1] - surfA->patches[patchA]->parameter_sub[subA_u][subA_v][0]);
	if ((patch(0, 0) == patchA) && (mc(0, 0) >= surfA->patches[patchA]->parameter_sub[subA_u][subA_v][0]) && (mc(0, 0) <= surfA->patches[patchA]->parameter_sub[subA_u][subA_v][1]))
		return_vector[0] = 0;
	else
	{
		if ((patch(0, 0) == patchA) && (mc(0, 0) >= (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][0] - range_u1)) && (mc(0, 0) <= (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][1] + range_u1)))
			return_vector[0] = 4;
		else
			return_vector[0] = 2;
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	range_v1 = perc * (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][4] - surfA->patches[patchA]->parameter_sub[subA_u][subA_v][3]);
	if ((patch(0, 0) == patchA) && (mc(1, 0) >= surfA->patches[patchA]->parameter_sub[subA_u][subA_v][3]) && (mc(1, 0) <= surfA->patches[patchA]->parameter_sub[subA_u][subA_v][4]))
		return_vector[0] = 0;
	else
	{
		if ((patch(1, 0) == patchA) && (mc(0, 0) >= (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][3] - range_v1)) && (mc(1, 0) <= (surfA->patches[patchA]->parameter_sub[subA_u][subA_v][4] + range_v1)))
			return_vector[1] = 4;
		else
			return_vector[1] = 2;
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	range_u2 = perc * (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][1] - surfB->patches[patchB]->parameter_sub[subB_u][subB_v][0]);
	if ((patch(1, 0) == patchB) && (mc(2, 0) >= surfB->patches[patchB]->parameter_sub[subB_u][subB_v][0]) && (mc(2, 0) <= surfB->patches[patchB]->parameter_sub[subB_u][subB_v][1]))
		return_vector[0] = 0;
	else
	{
		if ((patch(1, 0) == patchB) && (mc(2, 0) >= (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][0] - range_u2)) && (mc(2, 0) <= (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][1] + range_u2)))
			return_vector[2] = 4;
		else
			return_vector[2] = 2;
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	range_v2 = perc * perc * (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][4] - surfB->patches[patchB]->parameter_sub[subB_u][subB_v][3]);
	if ((patch(1, 0) == patchB) && (mc(3, 0) >= surfB->patches[patchB]->parameter_sub[subB_u][subB_v][3]) && (mc(3, 0) <= surfB->patches[patchB]->parameter_sub[subB_u][subB_v][4]))
		return_vector[0] = 0;
	else
	{
		if ((patch(1, 0) == patchB) && (mc(3, 0) >= (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][3] - range_v2)) && (mc(3, 0) <= (surfB->patches[patchB]->parameter_sub[subB_u][subB_v][4] + range_v2)))
			return_vector[3] = 4;
		else
			return_vector[3] = 2;
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Varredura final para retorno
	int return_value = 0;
	for (int i = 0; i < 4; i++)
	{
		if (return_value == 0)
			return_value = return_vector[i];
		else
		{
			if (return_value == 4 && return_vector[i] == 2)
				return_value = 2;
		}
	}

	return return_value;
}

//Matriz hessiana da função objetivo CSO
void RigidNURBSSurface_RigidNURBSSurface::GradientHessianObjectiveFunctionCSO(double rho, double phi, double & zetaA, double & thetaA, double & zetaB, double & thetaB, int & patchA, int & patchB, Matrix & mGrad, Matrix & mHes)
{
	/*-----------------------------------------------------------------------------------------------------------------*/
	// Derivadas dos parâmetros das superfícies em relação aos ângulos que definem a direção de busca
	// Superfície A
	double zetaA_rho = 0.0;
	double thetaA_rho = 0.0;
	double zetaA_rho_rho = 0.0;
	double thetaA_rho_rho = 0.0;
	double zetaA_phi = 0.0;
	double thetaA_phi = 0.0;
	double zetaA_phi_phi = 0.0;
	double thetaA_phi_phi = 0.0;
	double zetaA_rho_phi = 0.0;
	double thetaA_rho_phi = 0.0;

	// Superfície B
	double zetaB_rho = 0.0;
	double thetaB_rho = 0.0;
	double zetaB_rho_rho = 0.0;
	double thetaB_rho_rho = 0.0;
	double zetaB_phi = 0.0;
	double thetaB_phi = 0.0;
	double zetaB_phi_phi = 0.0;
	double thetaB_phi_phi = 0.0;
	double zetaB_rho_phi = 0.0;
	double thetaB_rho_phi = 0.0;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Degeneração
	int s_free = cd->P_0[0]->getColumns();
	int s_freeA = 0;
	int s_freeB = 0;
	for (int i = 0; i < s_free; i++)
	{
		if ((*cd->P_0[0])(0, i) == 1 || (*cd->P_0[0])(1, i) == 1) {
			s_freeA++;
		}
		if ((*cd->P_0[0])(2, i) == 1 || (*cd->P_0[0])(3, i) == 1) {
			s_freeB++;
		}
	}
	Matrix *P_0_A = new Matrix(2, s_freeA);
	for (int i = 0; i < s_freeA; i++)
	{
		(*P_0_A)(0, i) = (*cd->P_0[0])(0, i);
		(*P_0_A)(1, i) = (*cd->P_0[0])(1, i);
	}
	Matrix *P_0_B = new Matrix(2, s_freeB);
	for (int i = 0; i < s_freeB; i++)
	{
		(*P_0_B)(0, i) = (*cd->P_0[0])(2, i + s_freeA);
		(*P_0_B)(1, i) = (*cd->P_0[0])(3, i + s_freeA);
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Matrizes para a solução dos sistemas de equações lineares
	// Superfície A
	Matrix A_A(2, 2);
	Matrix A_A_deg(s_freeA, s_freeA);
	Matrix b_A(2, 1);
	Matrix b_A_deg(s_freeA, 1);
	Matrix x_A(2, 1);
	Matrix x_A_deg(s_freeA, 1);

	// Superfície B
	Matrix A_B(2, 2);
	Matrix A_B_deg(s_freeB, s_freeB);
	Matrix b_B(2, 1);
	Matrix b_B_deg(s_freeB, 1);
	Matrix x_B(2, 1);
	Matrix x_B_deg(s_freeB, 1);
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Matrizes para as derivadas das NURBS
	int dA = 3;
	Matrix** dataA;
	dataA = new Matrix*[dA + 1];
	for (int i = 0; i < dA + 1; i++)
	{
		dataA[i] = new Matrix[dA + 1];
		for (int j = 0; j < dA + 1; j++)
			dataA[i][j] = Matrix(3);
	}

	int dB = 3;
	Matrix** dataB;
	dataB = new Matrix*[dB + 1];
	for (int i = 0; i < dB + 1; i++)
	{
		dataB[i] = new Matrix[dB + 1];
		for (int j = 0; j < dB + 1; j++)
			dataB[i][j] = Matrix(3);
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Superfície A
	if (s_freeA == 0) {

	}
	else {
		int *flag = new int(0);

		// Direção local
		double *dirA;
		dirA = new double[3];
		dirA[0] = inv_QAp(0, 0) * cos(rho) * sin(phi) + inv_QAp(0, 1) * sin(rho) * sin(phi) + inv_QAp(0, 2) * cos(phi);
		dirA[1] = inv_QAp(1, 0) * cos(rho) * sin(phi) + inv_QAp(1, 1) * sin(rho) * sin(phi) + inv_QAp(1, 2) * cos(phi);
		dirA[2] = inv_QAp(2, 0) * cos(rho) * sin(phi) + inv_QAp(2, 1) * sin(rho) * sin(phi) + inv_QAp(2, 2) * cos(phi);
		// Derivadas em relação aos parâmetros das NURBS
		surfA->patches[patchA]->NURBSDerivatives(zetaA, thetaA, dataA, dA);
		if (s_freeA != 2) {
			if ((*P_0_A)(0, 0) == 1) {
				for (int i = 0; i < 4; i++)
				{
					for (int j = 1; j < 4; j++)
					{
						dataA[i][j](0, 0) = 0.0;
						dataA[i][j](1, 0) = 0.0; 
						dataA[i][j](2, 0) = 0.0;
					}
				}
			}
			else {
				for (int i = 0; i < 4; i++)
				{
					for (int j = 1; j < 4; j++)
					{
						dataA[j][i](0, 0) = 0.0;
						dataA[j][i](1, 0) = 0.0;
						dataA[j][i](2, 0) = 0.0;
					}
				}
			}
		}

		// Derivadas em relação aos ângulos
		// 1o sistema
		A_A(0, 0) = dirA[0] * dataA[2][0](0, 0) + dirA[1] * dataA[2][0](1, 0) + dirA[2] * dataA[2][0](2, 0);
		A_A(0, 1) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 0) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 1) = dirA[0] * dataA[0][2](0, 0) + dirA[1] * dataA[0][2](1, 0) + dirA[2] * dataA[0][2](2, 0);
		b_A(0, 0) = -(-inv_QAp(0, 0) * sin(rho) * sin(phi) + inv_QAp(0, 1) * cos(rho) * sin(phi)) * dataA[1][0](0, 0) - (-inv_QAp(1, 0) * sin(rho) * sin(phi) + inv_QAp(1, 1) * cos(rho) * sin(phi)) * dataA[1][0](1, 0) - (-inv_QAp(2, 0) * sin(rho) * sin(phi) + inv_QAp(2, 1) * cos(rho) * sin(phi)) * dataA[1][0](2, 0);
		b_A(1, 0) = -(-inv_QAp(0, 0) * sin(rho) * sin(phi) + inv_QAp(0, 1) * cos(rho) * sin(phi)) * dataA[0][1](0, 0) - (-inv_QAp(1, 0) * sin(rho) * sin(phi) + inv_QAp(1, 1) * cos(rho) * sin(phi)) * dataA[0][1](1, 0) - (-inv_QAp(2, 0) * sin(rho) * sin(phi) + inv_QAp(2, 1) * cos(rho) * sin(phi)) * dataA[0][1](2, 0);

		A_A_deg = transp(*P_0_A) * A_A * (*P_0_A);
		b_A_deg = transp(*P_0_A) * b_A;
		x_A_deg = fullsystem(A_A_deg, b_A_deg, flag);
		x_A = (*P_0_A) * x_A_deg;
		zetaA_rho = x_A(0, 0);
		thetaA_rho = x_A(1, 0);

		// 2o sistema
		A_A(0, 0) = dirA[0] * dataA[2][0](0, 0) + dirA[1] * dataA[2][0](1, 0) + dirA[2] * dataA[2][0](2, 0);
		A_A(0, 1) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 0) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 1) = dirA[0] * dataA[0][2](0, 0) + dirA[1] * dataA[0][2](1, 0) + dirA[2] * dataA[0][2](2, 0);
		b_A(0, 0) = -((-inv_QAp(0, 0) * cos(rho) * sin(phi) - inv_QAp(0, 1) * sin(rho) * sin(phi)) * dataA[1][0](0, 0) + 2 * (-inv_QAp(0, 0) * sin(rho) * sin(phi) + inv_QAp(0, 1) * cos(rho) * sin(phi)) * (dataA[2][0](0, 0) * zetaA_rho + dataA[1][1](0, 0) * thetaA_rho) +
			(-inv_QAp(1, 0) * cos(rho) * sin(phi) - inv_QAp(1, 1) * sin(rho) * sin(phi)) * dataA[1][0](1, 0) + 2 * (-inv_QAp(1, 0) * sin(rho) * sin(phi) + inv_QAp(1, 1) * cos(rho) * sin(phi)) * (dataA[2][0](1, 0) * zetaA_rho + dataA[1][1](1, 0) * thetaA_rho) +
			(-inv_QAp(2, 0) * cos(rho) * sin(phi) - inv_QAp(2, 1) * sin(rho) * sin(phi)) * dataA[1][0](2, 0) + 2 * (-inv_QAp(2, 0) * sin(rho) * sin(phi) + inv_QAp(2, 1) * cos(rho) * sin(phi)) * (dataA[2][0](2, 0) * zetaA_rho + dataA[1][1](2, 0) * thetaA_rho) +
			dirA[0] * (dataA[3][0](0, 0) * zetaA_rho + dataA[2][1](0, 0) * thetaA_rho)  * (zetaA_rho)+dirA[0] * (dataA[2][1](0, 0) * zetaA_rho + dataA[1][2](0, 0) * thetaA_rho) * (thetaA_rho)+
			dirA[1] * (dataA[3][0](1, 0) * zetaA_rho + dataA[2][1](1, 0) * thetaA_rho)  * (zetaA_rho)+dirA[1] * (dataA[2][1](1, 0) * zetaA_rho + dataA[1][2](1, 0) * thetaA_rho) * (thetaA_rho)+
			dirA[2] * (dataA[3][0](2, 0) * zetaA_rho + dataA[2][1](2, 0) * thetaA_rho)  * (zetaA_rho)+dirA[2] * (dataA[2][1](2, 0) * zetaA_rho + dataA[1][2](2, 0) * thetaA_rho) * (thetaA_rho));
		b_A(1, 0) = -((-inv_QAp(0, 0) * cos(rho) * sin(phi) - inv_QAp(0, 1) * sin(rho) * sin(phi)) * dataA[0][1](0, 0) + 2 * (-inv_QAp(0, 0) * sin(rho) * sin(phi) + inv_QAp(0, 1) * cos(rho) * sin(phi)) * (dataA[1][1](0, 0) * zetaA_rho + dataA[0][2](0, 0) * thetaA_rho) +
			(-inv_QAp(1, 0) * cos(rho) * sin(phi) - inv_QAp(1, 1) * sin(rho) * sin(phi)) * dataA[0][1](1, 0) + 2 * (-inv_QAp(1, 0) * sin(rho) * sin(phi) + inv_QAp(1, 1) * cos(rho) * sin(phi)) * (dataA[1][1](1, 0) * zetaA_rho + dataA[0][2](1, 0) * thetaA_rho) +
			(-inv_QAp(2, 0) * cos(rho) * sin(phi) - inv_QAp(2, 1) * sin(rho) * sin(phi)) * dataA[0][1](2, 0) + 2 * (-inv_QAp(2, 0) * sin(rho) * sin(phi) + inv_QAp(2, 1) * cos(rho) * sin(phi)) * (dataA[1][1](2, 0) * zetaA_rho + dataA[0][2](2, 0) * thetaA_rho) +
			dirA[0] * (dataA[2][1](0, 0) * zetaA_rho + dataA[1][2](0, 0) * thetaA_rho)  * (zetaA_rho)+dirA[0] * (dataA[1][2](0, 0) * zetaA_rho + dataA[0][3](0, 0) * thetaA_rho) * (thetaA_rho)+
			dirA[1] * (dataA[2][1](1, 0) * zetaA_rho + dataA[1][2](1, 0) * thetaA_rho)  * (zetaA_rho)+dirA[1] * (dataA[1][2](1, 0) * zetaA_rho + dataA[0][3](1, 0) * thetaA_rho) * (thetaA_rho)+
			dirA[2] * (dataA[2][1](2, 0) * zetaA_rho + dataA[1][2](2, 0) * thetaA_rho)  * (zetaA_rho)+dirA[2] * (dataA[1][2](2, 0) * zetaA_rho + dataA[0][3](2, 0) * thetaA_rho) * (thetaA_rho));

		A_A_deg = transp(*P_0_A) * A_A * (*P_0_A);
		b_A_deg = transp(*P_0_A) * b_A;
		x_A_deg = fullsystem(A_A_deg, b_A_deg, flag);
		x_A = (*P_0_A) * x_A_deg;
		zetaA_rho_rho = x_A(0, 0);
		thetaA_rho_rho = x_A(1, 0);

		// 3o sistema
		A_A(0, 0) = dirA[0] * dataA[2][0](0, 0) + dirA[1] * dataA[2][0](1, 0) + dirA[2] * dataA[2][0](2, 0);
		A_A(0, 1) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 0) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 1) = dirA[0] * dataA[0][2](0, 0) + dirA[1] * dataA[0][2](1, 0) + dirA[2] * dataA[0][2](2, 0);
		b_A(0, 0) = -(inv_QAp(0, 0) * cos(rho) * cos(phi) + inv_QAp(0, 1) * sin(rho) * cos(phi) - inv_QAp(0, 2) * sin(phi)) * dataA[1][0](0, 0) - (inv_QAp(1, 0) * cos(rho) * cos(phi) + inv_QAp(1, 1) * sin(rho) * cos(phi) - inv_QAp(1, 2) * sin(phi)) * dataA[1][0](1, 0) - (inv_QAp(2, 0) * cos(rho) * cos(phi) + inv_QAp(2, 1) * sin(rho) * cos(phi) - inv_QAp(2, 2) * sin(phi)) * dataA[1][0](2, 0);
		b_A(1, 0) = -(inv_QAp(0, 0) * cos(rho) * cos(phi) + inv_QAp(0, 1) * sin(rho) * cos(phi) - inv_QAp(0, 2) * sin(phi)) * dataA[0][1](0, 0) - (inv_QAp(1, 0) * cos(rho) * cos(phi) + inv_QAp(1, 1) * sin(rho) * cos(phi) - inv_QAp(1, 2) * sin(phi)) * dataA[0][1](1, 0) - (inv_QAp(2, 0) * cos(rho) * cos(phi) + inv_QAp(2, 1) * sin(rho) * cos(phi) - inv_QAp(2, 2) * sin(phi)) * dataA[0][1](2, 0);

		A_A_deg = transp(*P_0_A) * A_A * (*P_0_A);
		b_A_deg = transp(*P_0_A) * b_A;
		x_A_deg = fullsystem(A_A_deg, b_A_deg, flag);
		x_A = (*P_0_A) * x_A_deg;
		zetaA_phi = x_A(0, 0);
		thetaA_phi = x_A(1, 0);

		// 4o sistema
		A_A(0, 0) = dirA[0] * dataA[2][0](0, 0) + dirA[1] * dataA[2][0](1, 0) + dirA[2] * dataA[2][0](2, 0);
		A_A(0, 1) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 0) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 1) = dirA[0] * dataA[0][2](0, 0) + dirA[1] * dataA[0][2](1, 0) + dirA[2] * dataA[0][2](2, 0);
		b_A(0, 0) = -((-inv_QAp(0, 0) * cos(rho) * sin(phi) - inv_QAp(0, 1) * sin(rho) * sin(phi) - inv_QAp(0, 2) * cos(phi)) * dataA[1][0](0, 0) + 2 * (+inv_QAp(0, 0) * cos(rho) * cos(phi) + inv_QAp(0, 1) * sin(rho) * cos(phi) - inv_QAp(0, 2) * sin(phi)) * (dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) +
			(-inv_QAp(1, 0) * cos(rho) * sin(phi) - inv_QAp(1, 1) * sin(rho) * sin(phi) - inv_QAp(1, 2) * cos(phi)) * dataA[1][0](1, 0) + 2 * (+inv_QAp(1, 0) * cos(rho) * cos(phi) + inv_QAp(1, 1) * sin(rho) * cos(phi) - inv_QAp(1, 2) * sin(phi)) * (dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) +
			(-inv_QAp(2, 0) * cos(rho) * sin(phi) - inv_QAp(2, 1) * sin(rho) * sin(phi) - inv_QAp(2, 2) * cos(phi)) * dataA[1][0](2, 0) + 2 * (+inv_QAp(2, 0) * cos(rho) * cos(phi) + inv_QAp(2, 1) * sin(rho) * cos(phi) - inv_QAp(2, 2) * sin(phi)) * (dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) +
			dirA[0] * (dataA[3][0](0, 0) * zetaA_phi + dataA[2][1](0, 0) * thetaA_phi)  * (zetaA_phi)+dirA[0] * (dataA[2][1](0, 0) * zetaA_phi + dataA[1][2](0, 0) * thetaA_phi) * (thetaA_phi)+
			dirA[1] * (dataA[3][0](1, 0) * zetaA_phi + dataA[2][1](1, 0) * thetaA_phi)  * (zetaA_phi)+dirA[1] * (dataA[2][1](1, 0) * zetaA_phi + dataA[1][2](1, 0) * thetaA_phi) * (thetaA_phi)+
			dirA[2] * (dataA[3][0](2, 0) * zetaA_phi + dataA[2][1](2, 0) * thetaA_phi)  * (zetaA_phi)+dirA[2] * (dataA[2][1](2, 0) * zetaA_phi + dataA[1][2](2, 0) * thetaA_phi) * (thetaA_phi));
		b_A(1, 0) = -((-inv_QAp(0, 0) * cos(rho) * sin(phi) - inv_QAp(0, 1) * sin(rho) * sin(phi) - inv_QAp(0, 2) * cos(phi)) * dataA[0][1](0, 0) + 2 * (+inv_QAp(0, 0) * cos(rho) * cos(phi) + inv_QAp(0, 1) * sin(rho) * cos(phi) - inv_QAp(0, 2) * sin(phi)) * (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) +
			(-inv_QAp(1, 0) * cos(rho) * sin(phi) - inv_QAp(1, 1) * sin(rho) * sin(phi) - inv_QAp(1, 2) * cos(phi)) * dataA[0][1](1, 0) + 2 * (+inv_QAp(1, 0) * cos(rho) * cos(phi) + inv_QAp(1, 1) * sin(rho) * cos(phi) - inv_QAp(1, 2) * sin(phi)) * (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) +
			(-inv_QAp(2, 0) * cos(rho) * sin(phi) - inv_QAp(2, 1) * sin(rho) * sin(phi) - inv_QAp(2, 2) * cos(phi)) * dataA[0][1](2, 0) + 2 * (+inv_QAp(2, 0) * cos(rho) * cos(phi) + inv_QAp(2, 1) * sin(rho) * cos(phi) - inv_QAp(2, 2) * sin(phi)) * (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) +
			dirA[0] * (dataA[2][1](0, 0) * zetaA_phi + dataA[1][2](0, 0) * thetaA_phi)  * (zetaA_phi)+dirA[0] * (dataA[1][2](0, 0) * zetaA_phi + dataA[0][3](0, 0) * thetaA_phi) * (thetaA_phi)+
			dirA[1] * (dataA[2][1](1, 0) * zetaA_phi + dataA[1][2](1, 0) * thetaA_phi)  * (zetaA_phi)+dirA[1] * (dataA[1][2](1, 0) * zetaA_phi + dataA[0][3](1, 0) * thetaA_phi) * (thetaA_phi)+
			dirA[2] * (dataA[2][1](2, 0) * zetaA_phi + dataA[1][2](2, 0) * thetaA_phi)  * (zetaA_phi)+dirA[2] * (dataA[1][2](2, 0) * zetaA_phi + dataA[0][3](2, 0) * thetaA_phi) * (thetaA_phi));

		A_A_deg = transp(*P_0_A) * A_A * (*P_0_A);
		b_A_deg = transp(*P_0_A) * b_A;
		x_A_deg = fullsystem(A_A_deg, b_A_deg, flag);
		x_A = (*P_0_A) * x_A_deg;
		zetaA_phi_phi = x_A(0, 0);
		thetaA_phi_phi = x_A(1, 0);

		// 5o sistema
		A_A(0, 0) = dirA[0] * dataA[2][0](0, 0) + dirA[1] * dataA[2][0](1, 0) + dirA[2] * dataA[2][0](2, 0);
		A_A(0, 1) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 0) = dirA[0] * dataA[1][1](0, 0) + dirA[1] * dataA[1][1](1, 0) + dirA[2] * dataA[1][1](2, 0);
		A_A(1, 1) = dirA[0] * dataA[0][2](0, 0) + dirA[1] * dataA[0][2](1, 0) + dirA[2] * dataA[0][2](2, 0);
		b_A(0, 0) = -((-inv_QAp(0, 0) * sin(rho) * cos(phi) + inv_QAp(0, 1) * cos(rho) * cos(phi)) * dataA[1][0](0, 0) + (+inv_QAp(0, 0) * cos(rho) * cos(phi) + inv_QAp(0, 1) * sin(rho) * cos(phi) - inv_QAp(0, 2) * sin(phi)) * (dataA[2][0](0, 0) * zetaA_rho + dataA[1][1](0, 0) * thetaA_rho) + (-inv_QAp(0, 0) * sin(rho) * sin(phi) + inv_QAp(0, 1) * cos(rho) * sin(phi)) * (dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) +
			(-inv_QAp(1, 0) * sin(rho) * cos(phi) + inv_QAp(1, 1) * cos(rho) * cos(phi)) * dataA[1][0](1, 0) + (+inv_QAp(1, 0) * cos(rho) * cos(phi) + inv_QAp(1, 1) * sin(rho) * cos(phi) - inv_QAp(1, 2) * sin(phi)) * (dataA[2][0](1, 0) * zetaA_rho + dataA[1][1](1, 0) * thetaA_rho) + (-inv_QAp(1, 0) * sin(rho) * sin(phi) + inv_QAp(1, 1) * cos(rho) * sin(phi)) * (dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) +
			(-inv_QAp(2, 0) * sin(rho) * cos(phi) + inv_QAp(2, 1) * cos(rho) * cos(phi)) * dataA[1][0](2, 0) + (+inv_QAp(2, 0) * cos(rho) * cos(phi) + inv_QAp(2, 1) * sin(rho) * cos(phi) - inv_QAp(2, 2) * sin(phi)) * (dataA[2][0](2, 0) * zetaA_rho + dataA[1][1](2, 0) * thetaA_rho) + (-inv_QAp(2, 0) * sin(rho) * sin(phi) + inv_QAp(2, 1) * cos(rho) * sin(phi)) * (dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) +
			dirA[0] * (dataA[3][0](0, 0) * zetaA_phi + dataA[2][1](0, 0) * thetaA_phi)  * (zetaA_rho)+dirA[0] * (dataA[2][1](0, 0) * zetaA_phi + dataA[1][2](0, 0) * thetaA_phi) * (thetaA_rho)+
			dirA[1] * (dataA[3][0](1, 0) * zetaA_phi + dataA[2][1](1, 0) * thetaA_phi)  * (zetaA_rho)+dirA[1] * (dataA[2][1](1, 0) * zetaA_phi + dataA[1][2](1, 0) * thetaA_phi) * (thetaA_rho)+
			dirA[2] * (dataA[3][0](2, 0) * zetaA_phi + dataA[2][1](2, 0) * thetaA_phi)  * (zetaA_rho)+dirA[2] * (dataA[2][1](2, 0) * zetaA_phi + dataA[1][2](2, 0) * thetaA_phi) * (thetaA_rho));
		b_A(1, 0) = -((-inv_QAp(0, 0) * sin(rho) * cos(phi) + inv_QAp(0, 1) * cos(rho) * cos(phi)) * dataA[0][1](0, 0) + (+inv_QAp(0, 0) * cos(rho) * cos(phi) + inv_QAp(0, 1) * sin(rho) * cos(phi) - inv_QAp(0, 2) * sin(phi)) * (dataA[1][1](0, 0) * zetaA_rho + dataA[0][2](0, 0) * thetaA_rho) + (-inv_QAp(0, 0) * sin(rho) * sin(phi) + inv_QAp(0, 1) * cos(rho) * sin(phi)) * (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) +
			(-inv_QAp(1, 0) * sin(rho) * cos(phi) + inv_QAp(1, 1) * cos(rho) * cos(phi)) * dataA[0][1](1, 0) + (+inv_QAp(1, 0) * cos(rho) * cos(phi) + inv_QAp(1, 1) * sin(rho) * cos(phi) - inv_QAp(1, 2) * sin(phi)) * (dataA[1][1](1, 0) * zetaA_rho + dataA[0][2](1, 0) * thetaA_rho) + (-inv_QAp(1, 0) * sin(rho) * sin(phi) + inv_QAp(1, 1) * cos(rho) * sin(phi)) * (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) +
			(-inv_QAp(2, 0) * sin(rho) * cos(phi) + inv_QAp(2, 1) * cos(rho) * cos(phi)) * dataA[0][1](2, 0) + (+inv_QAp(2, 0) * cos(rho) * cos(phi) + inv_QAp(2, 1) * sin(rho) * cos(phi) - inv_QAp(2, 2) * sin(phi)) * (dataA[1][1](2, 0) * zetaA_rho + dataA[0][2](2, 0) * thetaA_rho) + (-inv_QAp(2, 0) * sin(rho) * sin(phi) + inv_QAp(2, 1) * cos(rho) * sin(phi)) * (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) +
			dirA[0] * (dataA[2][1](0, 0) * zetaA_phi + dataA[1][2](0, 0) * thetaA_phi)  * (zetaA_rho)+dirA[0] * (dataA[1][2](0, 0) * zetaA_phi + dataA[0][3](0, 0) * thetaA_phi) * (thetaA_rho)+
			dirA[1] * (dataA[2][1](1, 0) * zetaA_phi + dataA[1][2](1, 0) * thetaA_phi)  * (zetaA_rho)+dirA[1] * (dataA[1][2](1, 0) * zetaA_phi + dataA[0][3](1, 0) * thetaA_phi) * (thetaA_rho)+
			dirA[2] * (dataA[2][1](2, 0) * zetaA_phi + dataA[1][2](2, 0) * thetaA_phi)  * (zetaA_rho)+dirA[2] * (dataA[1][2](2, 0) * zetaA_phi + dataA[0][3](2, 0) * thetaA_phi) * (thetaA_rho));

		A_A_deg = transp(*P_0_A) * A_A * (*P_0_A);
		b_A_deg = transp(*P_0_A) * b_A;
		x_A_deg = fullsystem(A_A_deg, b_A_deg, flag);
		x_A = (*P_0_A) * x_A_deg;
		zetaA_rho_phi = x_A(0, 0);
		thetaA_rho_phi = x_A(1, 0);

		delete flag;
		delete[]dirA;
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Superfície B
	if (s_freeB == 0) {

	}
	else {
		int *flag = new int(0);
		// Direção local
		double *dirB;
		dirB = new double[3];
		dirB[0] = -(inv_QBp(0, 0) * cos(rho) * sin(phi) + inv_QBp(0, 1) * sin(rho) * sin(phi) + inv_QBp(0, 2) * cos(phi));
		dirB[1] = -(inv_QBp(1, 0) * cos(rho) * sin(phi) + inv_QBp(1, 1) * sin(rho) * sin(phi) + inv_QBp(1, 2) * cos(phi));
		dirB[2] = -(inv_QBp(2, 0) * cos(rho) * sin(phi) + inv_QBp(2, 1) * sin(rho) * sin(phi) + inv_QBp(2, 2) * cos(phi));

		// Derivadas em relação aos parâmetros das NURBS
		surfB->patches[patchB]->NURBSDerivatives(zetaB, thetaB, dataB, dB);
		if (s_freeB != 2) {
			if ((*P_0_B)(0, 0) == 1) {
				for (int i = 0; i < 4; i++)
				{
					for (int j = 1; j < 4; j++)
					{
						dataB[i][j](0, 0) = 0.0;
						dataB[i][j](1, 0) = 0.0;
						dataB[i][j](2, 0) = 0.0;
					}
				}
			}
			else {
				for (int i = 0; i < 4; i++)
				{
					for (int j = 1; j < 4; j++)
					{
						dataB[j][i](0, 0) = 0.0;
						dataB[j][i](1, 0) = 0.0;
						dataB[j][i](2, 0) = 0.0;
					}
				}
			}
		}

		// Derivadas em relação aos ângulos
		// 1o sistema
		A_B(0, 0) = dirB[0] * dataB[2][0](0, 0) + dirB[1] * dataB[2][0](1, 0) + dirB[2] * dataB[2][0](2, 0);
		A_B(0, 1) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 0) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 1) = dirB[0] * dataB[0][2](0, 0) + dirB[1] * dataB[0][2](1, 0) + dirB[2] * dataB[0][2](2, 0);
		b_B(0, 0) = +(-inv_QBp(0, 0) * sin(rho) * sin(phi) + inv_QBp(0, 1) * cos(rho) * sin(phi)) * dataB[1][0](0, 0) + (-inv_QBp(1, 0) * sin(rho) * sin(phi) + inv_QBp(1, 1) * cos(rho) * sin(phi)) * dataB[1][0](1, 0) + (-inv_QBp(2, 0) * sin(rho) * sin(phi) + inv_QBp(2, 1) * cos(rho) * sin(phi)) * dataB[1][0](2, 0);
		b_B(1, 0) = +(-inv_QBp(0, 0) * sin(rho) * sin(phi) + inv_QBp(0, 1) * cos(rho) * sin(phi)) * dataB[0][1](0, 0) + (-inv_QBp(1, 0) * sin(rho) * sin(phi) + inv_QBp(1, 1) * cos(rho) * sin(phi)) * dataB[0][1](1, 0) + (-inv_QBp(2, 0) * sin(rho) * sin(phi) + inv_QBp(2, 1) * cos(rho) * sin(phi)) * dataB[0][1](2, 0);

		A_B_deg = transp(*P_0_B) * A_B * (*P_0_B);
		b_B_deg = transp(*P_0_B) * b_B;
		x_B_deg = fullsystem(A_B_deg, b_B_deg, flag);
		x_B = (*P_0_B) * x_B_deg;
		zetaB_rho = x_B(0, 0);
		thetaB_rho = x_B(1, 0);

		// 2o sistema
		A_B(0, 0) = dirB[0] * dataB[2][0](0, 0) + dirB[1] * dataB[2][0](1, 0) + dirB[2] * dataB[2][0](2, 0);
		A_B(0, 1) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 0) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 1) = dirB[0] * dataB[0][2](0, 0) + dirB[1] * dataB[0][2](1, 0) + dirB[2] * dataB[0][2](2, 0);
		b_B(0, 0) = -(-(-inv_QBp(0, 0) * cos(rho) * sin(phi) - inv_QBp(0, 1) * sin(rho) * sin(phi)) * dataB[1][0](0, 0) - 2 * (-inv_QBp(0, 0) * sin(rho) * sin(phi) + inv_QBp(0, 1) * cos(rho) * sin(phi)) * (dataB[2][0](0, 0) * zetaB_rho + dataB[1][1](0, 0) * thetaB_rho) -
			(-inv_QBp(1, 0) * cos(rho) * sin(phi) - inv_QBp(1, 1) * sin(rho) * sin(phi)) * dataB[1][0](1, 0) - 2 * (-inv_QBp(1, 0) * sin(rho) * sin(phi) + inv_QBp(1, 1) * cos(rho) * sin(phi)) * (dataB[2][0](1, 0) * zetaB_rho + dataB[1][1](1, 0) * thetaB_rho) -
			(-inv_QBp(2, 0) * cos(rho) * sin(phi) - inv_QBp(2, 1) * sin(rho) * sin(phi)) * dataB[1][0](2, 0) - 2 * (-inv_QBp(2, 0) * sin(rho) * sin(phi) + inv_QBp(2, 1) * cos(rho) * sin(phi)) * (dataB[2][0](2, 0) * zetaB_rho + dataB[1][1](2, 0) * thetaB_rho) +
			dirB[0] * (dataB[3][0](0, 0) * zetaB_rho + dataB[2][1](0, 0) * thetaB_rho)  * (zetaB_rho)+dirB[0] * (dataB[2][1](0, 0) * zetaB_rho + dataB[1][2](0, 0) * thetaB_rho) * (thetaB_rho)+
			dirB[1] * (dataB[3][0](1, 0) * zetaB_rho + dataB[2][1](1, 0) * thetaB_rho)  * (zetaB_rho)+dirB[1] * (dataB[2][1](1, 0) * zetaB_rho + dataB[1][2](1, 0) * thetaB_rho) * (thetaB_rho)+
			dirB[2] * (dataB[3][0](2, 0) * zetaB_rho + dataB[2][1](2, 0) * thetaB_rho)  * (zetaB_rho)+dirB[2] * (dataB[2][1](2, 0) * zetaB_rho + dataB[1][2](2, 0) * thetaB_rho) * (thetaB_rho));
		b_B(1, 0) = -(-(-inv_QBp(0, 0) * cos(rho) * sin(phi) - inv_QBp(0, 1) * sin(rho) * sin(phi)) * dataB[0][1](0, 0) - 2 * (-inv_QBp(0, 0) * sin(rho) * sin(phi) + inv_QBp(0, 1) * cos(rho) * sin(phi)) * (dataB[1][1](0, 0) * zetaB_rho + dataB[0][2](0, 0) * thetaB_rho) -
			(-inv_QBp(1, 0) * cos(rho) * sin(phi) - inv_QBp(1, 1) * sin(rho) * sin(phi)) * dataB[0][1](1, 0) - 2 * (-inv_QBp(1, 0) * sin(rho) * sin(phi) + inv_QBp(1, 1) * cos(rho) * sin(phi)) * (dataB[1][1](1, 0) * zetaB_rho + dataB[0][2](1, 0) * thetaB_rho) -
			(-inv_QBp(2, 0) * cos(rho) * sin(phi) - inv_QBp(2, 1) * sin(rho) * sin(phi)) * dataB[0][1](2, 0) - 2 * (-inv_QBp(2, 0) * sin(rho) * sin(phi) + inv_QBp(2, 1) * cos(rho) * sin(phi)) * (dataB[1][1](2, 0) * zetaB_rho + dataB[0][2](2, 0) * thetaB_rho) +
			dirB[0] * (dataB[2][1](0, 0) * zetaB_rho + dataB[1][2](0, 0) * thetaB_rho)  * (zetaB_rho)+dirB[0] * (dataB[1][2](0, 0) * zetaB_rho + dataB[0][3](0, 0) * thetaB_rho) * (thetaB_rho)+
			dirB[1] * (dataB[2][1](1, 0) * zetaB_rho + dataB[1][2](1, 0) * thetaB_rho)  * (zetaB_rho)+dirB[1] * (dataB[1][2](1, 0) * zetaB_rho + dataB[0][3](1, 0) * thetaB_rho) * (thetaB_rho)+
			dirB[2] * (dataB[2][1](2, 0) * zetaB_rho + dataB[1][2](2, 0) * thetaB_rho)  * (zetaB_rho)+dirB[2] * (dataB[1][2](2, 0) * zetaB_rho + dataB[0][3](2, 0) * thetaB_rho) * (thetaB_rho));

		A_B_deg = transp(*P_0_B) * A_B * (*P_0_B);
		b_B_deg = transp(*P_0_B) * b_B;
		x_B_deg = fullsystem(A_B_deg, b_B_deg, flag);
		x_B = (*P_0_B) * x_B_deg;
		zetaB_rho_rho = x_B(0, 0);
		thetaB_rho_rho = x_B(1, 0);

		// 3o sistema
		A_B(0, 0) = dirB[0] * dataB[2][0](0, 0) + dirB[1] * dataB[2][0](1, 0) + dirB[2] * dataB[2][0](2, 0);
		A_B(0, 1) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 0) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 1) = dirB[0] * dataB[0][2](0, 0) + dirB[1] * dataB[0][2](1, 0) + dirB[2] * dataB[0][2](2, 0);
		b_B(0, 0) = +(inv_QBp(0, 0) * cos(rho) * cos(phi) + inv_QBp(0, 1) * sin(rho) * cos(phi) - inv_QBp(0, 2) * sin(phi)) * dataB[1][0](0, 0) + (inv_QBp(1, 0) * cos(rho) * cos(phi) + inv_QBp(1, 1) * sin(rho) * cos(phi) - inv_QBp(1, 2) * sin(phi)) * dataB[1][0](1, 0) + (inv_QBp(2, 0) * cos(rho) * cos(phi) + inv_QBp(2, 1) * sin(rho) * cos(phi) - inv_QBp(2, 2) * sin(phi)) * dataB[1][0](2, 0);
		b_B(1, 0) = +(inv_QBp(0, 0) * cos(rho) * cos(phi) + inv_QBp(0, 1) * sin(rho) * cos(phi) - inv_QBp(0, 2) * sin(phi)) * dataB[0][1](0, 0) + (inv_QBp(1, 0) * cos(rho) * cos(phi) + inv_QBp(1, 1) * sin(rho) * cos(phi) - inv_QBp(1, 2) * sin(phi)) * dataB[0][1](1, 0) + (inv_QBp(2, 0) * cos(rho) * cos(phi) + inv_QBp(2, 1) * sin(rho) * cos(phi) - inv_QBp(2, 2) * sin(phi)) * dataB[0][1](2, 0);

		A_B_deg = transp(*P_0_B) * A_B * (*P_0_B);
		b_B_deg = transp(*P_0_B) * b_B;
		x_B_deg = fullsystem(A_B_deg, b_B_deg, flag);
		x_B = (*P_0_B) * x_B_deg;
		zetaB_phi = x_B(0, 0);
		thetaB_phi = x_B(1, 0);

		// 4o sistema
		A_B(0, 0) = dirB[0] * dataB[2][0](0, 0) + dirB[1] * dataB[2][0](1, 0) + dirB[2] * dataB[2][0](2, 0);
		A_B(0, 1) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 0) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 1) = dirB[0] * dataB[0][2](0, 0) + dirB[1] * dataB[0][2](1, 0) + dirB[2] * dataB[0][2](2, 0);
		b_B(0, 0) = -(-(-inv_QBp(0, 0) * cos(rho) * sin(phi) - inv_QBp(0, 1) * sin(rho) * sin(phi) - inv_QBp(0, 2) * cos(phi)) * dataB[1][0](0, 0) - 2 * (+inv_QBp(0, 0) * cos(rho) * cos(phi) + inv_QBp(0, 1) * sin(rho) * cos(phi) - inv_QBp(0, 2) * sin(phi)) * (dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) -
			(-inv_QBp(1, 0) * cos(rho) * sin(phi) - inv_QBp(1, 1) * sin(rho) * sin(phi) - inv_QBp(1, 2) * cos(phi)) * dataB[1][0](1, 0) - 2 * (+inv_QBp(1, 0) * cos(rho) * cos(phi) + inv_QBp(1, 1) * sin(rho) * cos(phi) - inv_QBp(1, 2) * sin(phi)) * (dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) -
			(-inv_QBp(2, 0) * cos(rho) * sin(phi) - inv_QBp(2, 1) * sin(rho) * sin(phi) - inv_QBp(2, 2) * cos(phi)) * dataB[1][0](2, 0) - 2 * (+inv_QBp(2, 0) * cos(rho) * cos(phi) + inv_QBp(2, 1) * sin(rho) * cos(phi) - inv_QBp(2, 2) * sin(phi)) * (dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) +
			dirB[0] * (dataB[3][0](0, 0) * zetaB_phi + dataB[2][1](0, 0) * thetaB_phi)  * (zetaB_phi)+dirB[0] * (dataB[2][1](0, 0) * zetaB_phi + dataB[1][2](0, 0) * thetaB_phi) * (thetaB_phi)+
			dirB[1] * (dataB[3][0](1, 0) * zetaB_phi + dataB[2][1](1, 0) * thetaB_phi)  * (zetaB_phi)+dirB[1] * (dataB[2][1](1, 0) * zetaB_phi + dataB[1][2](1, 0) * thetaB_phi) * (thetaB_phi)+
			dirB[2] * (dataB[3][0](2, 0) * zetaB_phi + dataB[2][1](2, 0) * thetaB_phi)  * (zetaB_phi)+dirB[2] * (dataB[2][1](2, 0) * zetaB_phi + dataB[1][2](2, 0) * thetaB_phi) * (thetaB_phi));
		b_B(1, 0) = -(-(-inv_QBp(0, 0) * cos(rho) * sin(phi) - inv_QBp(0, 1) * sin(rho) * sin(phi) - inv_QBp(0, 2) * cos(phi)) * dataB[0][1](0, 0) - 2 * (+inv_QBp(0, 0) * cos(rho) * cos(phi) + inv_QBp(0, 1) * sin(rho) * cos(phi) - inv_QBp(0, 2) * sin(phi)) * (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) -
			(-inv_QBp(1, 0) * cos(rho) * sin(phi) - inv_QBp(1, 1) * sin(rho) * sin(phi) - inv_QBp(1, 2) * cos(phi)) * dataB[0][1](1, 0) - 2 * (+inv_QBp(1, 0) * cos(rho) * cos(phi) + inv_QBp(1, 1) * sin(rho) * cos(phi) - inv_QBp(1, 2) * sin(phi)) * (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) -
			(-inv_QBp(2, 0) * cos(rho) * sin(phi) - inv_QBp(2, 1) * sin(rho) * sin(phi) - inv_QBp(2, 2) * cos(phi)) * dataB[0][1](2, 0) - 2 * (+inv_QBp(2, 0) * cos(rho) * cos(phi) + inv_QBp(2, 1) * sin(rho) * cos(phi) - inv_QBp(2, 2) * sin(phi)) * (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) +
			dirB[0] * (dataB[2][1](0, 0) * zetaB_phi + dataB[1][2](0, 0) * thetaB_phi)  * (zetaB_phi)+dirB[0] * (dataB[1][2](0, 0) * zetaB_phi + dataB[0][3](0, 0) * thetaB_phi) * (thetaB_phi)+
			dirB[1] * (dataB[2][1](1, 0) * zetaB_phi + dataB[1][2](1, 0) * thetaB_phi)  * (zetaB_phi)+dirB[1] * (dataB[1][2](1, 0) * zetaB_phi + dataB[0][3](1, 0) * thetaB_phi) * (thetaB_phi)+
			dirB[2] * (dataB[2][1](2, 0) * zetaB_phi + dataB[1][2](2, 0) * thetaB_phi)  * (zetaB_phi)+dirB[2] * (dataB[1][2](2, 0) * zetaB_phi + dataB[0][3](2, 0) * thetaB_phi) * (thetaB_phi));

		A_B_deg = transp(*P_0_B) * A_B * (*P_0_B);
		b_B_deg = transp(*P_0_B) * b_B;
		x_B_deg = fullsystem(A_B_deg, b_B_deg, flag);
		x_B = (*P_0_B) * x_B_deg;
		zetaB_phi_phi = x_B(0, 0);
		thetaB_phi_phi = x_B(1, 0);

		// 5o sistema
		A_B(0, 0) = dirB[0] * dataB[2][0](0, 0) + dirB[1] * dataB[2][0](1, 0) + dirB[2] * dataB[2][0](2, 0);
		A_B(0, 1) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 0) = dirB[0] * dataB[1][1](0, 0) + dirB[1] * dataB[1][1](1, 0) + dirB[2] * dataB[1][1](2, 0);
		A_B(1, 1) = dirB[0] * dataB[0][2](0, 0) + dirB[1] * dataB[0][2](1, 0) + dirB[2] * dataB[0][2](2, 0);
		b_B(0, 0) = -(-(-inv_QBp(0, 0) * sin(rho) * cos(phi) + inv_QBp(0, 1) * cos(rho) * cos(phi)) * dataB[1][0](0, 0) - (+inv_QBp(0, 0) * cos(rho) * cos(phi) + inv_QBp(0, 1) * sin(rho) * cos(phi) - inv_QBp(0, 2) * sin(phi)) * (dataB[2][0](0, 0) * zetaB_rho + dataB[1][1](0, 0) * thetaB_rho) - (-inv_QBp(0, 0) * sin(rho) * sin(phi) + inv_QBp(0, 1) * cos(rho) * sin(phi)) * (dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) -
			(-inv_QBp(1, 0) * sin(rho) * cos(phi) + inv_QBp(1, 1) * cos(rho) * cos(phi)) * dataB[1][0](1, 0) - (+inv_QBp(1, 0) * cos(rho) * cos(phi) + inv_QBp(1, 1) * sin(rho) * cos(phi) - inv_QBp(1, 2) * sin(phi)) * (dataB[2][0](1, 0) * zetaB_rho + dataB[1][1](1, 0) * thetaB_rho) - (-inv_QBp(1, 0) * sin(rho) * sin(phi) + inv_QBp(1, 1) * cos(rho) * sin(phi)) * (dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) -
			(-inv_QBp(2, 0) * sin(rho) * cos(phi) + inv_QBp(2, 1) * cos(rho) * cos(phi)) * dataB[1][0](2, 0) - (+inv_QBp(2, 0) * cos(rho) * cos(phi) + inv_QBp(2, 1) * sin(rho) * cos(phi) - inv_QBp(2, 2) * sin(phi)) * (dataB[2][0](2, 0) * zetaB_rho + dataB[1][1](2, 0) * thetaB_rho) - (-inv_QBp(2, 0) * sin(rho) * sin(phi) + inv_QBp(2, 1) * cos(rho) * sin(phi)) * (dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) +
			dirB[0] * (dataB[3][0](0, 0) * zetaB_phi + dataB[2][1](0, 0) * thetaB_phi)  * (zetaB_rho)+dirB[0] * (dataB[2][1](0, 0) * zetaB_phi + dataB[1][2](0, 0) * thetaB_phi) * (thetaB_rho)+
			dirB[1] * (dataB[3][0](1, 0) * zetaB_phi + dataB[2][1](1, 0) * thetaB_phi)  * (zetaB_rho)+dirB[1] * (dataB[2][1](1, 0) * zetaB_phi + dataB[1][2](1, 0) * thetaB_phi) * (thetaB_rho)+
			dirB[2] * (dataB[3][0](2, 0) * zetaB_phi + dataB[2][1](2, 0) * thetaB_phi)  * (zetaB_rho)+dirB[2] * (dataB[2][1](2, 0) * zetaB_phi + dataB[1][2](2, 0) * thetaB_phi) * (thetaB_rho));
		b_B(1, 0) = -(-(-inv_QBp(0, 0) * sin(rho) * cos(phi) + inv_QBp(0, 1) * cos(rho) * cos(phi)) * dataB[0][1](0, 0) - (+inv_QBp(0, 0) * cos(rho) * cos(phi) + inv_QBp(0, 1) * sin(rho) * cos(phi) - inv_QBp(0, 2) * sin(phi)) * (dataB[1][1](0, 0) * zetaB_rho + dataB[0][2](0, 0) * thetaB_rho) - (-inv_QBp(0, 0) * sin(rho) * sin(phi) + inv_QBp(0, 1) * cos(rho) * sin(phi)) * (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) -
			(-inv_QBp(1, 0) * sin(rho) * cos(phi) + inv_QBp(1, 1) * cos(rho) * cos(phi)) * dataB[0][1](1, 0) - (+inv_QBp(1, 0) * cos(rho) * cos(phi) + inv_QBp(1, 1) * sin(rho) * cos(phi) - inv_QBp(1, 2) * sin(phi)) * (dataB[1][1](1, 0) * zetaB_rho + dataB[0][2](1, 0) * thetaB_rho) - (-inv_QBp(1, 0) * sin(rho) * sin(phi) + inv_QBp(1, 1) * cos(rho) * sin(phi)) * (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) -
			(-inv_QBp(2, 0) * sin(rho) * cos(phi) + inv_QBp(2, 1) * cos(rho) * cos(phi)) * dataB[0][1](2, 0) - (+inv_QBp(2, 0) * cos(rho) * cos(phi) + inv_QBp(2, 1) * sin(rho) * cos(phi) - inv_QBp(2, 2) * sin(phi)) * (dataB[1][1](2, 0) * zetaB_rho + dataB[0][2](2, 0) * thetaB_rho) - (-inv_QBp(2, 0) * sin(rho) * sin(phi) + inv_QBp(2, 1) * cos(rho) * sin(phi)) * (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) +
			dirB[0] * (dataB[2][1](0, 0) * zetaB_phi + dataB[1][2](0, 0) * thetaB_phi)  * (zetaB_rho)+dirB[0] * (dataB[1][2](0, 0) * zetaB_phi + dataB[0][3](0, 0) * thetaB_phi) * (thetaB_rho)+
			dirB[1] * (dataB[2][1](1, 0) * zetaB_phi + dataB[1][2](1, 0) * thetaB_phi)  * (zetaB_rho)+dirB[1] * (dataB[1][2](1, 0) * zetaB_phi + dataB[0][3](1, 0) * thetaB_phi) * (thetaB_rho)+
			dirB[2] * (dataB[2][1](2, 0) * zetaB_phi + dataB[1][2](2, 0) * thetaB_phi)  * (zetaB_rho)+dirB[2] * (dataB[1][2](2, 0) * zetaB_phi + dataB[0][3](2, 0) * thetaB_phi) * (thetaB_rho));

		A_B_deg = transp(*P_0_B) * A_B * (*P_0_B);
		b_B_deg = transp(*P_0_B) * b_B;
		x_B_deg = fullsystem(A_B_deg, b_B_deg, flag);
		x_B = (*P_0_B) * x_B_deg;
		zetaB_rho_phi = x_B(0, 0);
		thetaB_rho_phi = x_B(1, 0);

		delete flag;
		delete[]dirB;
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Gradiente e matriz hessiana

	mGrad(0, 0) = 2 * ((*ptrx0Ap)(0, 0) + (*ptrQAp)(0, 0) * dataA[0][0](0, 0) + (*ptrQAp)(0, 1) * dataA[0][0](1, 0) + (*ptrQAp)(0, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(0, 0) - (*ptrQBp)(0, 0) * dataB[0][0](0, 0) - (*ptrQBp)(0, 1) * dataB[0][0](1, 0) - (*ptrQBp)(0, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(1, 0) + (*ptrQAp)(1, 0) * dataA[0][0](0, 0) + (*ptrQAp)(1, 1) * dataA[0][0](1, 0) + (*ptrQAp)(1, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(1, 0) - (*ptrQBp)(1, 0) * dataB[0][0](0, 0) - (*ptrQBp)(1, 1) * dataB[0][0](1, 0) - (*ptrQBp)(1, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(2, 0) + (*ptrQAp)(2, 0) * dataA[0][0](0, 0) + (*ptrQAp)(2, 1) * dataA[0][0](1, 0) + (*ptrQAp)(2, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(2, 0) - (*ptrQBp)(2, 0) * dataB[0][0](0, 0) - (*ptrQBp)(2, 1) * dataB[0][0](1, 0) - (*ptrQBp)(2, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho));

	mGrad(1, 0) = 2 * ((*ptrx0Ap)(0, 0) + (*ptrQAp)(0, 0) * dataA[0][0](0, 0) + (*ptrQAp)(0, 1) * dataA[0][0](1, 0) + (*ptrQAp)(0, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(0, 0) - (*ptrQBp)(0, 0) * dataB[0][0](0, 0) - (*ptrQBp)(0, 1) * dataB[0][0](1, 0) - (*ptrQBp)(0, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) +
		2 * ((*ptrx0Ap)(1, 0) + (*ptrQAp)(1, 0) * dataA[0][0](0, 0) + (*ptrQAp)(1, 1) * dataA[0][0](1, 0) + (*ptrQAp)(1, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(1, 0) - (*ptrQBp)(1, 0) * dataB[0][0](0, 0) - (*ptrQBp)(1, 1) * dataB[0][0](1, 0) - (*ptrQBp)(1, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) +
		2 * ((*ptrx0Ap)(2, 0) + (*ptrQAp)(2, 0) * dataA[0][0](0, 0) + (*ptrQAp)(2, 1) * dataA[0][0](1, 0) + (*ptrQAp)(2, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(2, 0) - (*ptrQBp)(2, 0) * dataB[0][0](0, 0) - (*ptrQBp)(2, 1) * dataB[0][0](1, 0) - (*ptrQBp)(2, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi));

	mHes(0, 0) = 2 * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(0, 0) + (*ptrQAp)(0, 0) * dataA[0][0](0, 0) + (*ptrQAp)(0, 1) * dataA[0][0](1, 0) + (*ptrQAp)(0, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(0, 0) - (*ptrQBp)(0, 0) * dataB[0][0](0, 0) - (*ptrQBp)(0, 1) * dataB[0][0](1, 0) - (*ptrQBp)(0, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(0, 0) * ((dataA[2][0](0, 0) * zetaA_rho + dataA[1][1](0, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](0, 0) * zetaA_rho_rho + (dataA[1][1](0, 0) * zetaA_rho + dataA[0][2](0, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](0, 0) * thetaA_rho_rho) + (*ptrQAp)(0, 1) * ((dataA[2][0](1, 0) * zetaA_rho + dataA[1][1](1, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](1, 0) * zetaA_rho_rho + (dataA[1][1](1, 0) * zetaA_rho + dataA[0][2](1, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](1, 0) * thetaA_rho_rho) + (*ptrQAp)(0, 2) * ((dataA[2][0](2, 0) * zetaA_rho + dataA[1][1](2, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](2, 0) * zetaA_rho_rho + (dataA[1][1](2, 0) * zetaA_rho + dataA[0][2](2, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](2, 0) * thetaA_rho_rho) - (*ptrQBp)(0, 0) * ((dataB[2][0](0, 0) * zetaB_rho + dataB[1][1](0, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](0, 0) * zetaB_rho_rho + (dataB[1][1](0, 0) * zetaB_rho + dataB[0][2](0, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](0, 0) * thetaB_rho_rho) - (*ptrQBp)(0, 1) * ((dataB[2][0](1, 0) * zetaB_rho + dataB[1][1](1, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](1, 0) * zetaB_rho_rho + (dataB[1][1](1, 0) * zetaB_rho + dataB[0][2](1, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](1, 0) * thetaB_rho_rho) - (*ptrQBp)(0, 2) * ((dataB[2][0](2, 0) * zetaB_rho + dataB[1][1](2, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](2, 0) * zetaB_rho_rho + (dataB[1][1](2, 0) * zetaB_rho + dataB[0][2](2, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](2, 0) * thetaB_rho_rho)) +
		2 * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(1, 0) + (*ptrQAp)(1, 0) * dataA[0][0](0, 0) + (*ptrQAp)(1, 1) * dataA[0][0](1, 0) + (*ptrQAp)(1, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(1, 0) - (*ptrQBp)(1, 0) * dataB[0][0](0, 0) - (*ptrQBp)(1, 1) * dataB[0][0](1, 0) - (*ptrQBp)(1, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(1, 0) * ((dataA[2][0](0, 0) * zetaA_rho + dataA[1][1](0, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](0, 0) * zetaA_rho_rho + (dataA[1][1](0, 0) * zetaA_rho + dataA[0][2](0, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](0, 0) * thetaA_rho_rho) + (*ptrQAp)(1, 1) * ((dataA[2][0](1, 0) * zetaA_rho + dataA[1][1](1, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](1, 0) * zetaA_rho_rho + (dataA[1][1](1, 0) * zetaA_rho + dataA[0][2](1, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](1, 0) * thetaA_rho_rho) + (*ptrQAp)(1, 2) * ((dataA[2][0](2, 0) * zetaA_rho + dataA[1][1](2, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](2, 0) * zetaA_rho_rho + (dataA[1][1](2, 0) * zetaA_rho + dataA[0][2](2, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](2, 0) * thetaA_rho_rho) - (*ptrQBp)(1, 0) * ((dataB[2][0](0, 0) * zetaB_rho + dataB[1][1](0, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](0, 0) * zetaB_rho_rho + (dataB[1][1](0, 0) * zetaB_rho + dataB[0][2](0, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](0, 0) * thetaB_rho_rho) - (*ptrQBp)(1, 1) * ((dataB[2][0](1, 0) * zetaB_rho + dataB[1][1](1, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](1, 0) * zetaB_rho_rho + (dataB[1][1](1, 0) * zetaB_rho + dataB[0][2](1, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](1, 0) * thetaB_rho_rho) - (*ptrQBp)(1, 2) * ((dataB[2][0](2, 0) * zetaB_rho + dataB[1][1](2, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](2, 0) * zetaB_rho_rho + (dataB[1][1](2, 0) * zetaB_rho + dataB[0][2](2, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](2, 0) * thetaB_rho_rho)) +
		2 * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(2, 0) + (*ptrQAp)(2, 0) * dataA[0][0](0, 0) + (*ptrQAp)(2, 1) * dataA[0][0](1, 0) + (*ptrQAp)(2, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(2, 0) - (*ptrQBp)(2, 0) * dataB[0][0](0, 0) - (*ptrQBp)(2, 1) * dataB[0][0](1, 0) - (*ptrQBp)(2, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(2, 0) * ((dataA[2][0](0, 0) * zetaA_rho + dataA[1][1](0, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](0, 0) * zetaA_rho_rho + (dataA[1][1](0, 0) * zetaA_rho + dataA[0][2](0, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](0, 0) * thetaA_rho_rho) + (*ptrQAp)(2, 1) * ((dataA[2][0](1, 0) * zetaA_rho + dataA[1][1](1, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](1, 0) * zetaA_rho_rho + (dataA[1][1](1, 0) * zetaA_rho + dataA[0][2](1, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](1, 0) * thetaA_rho_rho) + (*ptrQAp)(2, 2) * ((dataA[2][0](2, 0) * zetaA_rho + dataA[1][1](2, 0) * thetaA_rho) * zetaA_rho + dataA[1][0](2, 0) * zetaA_rho_rho + (dataA[1][1](2, 0) * zetaA_rho + dataA[0][2](2, 0) * thetaA_rho) * thetaA_rho + dataA[0][1](2, 0) * thetaA_rho_rho) - (*ptrQBp)(2, 0) * ((dataB[2][0](0, 0) * zetaB_rho + dataB[1][1](0, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](0, 0) * zetaB_rho_rho + (dataB[1][1](0, 0) * zetaB_rho + dataB[0][2](0, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](0, 0) * thetaB_rho_rho) - (*ptrQBp)(2, 1) * ((dataB[2][0](1, 0) * zetaB_rho + dataB[1][1](1, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](1, 0) * zetaB_rho_rho + (dataB[1][1](1, 0) * zetaB_rho + dataB[0][2](1, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](1, 0) * thetaB_rho_rho) - (*ptrQBp)(2, 2) * ((dataB[2][0](2, 0) * zetaB_rho + dataB[1][1](2, 0) * thetaB_rho) * zetaB_rho + dataB[1][0](2, 0) * zetaB_rho_rho + (dataB[1][1](2, 0) * zetaB_rho + dataB[0][2](2, 0) * thetaB_rho) * thetaB_rho + dataB[0][1](2, 0) * thetaB_rho_rho));

	mHes(0, 1) = 2 * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(0, 0) + (*ptrQAp)(0, 0) * dataA[0][0](0, 0) + (*ptrQAp)(0, 1) * dataA[0][0](1, 0) + (*ptrQAp)(0, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(0, 0) - (*ptrQBp)(0, 0) * dataB[0][0](0, 0) - (*ptrQBp)(0, 1) * dataB[0][0](1, 0) - (*ptrQBp)(0, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(0, 0) * ((dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](0, 0) * zetaA_rho_phi + (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](0, 0) * thetaA_rho_phi) + (*ptrQAp)(0, 1) * ((dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](1, 0) * zetaA_rho_phi + (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](1, 0) * thetaA_rho_phi) + (*ptrQAp)(0, 2) * ((dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](2, 0) * zetaA_rho_phi + (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](2, 0) * thetaA_rho_phi) - (*ptrQBp)(0, 0) * ((dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](0, 0) * zetaB_rho_phi + (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](0, 0) * thetaB_rho_phi) - (*ptrQBp)(0, 1) * ((dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](1, 0) * zetaB_rho_phi + (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](1, 0) * thetaB_rho_phi) - (*ptrQBp)(0, 2) * ((dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](2, 0) * zetaB_rho_phi + (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](2, 0) * thetaB_rho_phi)) +
		2 * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(1, 0) + (*ptrQAp)(1, 0) * dataA[0][0](0, 0) + (*ptrQAp)(1, 1) * dataA[0][0](1, 0) + (*ptrQAp)(1, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(1, 0) - (*ptrQBp)(1, 0) * dataB[0][0](0, 0) - (*ptrQBp)(1, 1) * dataB[0][0](1, 0) - (*ptrQBp)(1, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(1, 0) * ((dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](0, 0) * zetaA_rho_phi + (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](0, 0) * thetaA_rho_phi) + (*ptrQAp)(1, 1) * ((dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](1, 0) * zetaA_rho_phi + (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](1, 0) * thetaA_rho_phi) + (*ptrQAp)(1, 2) * ((dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](2, 0) * zetaA_rho_phi + (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](2, 0) * thetaA_rho_phi) - (*ptrQBp)(1, 0) * ((dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](0, 0) * zetaB_rho_phi + (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](0, 0) * thetaB_rho_phi) - (*ptrQBp)(1, 1) * ((dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](1, 0) * zetaB_rho_phi + (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](1, 0) * thetaB_rho_phi) - (*ptrQBp)(1, 2) * ((dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](2, 0) * zetaB_rho_phi + (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](2, 0) * thetaB_rho_phi)) +
		2 * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_rho + dataA[0][1](0, 0) * thetaA_rho) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_rho + dataA[0][1](1, 0) * thetaA_rho) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_rho + dataA[0][1](2, 0) * thetaA_rho) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_rho + dataB[0][1](0, 0) * thetaB_rho) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_rho + dataB[0][1](1, 0) * thetaB_rho) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_rho + dataB[0][1](2, 0) * thetaB_rho)) +
		2 * ((*ptrx0Ap)(2, 0) + (*ptrQAp)(2, 0) * dataA[0][0](0, 0) + (*ptrQAp)(2, 1) * dataA[0][0](1, 0) + (*ptrQAp)(2, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(2, 0) - (*ptrQBp)(2, 0) * dataB[0][0](0, 0) - (*ptrQBp)(2, 1) * dataB[0][0](1, 0) - (*ptrQBp)(2, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(2, 0) * ((dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](0, 0) * zetaA_rho_phi + (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](0, 0) * thetaA_rho_phi) + (*ptrQAp)(2, 1) * ((dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](1, 0) * zetaA_rho_phi + (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](1, 0) * thetaA_rho_phi) + (*ptrQAp)(2, 2) * ((dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) * zetaA_rho + dataA[1][0](2, 0) * zetaA_rho_phi + (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) * thetaA_rho + dataA[0][1](2, 0) * thetaA_rho_phi) - (*ptrQBp)(2, 0) * ((dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](0, 0) * zetaB_rho_phi + (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](0, 0) * thetaB_rho_phi) - (*ptrQBp)(2, 1) * ((dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](1, 0) * zetaB_rho_phi + (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](1, 0) * thetaB_rho_phi) - (*ptrQBp)(2, 2) * ((dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) * zetaB_rho + dataB[1][0](2, 0) * zetaB_rho_phi + (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) * thetaB_rho + dataB[0][1](2, 0) * thetaB_rho_phi));

	mHes(1, 0) = mHes(0, 1);

	mHes(1, 1) = 2 * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) * ((*ptrQAp)(0, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(0, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(0, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(0, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(0, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(0, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) +
		2 * ((*ptrx0Ap)(0, 0) + (*ptrQAp)(0, 0) * dataA[0][0](0, 0) + (*ptrQAp)(0, 1) * dataA[0][0](1, 0) + (*ptrQAp)(0, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(0, 0) - (*ptrQBp)(0, 0) * dataB[0][0](0, 0) - (*ptrQBp)(0, 1) * dataB[0][0](1, 0) - (*ptrQBp)(0, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(0, 0) * ((dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](0, 0) * zetaA_phi_phi + (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](0, 0) * thetaA_phi_phi) + (*ptrQAp)(0, 1) * ((dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](1, 0) * zetaA_phi_phi + (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](1, 0) * thetaA_phi_phi) + (*ptrQAp)(0, 2) * ((dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](2, 0) * zetaA_phi_phi + (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](2, 0) * thetaA_phi_phi) - (*ptrQBp)(0, 0) * ((dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](0, 0) * zetaB_phi_phi + (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](0, 0) * thetaB_phi_phi) - (*ptrQBp)(0, 1) * ((dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](1, 0) * zetaB_phi_phi + (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](1, 0) * thetaB_phi_phi) - (*ptrQBp)(0, 2) * ((dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](2, 0) * zetaB_phi_phi + (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](2, 0) * thetaB_phi_phi)) +
		2 * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) * ((*ptrQAp)(1, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(1, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(1, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(1, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(1, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(1, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) +
		2 * ((*ptrx0Ap)(1, 0) + (*ptrQAp)(1, 0) * dataA[0][0](0, 0) + (*ptrQAp)(1, 1) * dataA[0][0](1, 0) + (*ptrQAp)(1, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(1, 0) - (*ptrQBp)(1, 0) * dataB[0][0](0, 0) - (*ptrQBp)(1, 1) * dataB[0][0](1, 0) - (*ptrQBp)(1, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(1, 0) * ((dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](0, 0) * zetaA_phi_phi + (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](0, 0) * thetaA_phi_phi) + (*ptrQAp)(1, 1) * ((dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](1, 0) * zetaA_phi_phi + (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](1, 0) * thetaA_phi_phi) + (*ptrQAp)(1, 2) * ((dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](2, 0) * zetaA_phi_phi + (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](2, 0) * thetaA_phi_phi) - (*ptrQBp)(1, 0) * ((dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](0, 0) * zetaB_phi_phi + (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](0, 0) * thetaB_phi_phi) - (*ptrQBp)(1, 1) * ((dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](1, 0) * zetaB_phi_phi + (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](1, 0) * thetaB_phi_phi) - (*ptrQBp)(1, 2) * ((dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](2, 0) * zetaB_phi_phi + (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](2, 0) * thetaB_phi_phi)) +
		2 * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) * ((*ptrQAp)(2, 0) * (dataA[1][0](0, 0) * zetaA_phi + dataA[0][1](0, 0) * thetaA_phi) + (*ptrQAp)(2, 1) * (dataA[1][0](1, 0) * zetaA_phi + dataA[0][1](1, 0) * thetaA_phi) + (*ptrQAp)(2, 2) * (dataA[1][0](2, 0) * zetaA_phi + dataA[0][1](2, 0) * thetaA_phi) - (*ptrQBp)(2, 0) * (dataB[1][0](0, 0) * zetaB_phi + dataB[0][1](0, 0) * thetaB_phi) - (*ptrQBp)(2, 1) * (dataB[1][0](1, 0) * zetaB_phi + dataB[0][1](1, 0) * thetaB_phi) - (*ptrQBp)(2, 2) * (dataB[1][0](2, 0) * zetaB_phi + dataB[0][1](2, 0) * thetaB_phi)) +
		2 * ((*ptrx0Ap)(2, 0) + (*ptrQAp)(2, 0) * dataA[0][0](0, 0) + (*ptrQAp)(2, 1) * dataA[0][0](1, 0) + (*ptrQAp)(2, 2) * dataA[0][0](2, 0) - (*ptrx0Bp)(2, 0) - (*ptrQBp)(2, 0) * dataB[0][0](0, 0) - (*ptrQBp)(2, 1) * dataB[0][0](1, 0) - (*ptrQBp)(2, 2) * dataB[0][0](2, 0)) * ((*ptrQAp)(2, 0) * ((dataA[2][0](0, 0) * zetaA_phi + dataA[1][1](0, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](0, 0) * zetaA_phi_phi + (dataA[1][1](0, 0) * zetaA_phi + dataA[0][2](0, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](0, 0) * thetaA_phi_phi) + (*ptrQAp)(2, 1) * ((dataA[2][0](1, 0) * zetaA_phi + dataA[1][1](1, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](1, 0) * zetaA_phi_phi + (dataA[1][1](1, 0) * zetaA_phi + dataA[0][2](1, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](1, 0) * thetaA_phi_phi) + (*ptrQAp)(2, 2) * ((dataA[2][0](2, 0) * zetaA_phi + dataA[1][1](2, 0) * thetaA_phi) * zetaA_phi + dataA[1][0](2, 0) * zetaA_phi_phi + (dataA[1][1](2, 0) * zetaA_phi + dataA[0][2](2, 0) * thetaA_phi) * thetaA_phi + dataA[0][1](2, 0) * thetaA_phi_phi) - (*ptrQBp)(2, 0) * ((dataB[2][0](0, 0) * zetaB_phi + dataB[1][1](0, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](0, 0) * zetaB_phi_phi + (dataB[1][1](0, 0) * zetaB_phi + dataB[0][2](0, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](0, 0) * thetaB_phi_phi) - (*ptrQBp)(2, 1) * ((dataB[2][0](1, 0) * zetaB_phi + dataB[1][1](1, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](1, 0) * zetaB_phi_phi + (dataB[1][1](1, 0) * zetaB_phi + dataB[0][2](1, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](1, 0) * thetaB_phi_phi) - (*ptrQBp)(2, 2) * ((dataB[2][0](2, 0) * zetaB_phi + dataB[1][1](2, 0) * thetaB_phi) * zetaB_phi + dataB[1][0](2, 0) * zetaB_phi_phi + (dataB[1][1](2, 0) * zetaB_phi + dataB[0][2](2, 0) * thetaB_phi) * thetaB_phi + dataB[0][1](2, 0) * thetaB_phi_phi));
	
	delete P_0_A;
	delete P_0_B;
	for (int i = 0; i < dA + 1; i++)
	{
		delete[]dataA[i];
	}
	delete[]dataA;
	for (int i = 0; i < dB + 1; i++)
	{
		delete[]dataB[i];
	}
	delete[]dataB;
}

void RigidNURBSSurface_RigidNURBSSurface::BeginStepCheck(SSContactData * c_data)
{
	/*
	if (write_report)
	{
		for (int i = 0; i < n_pointwise; i++)
		{
			OpenTRReport(i);
			fprintf(f_TR_report[i], "///////////////////////////////////////////////////////////////////////\n");
			fprintf(f_TR_report[i], "\nTime\t%.6f\tIteration\t%d\t", db.last_converged_time + db.current_time_step, db.current_iteration_number);
			fprintf(f_TR_report[i], "BeginStepCheck\n");
		}
	}
	*/

	/*
	if ((db.last_converged_time + db.current_time_step) > 1.333 && (db.last_converged_time + db.current_time_step) < 1.334) {
		cout << "pare";
	}
	*/

	int number_patchesA = 0;
	int number_patchesB = 0;

	//No início de cada passo é tomada a decisão acerca de strong_candidate ou não (com base na checagem de bounding box em torno das superfícies)
	bool converged1 = false;
	bool converged2 = false;
	bool strong_candidate = true;  // se chegou aqui é porque é strong candidate

	//Salvando últimas coordenadas convectivas convergidas nas atuais - evitando que casos que divergiram sejam usados como estimativas iniciais do novo incremento
	//for (int ip = 0; ip < n_pointwise; ip++)
	//{
		c_data->convective[/*ip*/0][0] = c_data->copy_convective[/*ip*/0][0];
		c_data->convective[/*ip*/0][1] = c_data->copy_convective[/*ip*/0][1];
		c_data->convective[/*ip*/0][2] = c_data->copy_convective[/*ip*/0][2];
		c_data->convective[/*ip*/0][3] = c_data->copy_convective[/*ip*/0][3];
		c_data->patchA[/*ip*/0] = c_data->copy_patchA[/*ip*/0];
		c_data->patchB[/*ip*/0] = c_data->copy_patchB[/*ip*/0];

		c_data->degenerated[/*ip*/0] = false;		//marca a princípio como não degenerado para todas as soluções
		c_data->repeated[/*ip*/0] = false;			//indica que a solução [ip] sempre será considerada
	//}

	//for (int ip = 0; ip < n_pointwise; ip++)
	//{
		converged1 = false;
		converged2 = false;

		//seq_number = ip;//para controle do report

		//Degeneration basis - canonical basis
		(*c_data->P[/*ip*/0])(0, 0) = 1.0;
		(*c_data->P[/*ip*/0])(1, 1) = 1.0;
		(*c_data->P[/*ip*/0])(2, 2) = 1.0;
		(*c_data->P[/*ip*/0])(3, 3) = 1.0;
		//Degenerated coordinates index (in the new basis)
		c_data->deg_control[/*ip*/0][0] = false;
		c_data->deg_control[/*ip*/0][1] = false;
		c_data->deg_control[/*ip*/0][2] = false;
		c_data->deg_control[/*ip*/0][3] = false;
		//Degenerated coordinates values - in case of degeneration, just fill the desired coordinate value
		c_data->copy_deg_coordinates[/*ip*/0][0] = 0.0;
		c_data->copy_deg_coordinates[/*ip*/0][1] = 0.0;
		c_data->copy_deg_coordinates[/*ip*/0][2] = 0.0;
		c_data->copy_deg_coordinates[/*ip*/0][3] = 0.0;

		//CASO 1: não era strong candidate (ou primeiro cálculo)
		if (c_data->copy_return_value[/*ip*/0] == 2)
		{
			//if (write_report)
				//fprintf(f_TR_report[ip], "Performing initial guess\n");
			InitialGuess(cd); //Realiza chute inicial com critério geométrico -> escreve em 'convective'
			for (int i = 0; i < 4; i++)
				(*cNR1[/*ip*/0])(i, 0) = cd->convective[/*ip*/0][i];
			(*patches1[/*ip*/0])(0, 0) = cd->patchA[/*ip*/0];
			(*patches1[/*ip*/0])(1, 0) = cd->patchB[/*ip*/0];

		}
		//CASO 2: ou é copy_return_value 0 ou 4 (já há solução disponível proveniente de um passo anterior)
		else
		{
			(*cNR1[/*ip*/0])(0, 0) = c_data->copy_convective[/*ip*/0][0];
			(*cNR1[/*ip*/0])(1, 0) = c_data->copy_convective[/*ip*/0][1];
			(*cNR1[/*ip*/0])(2, 0) = c_data->copy_convective[/*ip*/0][2];
			(*cNR1[/*ip*/0])(3, 0) = c_data->copy_convective[/*ip*/0][3];
			(*patches1[/*ip*/0])(0, 0) = c_data->copy_patchA[/*ip*/0];
			(*patches1[/*ip*/0])(1, 0) = c_data->copy_patchB[/*ip*/0];
		}

		c_data->return_value[/*ip*/0] = 0;		//é strong (default)
		int info = 0;

		int charact1 = 3;

		////////////////NO DEGENERATION///////////////
		//if (c_data->degenerated[ip] == false)
		//{
			//Se o contato era previamente ativo ou vizinho - ou seja, se havia solucao de ponto de sela
			if ((c_data->copy_return_value[/*ip*/0] == 0 || c_data->copy_return_value[/*ip*/0] == 4) && c_data->copy_g_n[/*ip*/0] < 0.0)
			{
				//if (write_report)
					//fprintf(f_TR_report[ip], "Direct search for saddle\n");
				//Tentativa de achar direto a sela
				*cNR2[/*ip*/0] = *cNR1[/*ip*/0];
				*patches2[/*ip*/0] = *patches1[/*ip*/0];
				converged2 = FindMinimumSolutionCSO(cd, cNR2[/*ip*/0], patches2[/*ip*/0], 2); //if the parameters are out of range, it returns false
			}
			//Se não entrou no if anterior ou se não convergiu o if anterior
			if (converged2 == false)
			{
				//if (write_report)
					//fprintf(f_TR_report[ip], "Search for minimum\n");
				//Determinação de mínimo ou intersecção
				converged1 = GeneralFindMinimumSolution(cd, cNR1[/*ip*/0], *patches1[/*ip*/0], info, number_patchesA, number_patchesB);
				*cNR2[/*ip*/0] = *cNR1[/*ip*/0];
				*patches2[/*ip*/0] = *patches1[/*ip*/0];
				charact1 = CharacterizeCriticalPoint(cNR1[/*ip*/0], *patches1[/*ip*/0]);

				//Se for intersecção - busca o ponto de sela
				if (charact1 == 1)
					converged2 = FindMinimumSolutionCSO(c_data, cNR2[/*ip*/0], patches2[/*ip*/0], 1);
				//Se nao, retorna o minimo
				else
					converged2 = converged1;
			}
		//}

		///////////////////////////////VERIFICATIONS//////////////////////////////////
		Matrix nA(3);
		Matrix nB(3);
		cd->return_value[/*ip*/0] = VerifyConvectiveRange(cd, *cNR2[/*ip*/0], *patches2[/*ip*/0]);

		//Strict minimum
		if (charact1 == 0)
		{
			if (VerifyConvectiveRange(cd, *cNR1[/*ip*/0], *patches1[/*ip*/0]) == 2)
			{
				c_data->return_value[/*ip*/0] = 2;	//não é strong
				//if (write_report)
					//fprintf(f_TR_report[ip], "Candidate is not Strong. Strict minimum far from range of interest.\n");
			}

			//Negative gap
			if (Gap(*cNR1[/*ip*/0], *patches1[/*ip*/0], false, nA, nB) < 0.0)
			{
				c_data->return_value[/*ip*/0] = 2;	//não é strong
				//if (write_report)
					//fprintf(f_TR_report[ip], "Candidate is is not Strong. Strict minimum with negative gap\n");
			}
		}
		//Avaliando se é candidato forte casos com interseccao
		if (charact1 == 1 && converged1 == true)
		{
			surfA->patches[static_cast<int>((*patches1)[/*ip*/0](0, 0))]->NormalExt(ptrQAp, &(*cNR1[/*ip*/0])(0, 0), &(*cNR1[/*ip*/0])(1, 0), &nA);
			surfB->patches[static_cast<int>((*patches1)[/*ip*/0](1, 0))]->NormalExt(ptrQBp, &(*cNR1[/*ip*/0])(2, 0), &(*cNR1[/*ip*/0])(3, 0), &nB);
			if (dot(nA, nB) >= 0.0)
			{
				c_data->return_value[/*ip*/0] = 2;	//não é strong
				/*if (write_report)
				{
					fprintf(f_TR_report[ip], "Candidate is not Strong. nA.nB is %.6f.\n", dot(nA, nB));
					fclose(f_TR_report[ip]);
				}*/
				return;
			}
			if (converged2 == true)
			{
				if (c_data->return_value[/*ip*/0] == 2)
				{
					//if (write_report)
						//fprintf(f_TR_report[ip], "Candidate is not Strong. Saddle far from range of interest.\n");
				}
			}
		}

		//Salva nas variáveis
		c_data->convective[/*ip*/0][0] = (*cNR2[/*ip*/0])(0, 0);
		c_data->convective[/*ip*/0][1] = (*cNR2[/*ip*/0])(1, 0);
		c_data->convective[/*ip*/0][2] = (*cNR2[/*ip*/0])(2, 0);
		c_data->convective[/*ip*/0][3] = (*cNR2[/*ip*/0])(3, 0);
		c_data->patchA[/*ip*/0] = (*patches2[/*ip*/0])(0, 0);
		c_data->patchB[/*ip*/0] = (*patches2[/*ip*/0])(1, 0);
	//}

	//Realiza a degeneracao automatica com base no resultado do LCP inicial. Acumula `a degeneracao imposta no inicio.
	//AutomaticDegenerationProcedure();

	/*if (write_report)
	{
		for (int ip = 0; ip < n_pointwise; ip++)
			fclose(f_TR_report[ip]);
	}*/
}

bool RigidNURBSSurface_RigidNURBSSurface::EndStepCheck(SSContactData * c_data)
{
	/*if (write_report)
	{
		for (int i = 0; i < c_data->n_solutions; i++)
		{
			OpenTRReport(i);
			fprintf(f_TR_report[i], "///////////////////////////////////////////////////////////////////////\n");
			fprintf(f_TR_report[i], "\nTime\t%.6f\tIteration\t%d\t", db.last_converged_time + db.current_time_step, db.current_iteration_number);
			fprintf(f_TR_report[i], "EndStepCheck\n");
		}
	}*/

	//Retorno com problemas: true
	//Retorno sem problemas: false

	//Teste para avaliar solucoes nao convergidas
	//Varredura das soluções ativas
	//for (int i = 0; i < c_data->n_solutions; i++)
	//{
		//Se não for solução repetida (ou seja, se for solução ativa)
		if (c_data->repeated[/*i*/0] == false)
		{
			//Se algum dos pares ativos apresentou divergência do método de otimização
			if (c_data->return_value[/*i*/0] == 1)
			{

				/*
				//Marina
				c_data->return_value[i] = 2;
				//return false;
				*/

				//Teste de bounding box
				/*double inflation_factor = 1.0;
				bool box = BoxOverlap(surf1->box, surf2->box, inflation_factor);
				if (box == false)
				{
					db.myprintf("LCP diverged but no bounding box overlap at the end of the step for surfaces %d and %d.\n", surf1_ID, surf2_ID);
					if (write_report)
					{
						fprintf(f_TR_report, "No bounding box overlap at the end of the step for surfaces %d and %d.\n", surf1_ID, surf2_ID);
						fclose(f_TR_report);
					}
					return false;
				}*/


				db.myprintf("LCP between surfaces %d and %d has presented problems. Code 1.\n", CAD_AID, CAD_BID);
				/*if (write_report)
				{
					fprintf(f_TR_report[i], "LCP between surfaces %d and %d has presented problems. Code 1.\n", surf1_ID, surf2_ID);
					for (int ip = 0; ip < c_data->n_solutions; ip++)
						fclose(f_TR_report[ip]);
				}*/
				return true;

			}
			//Se houve muita mudança de range das coordenadas convectivas é indicativo de perda da solução desejada para c_bar
			if (c_data->return_value[/*i*/0] == 3)
			{
				db.myprintf("LCP between surfaces %d and %d has presented problems. Code 3.\n", CAD_AID, CAD_BID);
				/*if (write_report)
				{
					fprintf(f_TR_report[i], "LCP between surfaces %d and %d has presented problems. Code 3.\n", surf1_ID, surf2_ID);
					for (int ip = 0; ip < c_data->n_solutions; ip++)
						fclose(f_TR_report[ip]);
				}*/
				return true;
			}
		}
	//}


	/*if (write_report)
	{
		for (int ip = 0; ip < c_data->n_solutions; ip++)
			fclose(f_TR_report[ip]);
	}*/

	return false;
}

double RigidNURBSSurface_RigidNURBSSurface::Gap(Matrix& mc, Matrix& patch, bool fixed_normals, Matrix& nA, Matrix& nB)
{
	//AceGen variables or pointers
	double v[2000];
	EvaluateNURBSDerivatives_p(mc, patch);
	EvaluateNURBSDOFsVariables();
	double Gap;
	bool* fixnormal = &fixed_normals;
	double* normalA = nA.getMatrix();
	double* normalB = nB.getMatrix();

	int b243;
	v[161] = Power(alphaA[0], 2);
	v[159] = 0.5e0*alphaA[0] * alphaA[1];
	v[154] = Power(alphaA[1], 2);
	v[166] = 0.5e0*alphaA[1] * alphaA[2];
	v[164] = 0.5e0*alphaA[0] * alphaA[2];
	v[155] = Power(alphaA[2], 2);
	v[252] = v[154] + v[155];
	v[192] = Power(alphaB[0], 2);
	v[190] = 0.5e0*alphaB[0] * alphaB[1];
	v[185] = Power(alphaB[1], 2);
	v[197] = 0.5e0*alphaB[1] * alphaB[2];
	v[195] = 0.5e0*alphaB[0] * alphaB[2];
	v[186] = Power(alphaB[2], 2);
	v[253] = v[185] + v[186];
	v[153] = 4e0 / (4e0 + v[161] + v[252]);
	v[156] = 1e0 - 0.5e0*v[153] * v[252];
	v[157] = v[153] * (-alphaA[2] + v[159]);
	v[158] = v[153] * (alphaA[1] + v[164]);
	v[160] = v[153] * (alphaA[2] + v[159]);
	v[162] = 1e0 - 0.5e0*v[153] * (v[155] + v[161]);
	v[163] = v[153] * (-alphaA[0] + v[166]);
	v[165] = v[153] * (-alphaA[1] + v[164]);
	v[167] = v[153] * (alphaA[0] + v[166]);
	v[168] = 1e0 - 0.5e0*v[153] * (v[154] + v[161]);
	v[169] = QAi[0][0] * v[156] + QAi[1][0] * v[157] + QAi[2][0] * v[158];
	v[170] = QAi[0][1] * v[156] + QAi[1][1] * v[157] + QAi[2][1] * v[158];
	v[171] = QAi[0][2] * v[156] + QAi[1][2] * v[157] + QAi[2][2] * v[158];
	v[218] = dGAp[0][1] * v[169] + dGAp[1][1] * v[170] + dGAp[2][1] * v[171];
	v[215] = dGAp[0][0] * v[169] + dGAp[1][0] * v[170] + dGAp[2][0] * v[171];
	v[172] = QAi[0][0] * v[160] + QAi[1][0] * v[162] + QAi[2][0] * v[163];
	v[173] = QAi[0][1] * v[160] + QAi[1][1] * v[162] + QAi[2][1] * v[163];
	v[174] = QAi[0][2] * v[160] + QAi[1][2] * v[162] + QAi[2][2] * v[163];
	v[219] = dGAp[0][1] * v[172] + dGAp[1][1] * v[173] + dGAp[2][1] * v[174];
	v[216] = dGAp[0][0] * v[172] + dGAp[1][0] * v[173] + dGAp[2][0] * v[174];
	v[175] = QAi[0][0] * v[165] + QAi[1][0] * v[167] + QAi[2][0] * v[168];
	v[176] = QAi[0][1] * v[165] + QAi[1][1] * v[167] + QAi[2][1] * v[168];
	v[177] = QAi[0][2] * v[165] + QAi[1][2] * v[167] + QAi[2][2] * v[168];
	v[220] = dGAp[0][1] * v[175] + dGAp[1][1] * v[176] + dGAp[2][1] * v[177];
	v[217] = dGAp[0][0] * v[175] + dGAp[1][0] * v[176] + dGAp[2][0] * v[177];
	v[184] = 4e0 / (4e0 + v[192] + v[253]);
	v[187] = 1e0 - 0.5e0*v[184] * v[253];
	v[188] = v[184] * (-alphaB[2] + v[190]);
	v[189] = v[184] * (alphaB[1] + v[195]);
	v[191] = v[184] * (alphaB[2] + v[190]);
	v[193] = 1e0 - 0.5e0*v[184] * (v[186] + v[192]);
	v[194] = v[184] * (-alphaB[0] + v[197]);
	v[196] = v[184] * (-alphaB[1] + v[195]);
	v[198] = v[184] * (alphaB[0] + v[197]);
	v[199] = 1e0 - 0.5e0*v[184] * (v[185] + v[192]);
	v[200] = QBi[0][0] * v[187] + QBi[1][0] * v[188] + QBi[2][0] * v[189];
	v[201] = QBi[0][1] * v[187] + QBi[1][1] * v[188] + QBi[2][1] * v[189];
	v[202] = QBi[0][2] * v[187] + QBi[1][2] * v[188] + QBi[2][2] * v[189];
	v[224] = dGBp[0][1] * v[200] + dGBp[1][1] * v[201] + dGBp[2][1] * v[202];
	v[221] = dGBp[0][0] * v[200] + dGBp[1][0] * v[201] + dGBp[2][0] * v[202];
	v[203] = QBi[0][0] * v[191] + QBi[1][0] * v[193] + QBi[2][0] * v[194];
	v[204] = QBi[0][1] * v[191] + QBi[1][1] * v[193] + QBi[2][1] * v[194];
	v[205] = QBi[0][2] * v[191] + QBi[1][2] * v[193] + QBi[2][2] * v[194];
	v[225] = dGBp[0][1] * v[203] + dGBp[1][1] * v[204] + dGBp[2][1] * v[205];
	v[222] = dGBp[0][0] * v[203] + dGBp[1][0] * v[204] + dGBp[2][0] * v[205];
	v[206] = QBi[0][0] * v[196] + QBi[1][0] * v[198] + QBi[2][0] * v[199];
	v[207] = QBi[0][1] * v[196] + QBi[1][1] * v[198] + QBi[2][1] * v[199];
	v[208] = QBi[0][2] * v[196] + QBi[1][2] * v[198] + QBi[2][2] * v[199];
	v[226] = dGBp[0][1] * v[206] + dGBp[1][1] * v[207] + dGBp[2][1] * v[208];
	v[223] = dGBp[0][0] * v[206] + dGBp[1][0] * v[207] + dGBp[2][0] * v[208];
	v[248] = uA[0] - uB[0] + GAp[0] * v[169] + GAp[1] * v[170] + GAp[2] * v[171] - GBp[0] * v[200] - GBp[1] * v[201]
		- GBp[2] * v[202] + xAi[0] - xBi[0];
	v[249] = uA[1] - uB[1] + GAp[0] * v[172] + GAp[1] * v[173] + GAp[2] * v[174] - GBp[0] * v[203] - GBp[1] * v[204]
		- GBp[2] * v[205] + xAi[1] - xBi[1];
	v[250] = uA[2] - uB[2] + GAp[0] * v[175] + GAp[1] * v[176] + GAp[2] * v[177] - GBp[0] * v[206] - GBp[1] * v[207]
		- GBp[2] * v[208] + xAi[2] - xBi[2];
	v[229] = -(v[217] * v[219]) + v[216] * v[220];
	v[236] = -(v[223] * v[225]) + v[222] * v[226];
	if ((*fixnormal)) {
		v[247] = ((-normalA[0] + normalB[0])*v[248] + (-normalA[1] + normalB[1])*v[249] + (-normalA[2] + normalB[2]
			)*v[250]) / 2e0;
	}
	else {
		v[241] = -(v[222] * v[224]) + v[221] * v[225];
		v[239] = v[223] * v[224] - v[221] * v[226];
		v[234] = -(v[216] * v[218]) + v[215] * v[219];
		v[232] = v[217] * v[218] - v[215] * v[220];
		v[247] = (-((((*invertnormalA) ? -1 : 1)*(v[229] * v[248] + v[232] * v[249] + v[234] * v[250])) / sqrt(
			(v[229] * v[229]) + (v[232] * v[232]) + (v[234] * v[234]))) + (((*invertnormalB) ? -1 : 1)*(v[236] * v[248]
				+ v[239] * v[249] + v[241] * v[250])) / sqrt((v[236] * v[236]) + (v[239] * v[239]) + (v[241] * v[241]))) / 2e0;
	};
	(Gap) = v[247];

	return Gap;
}

void RigidNURBSSurface_RigidNURBSSurface::EvaluateInvertedHessian(SSContactData * c_data, int type)
{
	//type 1: 1 patch
	//type 2: multipatches

	for (int sol = 0; sol < c_data->n_solutions; sol++)
	{
		if (c_data->repeated[sol] == false && (c_data->return_value[sol] == 0 || c_data->return_value[sol] == 4))
		{
			//c_data->P_0[sol]->print();
			Matrix Hes(4, 4);
			Matrix xk(4);
			Matrix patch(2);
			for (int i = 0; i < 4; i++)
				xk(i, 0) = c_data->convective[sol][i];
			//if (type == 1) {
				//HessianPhase1(xk, Hes);
			//}
			//else {
				patch(0, 0) = c_data->patchA[sol];
				patch(1, 0) = c_data->patchB[sol];
				HessianPhase1(xk, patch, Hes);
			//}

			Matrix Hes_minor = transp(*c_data->P_0[sol])*Hes*(*c_data->P_0[sol]);
			int order_minor = c_data->P_0[sol]->getColumns();
			Matrix P(order_minor, order_minor);
			Matrix D(order_minor, order_minor);
			fulleigen1(Hes_minor, P, D, tol_eig);
			//D.print();
			//Inversão da Hessiana
			for (int i = 0; i < order_minor; i++)
			{
				D(i, i) = 1.0 / D(i, i);
			}
			Matrix invHes = (*c_data->P_0[sol])*P*D*transp(P)*transp(*c_data->P_0[sol]);
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 4; j++)
					c_data->invHessian[sol][i][j] = invHes(i, j);
		}
	}
}

int RigidNURBSSurface_RigidNURBSSurface::VerifyCriticalMultipatchNURBSRegion(SSContactData * c_data, Matrix * solution, Matrix & patch)
{
	
	/*-----------------------------------------------------------------------------------------------------------------*/
	// Caso 1: projeção do ponto A na superfície B
	// Caso 2: projeção do ponto B na superfície A
	// Caso 3: distância entre A e B
	// Caso 4: não é região crítica
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Verificar se alguma superfície é um plano
	// Derivadas das superfícies no ponto inicial (intersecção ou ponto de sela anterior)
	// Superfície A
	int dA = 2;
	Matrix** dataA;
	dataA = new Matrix*[dA + 1];
	for (int i = 0; i < dA + 1; i++)
	{
		dataA[i] = new Matrix[dA + 1];
		for (int j = 0; j < dA + 1; j++)
			dataA[i][j] = Matrix(3);
	}
	surfA->patches[patch(0, 0)]->NURBSDerivatives((*solution)(0, 0), (*solution)(1, 0), dataA, dA);
	double der_zeta_zeta_A = sqrt(dataA[2][0](0, 0) * dataA[2][0](0, 0) + dataA[2][0](1, 0) * dataA[2][0](1, 0) + dataA[2][0](2, 0) * dataA[2][0](2, 0));
	double der_zeta_theta_A = sqrt(dataA[1][1](0, 0) * dataA[1][1](0, 0) + dataA[1][1](1, 0) * dataA[1][1](1, 0) + dataA[1][1](2, 0) * dataA[1][1](2, 0));
	double der_theta_theta_A = sqrt(dataA[0][2](0, 0) * dataA[0][2](0, 0) + dataA[0][2](1, 0) * dataA[0][2](1, 0) + dataA[0][2](2, 0) * dataA[0][2](2, 0));

	// Superfície B
	int dB = 2;
	Matrix** dataB;
	dataB = new Matrix*[dB + 1];
	for (int i = 0; i < dB + 1; i++)
	{
		dataB[i] = new Matrix[dB + 1];
		for (int j = 0; j < dB + 1; j++)
			dataB[i][j] = Matrix(3);
	}
	surfB->patches[patch(1, 0)]->NURBSDerivatives((*solution)(2, 0), (*solution)(3, 0), dataB, dB);
	double der_zeta_zeta_B = sqrt(dataB[2][0](0, 0) * dataB[2][0](0, 0) + dataB[2][0](1, 0) * dataB[2][0](1, 0) + dataB[2][0](2, 0) * dataB[2][0](2, 0));
	double der_zeta_theta_B = sqrt(dataB[1][1](0, 0) * dataB[1][1](0, 0) + dataB[1][1](1, 0) * dataB[1][1](1, 0) + dataB[1][1](2, 0) * dataB[1][1](2, 0));
	double der_theta_theta_B = sqrt(dataB[0][2](0, 0) * dataB[0][2](0, 0) + dataB[0][2](1, 0) * dataB[0][2](1, 0) + dataB[0][2](2, 0) * dataB[0][2](2, 0));

	bool planeA = false;
	bool planeB = false;

	if (der_zeta_zeta_A < tol_small_1 /*&& der_zeta_theta_A < tol_small_1*/ && der_theta_theta_A < tol_small_1){
		planeA = true;
	}

	if (der_zeta_zeta_B < tol_small_1 /*&& der_zeta_theta_B < tol_small_1*/ && der_theta_theta_B < tol_small_1) {
		planeB = true;
	}

	for (int i = 0; i < dA + 1; i++)
	{
		delete[]dataA[i];
	}
	delete[]dataA;
	for (int i = 0; i < dB + 1; i++)
	{
		delete[]dataB[i];
	}
	delete[]dataB;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	bool criticalA = false;
	bool criticalB = false;

	// Verificação da superfície A	
	int degA_u = 0;
	int degA_v = 0;

	double u = (*solution)(0, 0);
	double v = (*solution)(1, 0);

	Matrix point1(3);
	Matrix point2(3);

	double distA = 0.0;

	if (planeA){
		// Direção u
		if ((*solution)(0, 0) < surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) {
			criticalA = true;
			degA_u = 1;
			degA_v = 1;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order];
		}
		else if ((*solution)(0, 0) > surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim]) {
			criticalA = true;
			degA_u = 2;
			degA_v = 2;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim];
		}
		/*else if (((*solution)(0, 0) - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) < 0.100 * (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) && planeA == false) {
			criticalA = true;
			degA_u = 1;
			degA_v = 1;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order];
		}
		else if ((surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - (*solution)(0, 0)) < 0.100 * (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) && planeA == false) {
			criticalA = true;
			degA_u = 2;
			degA_v = 2;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim];
		}*/
		// Direção v
		if ((*solution)(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) {
			criticalA = true;
			degA_u = 1;
			degA_v = 1;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order];
		}
		else if ((*solution)(1, 0) > surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim]) {
			criticalA = true;
			degA_u = 2;
			degA_v = 2;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim];
		}
		/*else if (((*solution)(1, 0) - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) < 0.100 * (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) && planeA == false) {
			criticalA = true;
			degA_u = 1;
			degA_v = 1;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order];
		}
		else if ((surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - (*solution)(1, 0)) < 0.100 * (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) && planeA == false) {
			criticalA = true;
			degA_u = 2;
			degA_v = 2;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim];
		}*/
	}
	else {
		// Direção u
		if ((*solution)(0, 0) < surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) {
			criticalA = true;
			degA_u = 1;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order];
		}
		else if ((*solution)(0, 0) > surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim]) {
			criticalA = true;
			degA_u = 2;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim];
		}
		else if (((*solution)(0, 0) - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) < 0.10 * (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) && planeA == false) {
			criticalA = true;
			degA_u = 3;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order];
		}
		else if ((surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - (*solution)(0, 0)) < 0.10 * (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) && planeA == false) {
			criticalA = true;
			degA_u = 4;
			u = surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim];
		}

		// Direção v
		if ((*solution)(1, 0) < surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) {
			criticalA = true;
			degA_v = 1;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order];
		}
		else if ((*solution)(1, 0) > surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim]) {
			criticalA = true;
			degA_v = 2;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim];
		}
		else if (((*solution)(1, 0) - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) < 0.10 * (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) && planeA == false) {
			criticalA = true;
			degA_v = 3;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order];
		}
		else if ((surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - (*solution)(1, 0)) < 0.10 * (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) && planeA == false) {
			criticalA = true;
			degA_v = 4;
			v = surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim];
		}
	}
	
	if ((degA_u == 1 || degA_u == 2) && (degA_v == 1 || degA_v == 2)) {
		(*solution)(0, 0) = u;
		cd->deg_control[0][0] = true;
		(*solution)(1, 0) = v;
		cd->deg_control[0][1] = true;
	}
	else if ((degA_u == 1 || degA_u == 2)) {
		(*solution)(0, 0) = u;
		cd->deg_control[0][0] = true;
	}
	else if ((degA_v == 1 || degA_v == 2)) {
		(*solution)(1, 0) = v;
		cd->deg_control[0][1] = true;
	}
	else {
		if ((degA_u == 3 || degA_u == 4) && (degA_v == 3 || degA_v == 4)) {
			if ((((*solution)(0, 0) - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) < 0.025 * (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order]) || (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - (*solution)(0, 0)) < 0.025 * (surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_dim] - surfA->patches[patch(0, 0)]->U_knot_vector[surfA->patches[patch(0, 0)]->U_order])) && (((*solution)(1, 0) - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) < 0.025 * (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]) || (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - (*solution)(1, 0)) < 0.025 * (surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_dim] - surfA->patches[patch(0, 0)]->V_knot_vector[surfA->patches[patch(0, 0)]->V_order]))) {
				(*solution)(0, 0) = u;
				cd->deg_control[0][0] = true;
				(*solution)(1, 0) = v;
				cd->deg_control[0][1] = true;
			}
			else {
				surfA->patches[patch(0, 0)]->NURBSPoint((*solution)(0, 0), (*solution)(1, 0), point1);
				surfA->patches[patch(0, 0)]->NURBSPoint(u, (*solution)(1, 0), point2);
				distA = norm(point2 - point1);
				surfA->patches[patch(0, 0)]->NURBSPoint((*solution)(0, 0), v, point2);
				if (distA < 0.90 * norm(point2 - point1)) {
					(*solution)(0, 0) = u;
					cd->deg_control[0][0] = true;
				}
				else if (norm(point2 - point1) < 0.90 * distA) {
					(*solution)(1, 0) = v;
					cd->deg_control[0][1] = true;
				}
				else {
					(*solution)(0, 0) = u;
					cd->deg_control[0][0] = true;
					(*solution)(1, 0) = v;
					cd->deg_control[0][1] = true;
				}
			}
		}
		else {
			(*solution)(0, 0) = u;
			(*solution)(1, 0) = v;
			if (degA_u == 3 || degA_u == 4) {
				cd->deg_control[0][0] = true;
			}
			if (degA_v == 3 || degA_v == 4) {
				cd->deg_control[0][1] = true;
			}
		}
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Verificação da superfície B	

	int degB_u = 0;
	int degB_v = 0;

	u = (*solution)(2, 0);
	v = (*solution)(3, 0);

	double distB = 0.0;

	if (planeB) {

		// Direção u
		if ((*solution)(2, 0) < surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) {
			criticalB = true;
			degB_u = 1;
			degB_v = 1;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order];
		}
		else if ((*solution)(2, 0) > surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim]) {
			criticalB = true;
			degB_u = 2;
			degB_v = 2;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim];
		}
		/*else if (((*solution)(2, 0) - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) < 0.100 * (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) && planeB == false) {
			criticalB = true;
			degB_u = 1;
			degB_v = 1;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order];
		}
		else if ((surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - (*solution)(2, 0)) < 0.100 * (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) && planeB == false) {
			criticalB = true;
			degB_u = 2;
			degB_v = 2;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim];
		}*/
		// Direção v
		if ((*solution)(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) {
			criticalB = true;
			degB_u = 1;
			degB_v = 1;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order];
		}
		else if ((*solution)(3, 0) > surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim]) {
			criticalB = true;
			degB_u = 2;
			degB_v = 2;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim];
		}
		/*else if (((*solution)(3, 0) - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) < 0.100 * (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) && planeB == false) {
			criticalB = true;
			degB_u = 1;
			degB_v = 1;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order];
		}
		else if ((surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - (*solution)(3, 0)) < 0.100 * (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) && planeB == false) {
			criticalB = true;
			degB_u = 2;
			degB_v = 2;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim];
		}*/
	}
	else {
		// Direção u
		if ((*solution)(2, 0) < surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) {
			criticalB = true;
			degB_u = 1;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order];
		}
		else if ((*solution)(2, 0) > surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim]) {
			criticalB = true;
			degB_u = 2;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim];
		}
		else if (((*solution)(2, 0) - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) < 0.10 * (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) && planeB == false) {
			criticalB = true;
			degB_u = 3;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order];
		}
		else if ((surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - (*solution)(2, 0)) < 0.10 * (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) && planeB == false) {
			criticalB = true;
			degB_u = 4;
			u = surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim];
		}

		// Direção v
		if ((*solution)(3, 0) < surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) {
			criticalB = true;
			degB_v = 1;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order];
		}
		else if ((*solution)(3, 0) > surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim]) {
			criticalB = true;
			degB_v = 2;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim];
		}
		else if (((*solution)(3, 0) - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) < 0.10 * (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) && planeB == false) {
			criticalB = true;
			degB_v = 3;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order];
		}
		else if ((surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - (*solution)(3, 0)) < 0.10 * (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) && planeB == false) {
			criticalB = true;
			degB_v = 4;
			v = surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim];
		}
	}

	if ((degB_u == 1 || degB_u == 2) && (degB_v == 1 || degB_v == 2)) {
		(*solution)(2, 0) = u;
		cd->deg_control[0][2] = true;
		(*solution)(3, 0) = v;
		cd->deg_control[0][3] = true;
	}
	else if ((degB_u == 1 || degB_u == 2)) {
		(*solution)(2, 0) = u;
		cd->deg_control[0][2] = true;
	}
	else if ((degB_v == 1 || degB_v == 2)) {
		(*solution)(3, 0) = v;
		cd->deg_control[0][3] = true;
	}
	else {
		if ((degB_u == 3 || degB_u == 4) && (degB_v == 3 || degB_v == 4)) {
			if ((((*solution)(2, 0) - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) < 0.025 * (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order]) || (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - (*solution)(2, 0)) < 0.025 * (surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_dim] - surfB->patches[patch(1, 0)]->U_knot_vector[surfB->patches[patch(1, 0)]->U_order])) && (((*solution)(3, 0) - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]) < 0.025 * (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order])|| (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - (*solution)(3, 0)) < 0.025 * (surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_dim] - surfB->patches[patch(1, 0)]->V_knot_vector[surfB->patches[patch(1, 0)]->V_order]))) {
				(*solution)(2, 0) = u;
				cd->deg_control[0][2] = true;
				(*solution)(3, 0) = v;
				cd->deg_control[0][3] = true;
			}
			else {
				surfB->patches[patch(1, 0)]->NURBSPoint((*solution)(2, 0), (*solution)(3, 0), point1);
				surfB->patches[patch(1, 0)]->NURBSPoint(u, (*solution)(3, 0), point2);
				distB = norm(point2 - point1);
				surfB->patches[patch(1, 0)]->NURBSPoint((*solution)(2, 0), v, point2);
				if (distB < 0.90 * norm(point2 - point1)) {
					(*solution)(2, 0) = u;
					cd->deg_control[0][2] = true;
				}
				else if (norm(point2 - point1) < 0.90 * distB) {
					(*solution)(3, 0) = v;
					cd->deg_control[0][3] = true;
				}
				else {
					(*solution)(2, 0) = u;
					cd->deg_control[0][2] = true;
					(*solution)(3, 0) = v;
					cd->deg_control[0][3] = true;
				}
			}
		}
		else {
			(*solution)(2, 0) = u;
			(*solution)(3, 0) = v;
			if (degB_u == 3 || degB_u == 4) {
				cd->deg_control[0][2] = true;
			}
			if (degB_v == 3 || degB_v == 4) {
				cd->deg_control[0][3] = true;
			}
		}
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	cd->copy_deg_coordinates[0][0] = (*solution)(0, 0);
	cd->copy_deg_coordinates[0][1] = (*solution)(1, 0);
	cd->copy_deg_coordinates[0][2] = (*solution)(2, 0);
	cd->copy_deg_coordinates[0][3] = (*solution)(3, 0);

	// Degeneration basis - canonical basis
	(*cd->P[0])(0, 0) = 1.0;
	(*cd->P[0])(1, 1) = 1.0;
	(*cd->P[0])(2, 2) = 1.0;
	(*cd->P[0])(3, 3) = 1.0;

	// Degenerative operator
	cd->MountDegenerativeOperator();

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Retorno da função
	if (criticalA && criticalB) {
		cd->degenerated[0] = true;
		return 3;
	}
	else if (criticalA) {
		cd->degenerated[0] = true;
		return 1;
	}
	else if (criticalB) {
		cd->degenerated[0] = true;
		return 2;
	}
	else {
		cd->degenerated[0] = false;
		return 4;
	}
}

bool RigidNURBSSurface_RigidNURBSSurface::FindMinimumSolutionDegenerated(SSContactData * c_data, Matrix * P_0, Matrix * solution, Matrix & patch)
{
	int order = P_0->getColumns();

	if (order == 0) {
		return true;
	}
	else {
		//Dados - trust region
		double Deltamax = 1e4;			//máximo raio da trust region permitido
		double Deltak = 0.1;			//atual raio de trust region
		double etha = 0.15;				//valor entre 0 e 0.15 - indica que a aproximação é ruim e veta o incremento
		double rhok = 0.0;				//razão entre a diferença na função objetivo e a diferença da aproximação utilizada
		double actual_reduction = 0.0;
		double predicted_reduction = 0.0;
		int max_it = max_it_1;
		double last_reduction = 0.0;
		double reduction = 0.0;

		Matrix Hes(4, 4);
		Matrix Gra(4, 1);
		Matrix xk(4);
		Matrix pt(2); // Marina
		Matrix pk(order);
		Matrix pb(order);
		Matrix pc(order);
		Matrix pGra(order, 1);
		Matrix deg_Hes(order, order);
		Matrix deg_Gra(order, 1);
		Matrix P(order, order);
		Matrix D(order, order);
		Matrix cHes(order, order);

		//Inicialização do método - chute inicial - obtido da solução anterior - problema de mínima distância
		for (int i = 0; i < 4; i++)
			xk(i, 0) = (*solution)(i, 0);
		pt(0, 0) = patch(0, 0); //Marina
		pt(1, 0) = patch(1, 0); //Marina

		//Criterio de parada
		HessianPhase1(xk, pt, Hes);
		deg_Hes = transp(*P_0)*Hes*(*P_0);
		fulleigen1(deg_Hes, P, D, tol_eig);
		double max_eig = -1e100;
		for (int i = 0; i < order; i++)
		{
			if (D(i, i) > max_eig)
				max_eig = D(i, i);
		}

		double tol_ortho = tol_convective * abs(max_eig);
		//double tol_small = tol_small_1*1e4;
		double tol_small = tol_small_1;

		int it = 1;
		//Objetivo
		double ob = ObjectivePhase1(xk, pt);
		//Gradiente
		GradientPhase1(xk, pt, Gra);
		//Hessiana
		HessianPhase1(xk, pt, Hes);
		//Transformações - degeneração
		deg_Gra = transp(*P_0)*Gra;
		deg_Hes = transp(*P_0)*Hes*(*P_0);
		//Erro - forçando primeira entrada
		double error = tol_ortho + 1.0;
		/////////////////////////////////////////////////////BEGIN///////////////////////////////////////////////
		while ((error > tol_ortho || norm((*P_0)*pk) > tol_convective) && it <= max_it)
		{
			//Determinação do ponto de Cauchy
			double gragra = (transp(deg_Gra)*deg_Gra)(0, 0);
			double grahesgra = (transp(deg_Gra)*deg_Hes*deg_Gra)(0, 0);
			double normgra = norm(deg_Gra);
			Matrix pc;	//direção do Cauchy point
			/////////////////Ponto de Cauchy///////////////////////
			if (grahesgra <= 0.0)
				pc = -(Deltak / normgra)*deg_Gra;
			else
				pc = -gragra / grahesgra * deg_Gra;
			double normpc = norm(pc);
			//Cauchy point outside the TR - use a fraction of it
			if ((normpc + tol_convective) >= Deltak)
			{
				pk = (Deltak / normpc)*pc; //Steep descent
			}

			else//Cauchy point inside the TR
			{
				//Calculando direções principais e curvaturas principais da função objetivo
				cHes = deg_Hes;
				fulleigen1(cHes, P, D, tol_eig);
				//Escrevendo gradiente nas direções principais
				pGra = transp(P)*deg_Gra;
				//Determinação do menor autovalor (min_eig)
				double min_eig = 1e100;
				for (int i = 0; i < order; i++)
				{
					if (D(i, i) < min_eig)
						min_eig = D(i, i);
				}
				//Construção da direção de busca
				//Direção de busca baseada em NR - modificada pelo menor autovalor
				zeros(&pb);
				//Se o menor autovalor é menor ou igual a zero (tol_small) - modifica a direção de NR para garantir direção descendente
				if (min_eig < tol_small)
				{
					for (int i = 0; i < order; i++)
						pb(i, 0) = -pGra(i, 0) / (D(i, i) - (min_eig - abs(min_eig)*tol_ascent));
				}
				//Se o menor autovalor é maior que zero (tol_small) - direção de NR é escolhida
				else
				{
					for (int i = 0; i < order; i++)
						pb(i, 0) = -pGra(i, 0) / D(i, i);
				}
				//Escrevendo direção de busca nas coordenadas originais
				pb = P * pb;
				double normpb = norm(pb);
				double thetak;
				//Newton point inside the TR -  use it
				if (normpb <= Deltak)
				{
					pk = pb;
				}
				else
				{
					////////////////////////////Dogleg path//////////////////////////
					double a, b, c;
					a = norm(pb - pc)*norm(pb - pc);
					b = 2 * (transp(pc)*(pb - pc))(0, 0);
					c = normpc * normpc - Deltak * Deltak;
					thetak = (-b + sqrt(b*b - 4 * a*c)) / (2 * a);
					//Determinação do path
					pk = pc + thetak * (pb - pc);
				}
			}

			//////////////////////////UPDATING SOLUTION////////////////////////////////
			//Cálculo de rhok
			double actual_reduction = ObjectivePhase1(xk, pt) - ObjectivePhase1(xk + (*P_0)*pk, pt);
			double predicted_reduction = -(transp(deg_Gra)*pk + 0.5*transp(pk)*deg_Hes*pk)(0, 0);
			rhok = actual_reduction / predicted_reduction;

			if (abs(actual_reduction / ObjectivePhase1(xk, pt)) < tol_ascent)
				rhok = 1.0;

			if (abs(predicted_reduction) < tol_small || abs(actual_reduction) < tol_small)
				rhok = 1.0;

			if (rhok >= 0.0)
			{
				if (rhok < 0.25)//low reduction or even augmenting the objective function
					Deltak = 0.25*norm(pk);//reduce TR
				else
				{
					if (rhok > 0.75 && ((norm(pk) + tol_convective) >= Deltak && (norm(pk) - tol_convective) <= Deltak))//high reduction and testing the limits of the trust region
					{
						//augments the radius of TR
						if (2.0 * Deltak < Deltamax)
							Deltak = 2.0 * Deltak;
						else
							Deltak = Deltamax;
					}
				}
				if (rhok >= etha)
					xk = xk + (*P_0)*pk;
			}
			else
				Deltak = Deltak / 2;
			//		//Incrementa iterações
			it++;
			//Objetivo
			ob = ObjectivePhase1(xk, pt);
			//Gradiente
			GradientPhase1(xk, pt, Gra);
			//Hessiana
			HessianPhase1(xk, pt, Hes);
			//Transformações - degeneração
			deg_Gra = transp(*P_0)*Gra;
			deg_Hes = transp(*P_0)*Hes*(*P_0);
			//Erro - norma do gradiente
			error = norm(deg_Gra);
			//Initial guess report
		}

		//Retorno da função
		if (error < tol_ortho)
		{
			//Salva resultado em solution
			for (int i = 0; i < 4; i++)
				(*solution)(i, 0) = xk(i, 0);

			//Marina
			if ((*solution)(0, 0) < surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order])
				(*solution)(0, 0) = surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order];

			if ((*solution)(0, 0) > surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_dim])
				(*solution)(0, 0) = surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_dim];

			if ((*solution)(1, 0) < surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order])
				(*solution)(1, 0) = surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order];

			if ((*solution)(1, 0) > surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_dim])
				(*solution)(1, 0) = surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_dim];

			if ((*solution)(2, 0) < surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order])
				(*solution)(2, 0) = surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order];

			if ((*solution)(2, 0) > surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_dim])
				(*solution)(2, 0) = surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_dim];

			if ((*solution)(3, 0) < surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order])
				(*solution)(3, 0) = surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order];

			if ((*solution)(3, 0) > surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_dim])
				(*solution)(3, 0) = surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_dim];

			return true;
		}
		else
			return false;
	}
}

void RigidNURBSSurface_RigidNURBSSurface::EvaluateNURBSDerivatives_p(Matrix & mc, Matrix & patch)
{
	if (mc == last_cp && first_cp == false && patch1_p == static_cast<int>(patch(0, 0)) && patch2_p == static_cast<int>(patch(1, 0)))
		return;
	else
	{
		last_cp = mc;
		first_cp = false;
		patch1_p = static_cast<int>(patch(0, 0));
		patch2_p = static_cast<int>(patch(1, 0));
	}

	//Evaluates data and store in dataA and dataB
	surfA->patches[static_cast<int>(patch(0, 0))]->NURBSDerivatives(mc(0, 0), mc(1, 0), dataA, derivative_order);
	surfB->patches[static_cast<int>(patch(1, 0))]->NURBSDerivatives(mc(2, 0), mc(3, 0), dataB, derivative_order);

	//Copies data from dataA and dataB to AceGen input data pointers
	cAp[0] = mc(0, 0);
	cAp[1] = mc(1, 0);
	cBp[0] = mc(2, 0);
	cBp[1] = mc(3, 0);
	for (int i = 0; i < 3; i++)
	{
		GAp[i] = dataA[0][0](i, 0);
		dGAp[i][0] = dataA[1][0](i, 0);
		dGAp[i][1] = dataA[0][1](i, 0);
		ddGAp[i][0][0] = dataA[2][0](i, 0);
		ddGAp[i][0][1] = dataA[1][1](i, 0);
		ddGAp[i][1][0] = dataA[1][1](i, 0);
		ddGAp[i][1][1] = dataA[0][2](i, 0);
		dddGAp[i][0][0][0] = dataA[3][0](i, 0);
		dddGAp[i][0][0][1] = dataA[2][1](i, 0);
		dddGAp[i][0][1][0] = dataA[2][1](i, 0);
		dddGAp[i][0][1][1] = dataA[1][2](i, 0);
		dddGAp[i][1][0][0] = dataA[2][1](i, 0);
		dddGAp[i][1][0][1] = dataA[1][2](i, 0);
		dddGAp[i][1][1][0] = dataA[1][2](i, 0);
		dddGAp[i][1][1][1] = dataA[0][3](i, 0);

		GBp[i] = dataB[0][0](i, 0);
		dGBp[i][0] = dataB[1][0](i, 0);
		dGBp[i][1] = dataB[0][1](i, 0);
		ddGBp[i][0][0] = dataB[2][0](i, 0);
		ddGBp[i][0][1] = dataB[1][1](i, 0);
		ddGBp[i][1][0] = dataB[1][1](i, 0);
		ddGBp[i][1][1] = dataB[0][2](i, 0);
		dddGBp[i][0][0][0] = dataB[3][0](i, 0);
		dddGBp[i][0][0][1] = dataB[2][1](i, 0);
		dddGBp[i][0][1][0] = dataB[2][1](i, 0);
		dddGBp[i][0][1][1] = dataB[1][2](i, 0);
		dddGBp[i][1][0][0] = dataB[2][1](i, 0);
		dddGBp[i][1][0][1] = dataB[1][2](i, 0);
		dddGBp[i][1][1][0] = dataB[1][2](i, 0);
		dddGBp[i][1][1][1] = dataB[0][3](i, 0);
	}
}

void RigidNURBSSurface_RigidNURBSSurface::EvaluateNURBSDerivatives_i(Matrix & mc, Matrix & patch)
{
	if (mc == last_ci && first_ci == false && patch1_i == static_cast<int>(patch(0, 0)) && patch2_i == static_cast<int>(patch(1, 0)))
		return;
	else
	{
		last_ci = mc;
		first_ci = false;
		patch1_i = static_cast<int>(patch(0, 0));
		patch2_i = static_cast<int>(patch(1, 0));
	}

	//Evaluates data and store in dataA and dataB
	int d = 1;
	surfA->patches[static_cast<int>(patch(0, 0))]->NURBSDerivatives(mc(0, 0), mc(1, 0), dataA, d);
	surfB->patches[static_cast<int>(patch(1, 0))]->NURBSDerivatives(mc(2, 0), mc(3, 0), dataB, d);
	//Copies data from dataA and dataB to AceGen input data pointers
	cAi[0] = mc(0, 0);
	cAi[1] = mc(1, 0);
	cBi[0] = mc(2, 0);
	cBi[1] = mc(3, 0);
	for (int i = 0; i < 3; i++)
	{
		GAi[i] = dataA[0][0](i, 0);
		dGAi[i][0] = dataA[1][0](i, 0);
		dGAi[i][1] = dataA[0][1](i, 0);

		GBi[i] = dataB[0][0](i, 0);
		dGBi[i][0] = dataB[1][0](i, 0);
		dGBi[i][1] = dataB[0][1](i, 0);
	}
}

void RigidNURBSSurface_RigidNURBSSurface::EvaluateNURBSDOFsVariables()
{
	///////////////////////////////Ponteiros e variáveis para facilitar acesso//////////////////////////////////////////
	NURBSParticle* partA;		//Ponteiro para a partícula A
	NURBSParticle* partB;		//Ponteiro para a partícula B
	partA = static_cast<NURBSParticle*>(db.particles[index1]);
	partB = static_cast<NURBSParticle*>(db.particles[index2]);

	for (int i = 0; i < 3; i++)
	{
		xAi[i] = (*partA->x0i)(i, 0);
		xBi[i] = (*partB->x0i)(i, 0);

		uA[i] = db.nodes[partA->node - 1]->displacements[i];
		uB[i] = db.nodes[partB->node - 1]->displacements[i];

		alphaA[i] = db.nodes[partA->node - 1]->displacements[i + 3];
		alphaB[i] = db.nodes[partB->node - 1]->displacements[i + 3];


		duiA[i] = db.nodes[partA->node - 1]->copy_vel[i];
		duiB[i] = db.nodes[partB->node - 1]->copy_vel[i];
		dduiA[i] = db.nodes[partA->node - 1]->copy_accel[i];
		dduiB[i] = db.nodes[partB->node - 1]->copy_accel[i];
		dalphaiA[i] = db.nodes[partA->node - 1]->copy_vel[i + 3];
		dalphaiB[i] = db.nodes[partB->node - 1]->copy_vel[i + 3];
		ddalphaiA[i] = db.nodes[partA->node - 1]->copy_accel[i + 3];
		ddalphaiB[i] = db.nodes[partB->node - 1]->copy_accel[i + 3];


		for (int j = 0; j < 3; j++)
		{
			QAi[i][j] = (*partA->Qi)(i, j);
			QBi[i][j] = (*partB->Qi)(i, j);
		}
	}

	/*
	invertnormalA = &surfA->invert_normal;
	invertnormalB = &surfB->invert_normal;
	*/
}

bool RigidNURBSSurface_RigidNURBSSurface::SupportFunction(double rho, double phi, double & zetaA, double & thetaA, double & zetaB, double & thetaB, double * pA, double * pB, int & patchA, int & patchB, double & obj, bool & conv_sup)
{

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Degeneração
	int s_free = cd->P_0[0]->getColumns();
	int s_freeA = 0;
	int s_freeB = 0;
	for (int i = 0; i < s_free; i++)
	{
		if ((*cd->P_0[0])(0, i) == 1 || (*cd->P_0[0])(1, i) == 1) {
			s_freeA++;
		}
		if ((*cd->P_0[0])(2, i) == 1 || (*cd->P_0[0])(3, i) == 1) {
			s_freeB++;
		}
	}
	Matrix *P_0_A = new Matrix(2, s_freeA);
	for (int i = 0; i < s_freeA; i++)
	{
		(*P_0_A)(0, i) = (*cd->P_0[0])(0, i);
		(*P_0_A)(1, i) = (*cd->P_0[0])(1, i);
	}
	Matrix *P_0_B = new Matrix(2, s_freeB);
	for (int i = 0; i < s_freeB; i++)
	{
		(*P_0_B)(0, i) = (*cd->P_0[0])(2, i + s_freeA);
		(*P_0_B)(1, i) = (*cd->P_0[0])(3, i + s_freeA);
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Convergência da função de suporte
	conv_sup = false;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Variáveis para casos de mudança de patch
	int uv = 0;
	double tol = 0.0;
	double err = 0.0;
	bool convv = true;
	bool duoA = false;
	bool duoB = false;
	int patch_aux[2];
	int patch_duo[2];
	int patch_old[2];
	patch_aux[0] = 0;
	patch_aux[1] = 0;
	patch_duo[0] = 0;
	patch_duo[1] = 0;
	patch_old[0] = 0;
	patch_old[1] = 0;
	Matrix pointA(3); // Ponto no sistema local de coordenadas (superfície A)
	Matrix pointB(3); // Ponto no sistema local de coordenadas (superfície B)
	Matrix point_c(3); // Ponto no sistema local de coordenadas - conferência
	Matrix point_aux(3); // Ponto no sistema local de coordenadas - auxiliar

	double u = 0.0;
	double v = 0.0;
	double u_aux = 0.0;
	double v_aux = 0.0;
	
	double d = 0;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Superfície A

	// Direção de busca no sistema local de coordenadas
	double *dirA;
	dirA = new double[3];
	dirA[0] = inv_QAp(0, 0) * cos(rho) * sin(phi) + inv_QAp(0, 1) * sin(rho) * sin(phi) + inv_QAp(0, 2) * cos(phi);
	dirA[1] = inv_QAp(1, 0) * cos(rho) * sin(phi) + inv_QAp(1, 1) * sin(rho) * sin(phi) + inv_QAp(1, 2) * cos(phi);
	dirA[2] = inv_QAp(2, 0) * cos(rho) * sin(phi) + inv_QAp(2, 1) * sin(rho) * sin(phi) + inv_QAp(2, 2) * cos(phi);

	// Parâmetros
	double ufA = zetaA;
	double vfA = thetaA;

	double *p_fA;
	p_fA = new double[3];
	p_fA[0] = 0.0;
	p_fA[1] = 0.0;
	p_fA[2] = 0.0;

	bool convA = true;
	bool conv_totalA = true; // O processo de otimização chegou no final ou os parâmetros saíram do range durante o processo?

	double objective = 0.0;

	double delta = 0.0; // Para a otimização com trust region

	surfA->patches[patchA]->NURBSSupportFunction(dirA, ufA, vfA, p_fA, objective, convA, conv_totalA, delta, P_0_A);

	int iter = 1;

	while (conv_totalA == false && iter < 5 && s_freeA == 2) { // Troca de patches apenas para caso sem degeneração
		// Análise da superfície A
		if ((ufA < surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order]) || (ufA > surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_dim])) {
			if ((vfA < surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order]) || (vfA > surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_dim])) {
				duoA = true;
				if ((ufA < surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order])) {
					u = surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order];
					patch_aux[0] = (surfA->patches[patchA]->connectivity[0] - 1);
				}
				else {
					u = surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_dim];
					patch_aux[0] = (surfA->patches[patchA]->connectivity[1] - 1);
				}
				if ((vfA < surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order])) {
					v = surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order];
					patch_duo[0] = (surfA->patches[patchA]->connectivity[2] - 1);
				}
				else {
					v = surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_dim];
					patch_duo[0] = (surfA->patches[patchA]->connectivity[3] - 1);
				}
			}
			else {
				v = vfA;
				if ((ufA < surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order])) {
					u = surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_order];
					patch_aux[0] = (surfA->patches[patchA]->connectivity[0] - 1);
				}
				else {
					u = surfA->patches[patchA]->U_knot_vector[surfA->patches[patchA]->U_dim];
					patch_aux[0] = (surfA->patches[patchA]->connectivity[1] - 1);
				}
			}
			surfA->patches[patchA]->NURBSPoint(u, v, pointA);
			if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patchA) {
				uv = 0;
				u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
				v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
				{
					v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patchA) {
				uv = 0;
				u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
				v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
				{
					v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patchA) {
				uv = 1;
				v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
				u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
				{
					u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patchA) {
				uv = 1;
				v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
				u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
				surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
				{
					u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			ufA = u;
			vfA = v;
			patch_old[0] = patchA;
			patchA = patch_aux[0];
			surfA->patches[patch_aux[0]]->PointInversion(pointA, ufA, vfA, point_c, convv, tol, err, uv);
		}
		else {
			u = ufA;
			if ((vfA < surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order]) || (vfA > surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_dim])) {
				if ((vfA < surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order])) {
					v = surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_order];
					patch_aux[0] = (surfA->patches[patchA]->connectivity[2] - 1);
				}
				else {
					v = surfA->patches[patchA]->V_knot_vector[surfA->patches[patchA]->V_dim];
					patch_aux[0] = (surfA->patches[patchA]->connectivity[3] - 1);
				}
				surfA->patches[patchA]->NURBSPoint(u, v, pointA);
				if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patchA) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patchA) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patchA) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patchA) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointA(0, 0) - point_aux(0, 0))*(pointA(0, 0) - point_aux(0, 0)) + (pointA(1, 0) - point_aux(1, 0))*(pointA(1, 0) - point_aux(1, 0)) + (pointA(2, 0) - point_aux(2, 0))*(pointA(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				ufA = u;
				vfA = v;
				patch_old[0] = patchA;
				patchA = patch_aux[0];
				surfA->patches[patch_aux[0]]->PointInversion(pointA, ufA, vfA, point_c, convv, tol, err, uv);
			}
			else {
				v = vfA;
				patch_aux[0] = patchA;
				patch_old[0] = patchA;
			}
		}

		surfA->patches[patchA]->NURBSSupportFunction(dirA, ufA, vfA, p_fA, objective, convA, conv_totalA, delta, P_0_A);

		iter++;
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Superfície B 

	// Parâmetros
	double ufB = zetaB;
	double vfB = thetaB;

	double *p_fB;
	p_fB = new double[3];
	p_fB[0] = 0.0;
	p_fB[1] = 0.0;
	p_fB[2] = 0.0;

	// Direção de busca no sistema local de coordenadas
	double *dirB;
	dirB = new double[3];
	dirB[0] = -(inv_QBp(0, 0) * cos(rho) * sin(phi) + inv_QBp(0, 1) * sin(rho) * sin(phi) + inv_QBp(0, 2) * cos(phi));
	dirB[1] = -(inv_QBp(1, 0) * cos(rho) * sin(phi) + inv_QBp(1, 1) * sin(rho) * sin(phi) + inv_QBp(1, 2) * cos(phi));
	dirB[2] = -(inv_QBp(2, 0) * cos(rho) * sin(phi) + inv_QBp(2, 1) * sin(rho) * sin(phi) + inv_QBp(2, 2) * cos(phi));

	bool convB = true;
	bool conv_totalB = true; // O processo de otimização chegou no final ou os parâmetros saíram do range durante o processo?

	objective = 0.0; 

	delta = 0.0; // Para a otimização com trust region

	surfB->patches[patchB]->NURBSSupportFunction(dirB, ufB, vfB, p_fB, objective, convB, conv_totalB, delta, P_0_B);

	iter = 1;

	while (conv_totalB == false && iter < 5 && s_freeB == 2) {  // Troca de patches apenas para caso sem degeneração
		// Análise da superfície B
		if ((ufB < surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order]) || (ufB > surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_dim])) {
			if ((vfB < surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order]) || (vfB > surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_dim])) {
				duoB = true;
				if ((ufB < surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order])) {
					u = surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order];
					patch_aux[0] = (surfB->patches[patchB]->connectivity[0] - 1);
				}
				else {
					u = surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_dim];
					patch_aux[0] = (surfB->patches[patchB]->connectivity[1] - 1);
				}
				if ((vfB < surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order])) {
					v = surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order];
					patch_duo[0] = (surfB->patches[patchB]->connectivity[2] - 1);
				}
				else {
					v = surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_dim];
					patch_duo[0] = (surfB->patches[patchB]->connectivity[3] - 1);
				}
			}
			else {
				v = vfB;
				if ((ufB < surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order])) {
					u = surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_order];
					patch_aux[0] = (surfB->patches[patchB]->connectivity[0] - 1);
				}
				else {
					u = surfB->patches[patchB]->U_knot_vector[surfB->patches[patchB]->U_dim];
					patch_aux[0] = (surfB->patches[patchB]->connectivity[1] - 1);
				}
			}
			surfB->patches[patchB]->NURBSPoint(u, v, pointB);
			if ((surfB->patches[patch_aux[0]]->connectivity[0] - 1) == patchB) {
				uv = 0;
				u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_order];
				v = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
				surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
				{
					v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfB->patches[patch_aux[0]]->connectivity[1] - 1) == patchB) {
				uv = 0;
				u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_dim];
				v = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
				surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
				{
					v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						v = v_aux;
					}
				}
			}
			else if ((surfB->patches[patch_aux[0]]->connectivity[2] - 1) == patchB) {
				uv = 1;
				v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_order];
				u = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
				surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
				{
					u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			else if ((surfB->patches[patch_aux[0]]->connectivity[3] - 1) == patchB) {
				uv = 1;
				v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_dim];
				u = (surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
				surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
				d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
				for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
				{
					u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
					if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
						u = u_aux;
					}
				}
			}
			ufB = u;
			vfB = v;
			patch_old[0] = patchB;
			patchB = patch_aux[0];
			surfB->patches[patch_aux[0]]->PointInversion(pointB, ufB, vfB, point_c, convv, tol, err, uv);
		}
		else {
			u = ufB;
			if ((vfB < surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order]) || (vfB > surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_dim])) {
				if ((vfB < surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order])) {
					v = surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_order];
					patch_aux[0] = (surfB->patches[patchB]->connectivity[2] - 1);
				}
				else {
					v = surfB->patches[patchB]->V_knot_vector[surfB->patches[patchB]->V_dim];
					patch_aux[0] = (surfB->patches[patchB]->connectivity[3] - 1);
				}
				surfB->patches[patchB]->NURBSPoint(u, v, pointB);
				if ((surfB->patches[patch_aux[0]]->connectivity[0] - 1) == patchB) {
					uv = 0;
					u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_order];
					v = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[1] - 1) == patchB) {
					uv = 0;
					u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_dim];
					v = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[2] - 1) == patchB) {
					uv = 1;
					v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_order];
					u = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[3] - 1) == patchB) {
					uv = 1;
					v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_dim];
					u = (surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((pointB(0, 0) - point_aux(0, 0))*(pointB(0, 0) - point_aux(0, 0)) + (pointB(1, 0) - point_aux(1, 0))*(pointB(1, 0) - point_aux(1, 0)) + (pointB(2, 0) - point_aux(2, 0))*(pointB(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				ufB = u;
				vfB = v;
				patch_old[0] = patchB;
				patchB = patch_aux[0];
				surfB->patches[patch_aux[0]]->PointInversion(pointB, ufB, vfB, point_c, convv, tol, err, uv);
			}
			else {
				v = vfB;
				patch_aux[0] = patchB;
				patch_old[0] = patchB;
			}
		}

		surfB->patches[patchB]->NURBSSupportFunction(dirB, ufB, vfB, p_fB, objective, convB, conv_totalB, delta, P_0_B);

		iter++;
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Retorno da função
	if (convA && convB) {
		conv_sup = true;
	}

	if (convA == false || conv_totalA == false || convB == false || conv_totalB == false) {
		zetaA = ufA;
		thetaA = vfA;
		pA[0] = (*ptrQAp)(0, 0) * p_fA[0] + (*ptrQAp)(0, 1) * p_fA[1] + (*ptrQAp)(0, 2) * p_fA[2] + (*ptrx0Ap)(0, 0);
		pA[1] = (*ptrQAp)(1, 0) * p_fA[0] + (*ptrQAp)(1, 1) * p_fA[1] + (*ptrQAp)(1, 2) * p_fA[2] + (*ptrx0Ap)(1, 0);
		pA[2] = (*ptrQAp)(2, 0) * p_fA[0] + (*ptrQAp)(2, 1) * p_fA[1] + (*ptrQAp)(2, 2) * p_fA[2] + (*ptrx0Ap)(2, 0);
		zetaB = ufB;
		thetaB = vfB;
		pB[0] = (*ptrQBp)(0, 0) * p_fB[0] + (*ptrQBp)(0, 1) * p_fB[1] + (*ptrQBp)(0, 2) * p_fB[2] + (*ptrx0Bp)(0, 0);
		pB[1] = (*ptrQBp)(1, 0) * p_fB[0] + (*ptrQBp)(1, 1) * p_fB[1] + (*ptrQBp)(1, 2) * p_fB[2] + (*ptrx0Bp)(1, 0);
		pB[2] = (*ptrQBp)(2, 0) * p_fB[0] + (*ptrQBp)(2, 1) * p_fB[1] + (*ptrQBp)(2, 2) * p_fB[2] + (*ptrx0Bp)(2, 0);
		delete[]dirA;
		delete[]dirB;
		delete[]p_fA;
		delete[]p_fB;
		delete P_0_A;
		delete P_0_B;
		return false;
	}
	else {
		zetaA = ufA;
		thetaA = vfA;
		pA[0] = (*ptrQAp)(0, 0) * p_fA[0] + (*ptrQAp)(0, 1) * p_fA[1] + (*ptrQAp)(0, 2) * p_fA[2] + (*ptrx0Ap)(0, 0);
		pA[1] = (*ptrQAp)(1, 0) * p_fA[0] + (*ptrQAp)(1, 1) * p_fA[1] + (*ptrQAp)(1, 2) * p_fA[2] + (*ptrx0Ap)(1, 0);
		pA[2] = (*ptrQAp)(2, 0) * p_fA[0] + (*ptrQAp)(2, 1) * p_fA[1] + (*ptrQAp)(2, 2) * p_fA[2] + (*ptrx0Ap)(2, 0);
		zetaB = ufB;
		thetaB = vfB;
		pB[0] = (*ptrQBp)(0, 0) * p_fB[0] + (*ptrQBp)(0, 1) * p_fB[1] + (*ptrQBp)(0, 2) * p_fB[2] + (*ptrx0Bp)(0, 0);
		pB[1] = (*ptrQBp)(1, 0) * p_fB[0] + (*ptrQBp)(1, 1) * p_fB[1] + (*ptrQBp)(1, 2) * p_fB[2] + (*ptrx0Bp)(1, 0);
		pB[2] = (*ptrQBp)(2, 0) * p_fB[0] + (*ptrQBp)(2, 1) * p_fB[1] + (*ptrQBp)(2, 2) * p_fB[2] + (*ptrx0Bp)(2, 0);

		obj = pow((pA[0] - pB[0]), 2) + pow((pA[1] - pB[1]), 2) + pow((pA[2] - pB[2]), 2);

		delete[]dirA;
		delete[]dirB;
		delete[]p_fA;
		delete[]p_fB;
		delete P_0_A;
		delete P_0_B;
	}

	return true;
}

bool RigidNURBSSurface_RigidNURBSSurface::SupportFunction(double rho, double phi, double & zeta, double & theta, double * p, int & patch, bool & conv_sup, int surf, bool &conv_total)
{
	/*-----------------------------------------------------------------------------------------------------------------*/
	// Degeneração
	int s_free = cd->P_0[0]->getColumns();
	int s_freeA = 0;
	int s_freeB = 0;
	for (int i = 0; i < s_free; i++)
	{
		if ((*cd->P_0[0])(0, i) == 1 || (*cd->P_0[0])(1, i) == 1) {
			s_freeA++;
		}
		if ((*cd->P_0[0])(2, i) == 1 || (*cd->P_0[0])(3, i) == 1) {
			s_freeB++;
		}
	}
	Matrix *P_0_A = new Matrix(2, s_freeA);
	for (int i = 0; i < s_freeA; i++)
	{
		(*P_0_A)(0, i) = (*cd->P_0[0])(0, i);
		(*P_0_A)(1, i) = (*cd->P_0[0])(1, i);
	}
	Matrix *P_0_B = new Matrix(2, s_freeB);
	for (int i = 0; i < s_freeB; i++)
	{
		(*P_0_B)(0, i) = (*cd->P_0[0])(2, i + s_freeA);
		(*P_0_B)(1, i) = (*cd->P_0[0])(3, i + s_freeA);
	}
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Convergência da função de suporte
	conv_sup = false;
	conv_total = true;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Variáveis para casos de mudança de patch
	int uv = 0;
	double tol = 0.0;
	double err = 0.0;
	bool convv = true;
	bool duoA = false;
	bool duoB = false;
	int patch_aux[2];
	int patch_duo[2];
	int patch_old[2];
	patch_aux[0] = 0;
	patch_aux[1] = 0;
	patch_duo[0] = 0;
	patch_duo[1] = 0;
	patch_old[0] = 0;
	patch_old[1] = 0;
	Matrix point(3); // Ponto no sistema local de coordenadas (superfície A)
	Matrix point_c(3); // Ponto no sistema local de coordenadas - conferência
	Matrix point_aux(3); // Ponto no sistema local de coordenadas - auxiliar

	double u = 0.0;
	double v = 0.0;
	double u_aux = 0.0;
	double v_aux = 0.0;

	double d = 0;
	/*-----------------------------------------------------------------------------------------------------------------*/

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Direção de busca no sistema local de coordenadas
	double *dir;
	dir = new double[3];
	if (surf == 0) {
		dir[0] = inv_QAp(0, 0) * cos(rho) * sin(phi) + inv_QAp(0, 1) * sin(rho) * sin(phi) + inv_QAp(0, 2) * cos(phi);
		dir[1] = inv_QAp(1, 0) * cos(rho) * sin(phi) + inv_QAp(1, 1) * sin(rho) * sin(phi) + inv_QAp(1, 2) * cos(phi);
		dir[2] = inv_QAp(2, 0) * cos(rho) * sin(phi) + inv_QAp(2, 1) * sin(rho) * sin(phi) + inv_QAp(2, 2) * cos(phi);
	}
	else {
		dir[0] = (inv_QBp(0, 0) * cos(rho) * sin(phi) + inv_QBp(0, 1) * sin(rho) * sin(phi) + inv_QBp(0, 2) * cos(phi));
		dir[1] = (inv_QBp(1, 0) * cos(rho) * sin(phi) + inv_QBp(1, 1) * sin(rho) * sin(phi) + inv_QBp(1, 2) * cos(phi));
		dir[2] = (inv_QBp(2, 0) * cos(rho) * sin(phi) + inv_QBp(2, 1) * sin(rho) * sin(phi) + inv_QBp(2, 2) * cos(phi));
	}
	
	// Parâmetros
	double uf = zeta;
	double vf = theta;

	double *p_f;
	p_f = new double[3];
	p_f[0] = 0.0;
	p_f[1] = 0.0;
	p_f[2] = 0.0;

	bool conv = true;

	double objective = 0.0;

	double delta = 0.0; // Para a otimização com trust region

	if (surf == 0) {
		surfA->patches[patch]->NURBSSupportFunction(dir, uf, vf, p_f, objective, conv, conv_total, delta, P_0_A);
	}
	else {
		surfB->patches[patch]->NURBSSupportFunction(dir, uf, vf, p_f, objective, conv, conv_total, delta, P_0_B);
	}

	int iter = 1;

	if (surf == 0) {
		while (conv_total == false && iter < 5 && s_freeA == 2) { // Troca de patches apenas para caso sem degeneração
			// Análise da superfície A
			if ((uf < surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order]) || (uf > surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_dim])) {
				if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order]) || (vf > surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim])) {
					duoA = true;
					if ((uf < surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order])) {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order];
						patch_aux[0] = (surfA->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_dim];
						patch_aux[0] = (surfA->patches[patch]->connectivity[1] - 1);
					}
					if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order])) {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order];
						patch_duo[0] = (surfA->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim];
						patch_duo[0] = (surfA->patches[patch]->connectivity[3] - 1);
					}
				}
				else {
					v = vf;
					if ((uf < surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order])) {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_order];
						patch_aux[0] = (surfA->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfA->patches[patch]->U_knot_vector[surfA->patches[patch]->U_dim];
						patch_aux[0] = (surfA->patches[patch]->connectivity[1] - 1);
					}
				}
				surfA->patches[patch]->NURBSPoint(u, v, point);
				if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
					uv = 0;
					u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
					v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
					uv = 1;
					v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
					u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				uf = u;
				vf = v;
				patch_old[0] = patch;
				patch = patch_aux[0];
				surfA->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
			}
			else {
				u = uf;
				if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order]) || (vf > surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim])) {
					if ((vf < surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order])) {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_order];
						patch_aux[0] = (surfA->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfA->patches[patch]->V_knot_vector[surfA->patches[patch]->V_dim];
						patch_aux[0] = (surfA->patches[patch]->connectivity[3] - 1);
					}
					surfA->patches[patch]->NURBSPoint(u, v, point);
					if ((surfA->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
						uv = 0;
						u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_order];
						v = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfA->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
						uv = 0;
						u = surfA->patches[patch_aux[0]]->U_knot_vector[surfA->patches[patch_aux[0]]->U_dim];
						v = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfA->patches[patch_aux[0]]->parameter_sub[surfA->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfA->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
						uv = 1;
						v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_order];
						u = (surfA->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					else if ((surfA->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
						uv = 1;
						v = surfA->patches[patch_aux[0]]->V_knot_vector[surfA->patches[patch_aux[0]]->V_dim];
						u = (surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[0][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfA->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfA->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfA->patches[patch_aux[0]]->parameter_sub[j][surfA->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
							surfA->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					uf = u;
					vf = v;
					patch_old[0] = patch;
					patch = patch_aux[0];
					surfA->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
				}
				else {
					v = vf;
					patch_aux[0] = patch;
					patch_old[0] = patch;
				}
			}

			surfA->patches[patch]->NURBSSupportFunction(dir, uf, vf, p_f, objective, conv, conv_total, delta, P_0_A);

			iter++;
		}
	}
	else {
		while (conv_total == false && iter < 5 && s_freeB == 2) { // Troca de patches apenas para caso sem degeneração
			// Análise da superfície B
			if ((uf < surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order]) || (uf > surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_dim])) {
				if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order]) || (vf > surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim])) {
					duoA = true;
					if ((uf < surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order])) {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order];
						patch_aux[0] = (surfB->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_dim];
						patch_aux[0] = (surfB->patches[patch]->connectivity[1] - 1);
					}
					if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order])) {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order];
						patch_duo[0] = (surfB->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim];
						patch_duo[0] = (surfB->patches[patch]->connectivity[3] - 1);
					}
				}
				else {
					v = vf;
					if ((uf < surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order])) {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_order];
						patch_aux[0] = (surfB->patches[patch]->connectivity[0] - 1);
					}
					else {
						u = surfB->patches[patch]->U_knot_vector[surfB->patches[patch]->U_dim];
						patch_aux[0] = (surfB->patches[patch]->connectivity[1] - 1);
					}
				}
				surfB->patches[patch]->NURBSPoint(u, v, point);
				if ((surfB->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
					uv = 0;
					u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_order];
					v = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
					uv = 0;
					u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_dim];
					v = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
					{
						v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							v = v_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
					uv = 1;
					v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_order];
					u = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				else if ((surfB->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
					uv = 1;
					v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_dim];
					u = (surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
					surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
					d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
					for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
					{
						u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
						if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
							u = u_aux;
						}
					}
				}
				uf = u;
				vf = v;
				patch_old[0] = patch;
				patch = patch_aux[0];
				surfB->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
			}
			else {
				u = uf;
				if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order]) || (vf > surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim])) {
					if ((vf < surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order])) {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_order];
						patch_aux[0] = (surfB->patches[patch]->connectivity[2] - 1);
					}
					else {
						v = surfB->patches[patch]->V_knot_vector[surfB->patches[patch]->V_dim];
						patch_aux[0] = (surfB->patches[patch]->connectivity[3] - 1);
					}
					surfB->patches[patch]->NURBSPoint(u, v, point);
					if ((surfB->patches[patch_aux[0]]->connectivity[0] - 1) == patch) {
						uv = 0;
						u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_order];
						v = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[0][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[0][j][4]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfB->patches[patch_aux[0]]->connectivity[1] - 1) == patch) {
						uv = 0;
						u = surfB->patches[patch_aux[0]]->U_knot_vector[surfB->patches[patch_aux[0]]->U_dim];
						v = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][0][4]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[1]; j++)
						{
							v_aux = (surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][3] + surfB->patches[patch_aux[0]]->parameter_sub[surfB->patches[patch_aux[0]]->subdivisions[0] - 1][j][4]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u, v_aux, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								v = v_aux;
							}
						}
					}
					else if ((surfB->patches[patch_aux[0]]->connectivity[2] - 1) == patch) {
						uv = 1;
						v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_order];
						u = (surfB->patches[patch_aux[0]]->parameter_sub[0][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][0][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][0][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][0][1]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					else if ((surfB->patches[patch_aux[0]]->connectivity[3] - 1) == patch) {
						uv = 1;
						v = surfB->patches[patch_aux[0]]->V_knot_vector[surfB->patches[patch_aux[0]]->V_dim];
						u = (surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[0][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
						surfB->patches[patch_aux[0]]->NURBSPoint(u, v, point_aux);
						d = sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)));
						for (int j = 1; j < surfB->patches[patch_aux[0]]->subdivisions[0]; j++)
						{
							u_aux = (surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][0] + surfB->patches[patch_aux[0]]->parameter_sub[j][surfB->patches[patch_aux[0]]->subdivisions[1] - 1][1]) / 2;
							surfB->patches[patch_aux[0]]->NURBSPoint(u_aux, v, point_aux);
							if ((sqrt((point(0, 0) - point_aux(0, 0))*(point(0, 0) - point_aux(0, 0)) + (point(1, 0) - point_aux(1, 0))*(point(1, 0) - point_aux(1, 0)) + (point(2, 0) - point_aux(2, 0))*(point(2, 0) - point_aux(2, 0)))) < d) {
								u = u_aux;
							}
						}
					}
					uf = u;
					vf = v;
					patch_old[0] = patch;
					patch = patch_aux[0];
					surfB->patches[patch_aux[0]]->PointInversion(point, uf, vf, point_c, convv, tol, err, uv);
				}
				else {
					v = vf;
					patch_aux[0] = patch;
					patch_old[0] = patch;
				}
			}

			surfB->patches[patch]->NURBSSupportFunction(dir, uf, vf, p_f, objective, conv, conv_total, delta, P_0_B);

			iter++;
		}
	}

	conv_sup = conv;

	/*-----------------------------------------------------------------------------------------------------------------*/
	// Retorno da função
	if (conv == false || conv_total == false) {
		zeta = uf;
		theta = vf;
		if (surf == 0) {
			p[0] = (*ptrQAp)(0, 0) * p_f[0] + (*ptrQAp)(0, 1) * p_f[1] + (*ptrQAp)(0, 2) * p_f[2] + (*ptrx0Ap)(0, 0);
			p[1] = (*ptrQAp)(1, 0) * p_f[0] + (*ptrQAp)(1, 1) * p_f[1] + (*ptrQAp)(1, 2) * p_f[2] + (*ptrx0Ap)(1, 0);
			p[2] = (*ptrQAp)(2, 0) * p_f[0] + (*ptrQAp)(2, 1) * p_f[1] + (*ptrQAp)(2, 2) * p_f[2] + (*ptrx0Ap)(2, 0);
		}
		else {
			p[0] = (*ptrQBp)(0, 0) * p_f[0] + (*ptrQBp)(0, 1) * p_f[1] + (*ptrQBp)(0, 2) * p_f[2] + (*ptrx0Bp)(0, 0);
			p[1] = (*ptrQBp)(1, 0) * p_f[0] + (*ptrQBp)(1, 1) * p_f[1] + (*ptrQBp)(1, 2) * p_f[2] + (*ptrx0Bp)(1, 0);
			p[2] = (*ptrQBp)(2, 0) * p_f[0] + (*ptrQBp)(2, 1) * p_f[1] + (*ptrQBp)(2, 2) * p_f[2] + (*ptrx0Bp)(2, 0);
		}
		delete[]dir;
		delete[]p_f;
		delete P_0_A;
		delete P_0_B;
		return false;
	}
	else {
		zeta = uf;
		theta = vf;
		if (surf == 0) {
			p[0] = (*ptrQAp)(0, 0) * p_f[0] + (*ptrQAp)(0, 1) * p_f[1] + (*ptrQAp)(0, 2) * p_f[2] + (*ptrx0Ap)(0, 0);
			p[1] = (*ptrQAp)(1, 0) * p_f[0] + (*ptrQAp)(1, 1) * p_f[1] + (*ptrQAp)(1, 2) * p_f[2] + (*ptrx0Ap)(1, 0);
			p[2] = (*ptrQAp)(2, 0) * p_f[0] + (*ptrQAp)(2, 1) * p_f[1] + (*ptrQAp)(2, 2) * p_f[2] + (*ptrx0Ap)(2, 0);
		}
		else {
			p[0] = (*ptrQBp)(0, 0) * p_f[0] + (*ptrQBp)(0, 1) * p_f[1] + (*ptrQBp)(0, 2) * p_f[2] + (*ptrx0Bp)(0, 0);
			p[1] = (*ptrQBp)(1, 0) * p_f[0] + (*ptrQBp)(1, 1) * p_f[1] + (*ptrQBp)(1, 2) * p_f[2] + (*ptrx0Bp)(1, 0);
			p[2] = (*ptrQBp)(2, 0) * p_f[0] + (*ptrQBp)(2, 1) * p_f[1] + (*ptrQBp)(2, 2) * p_f[2] + (*ptrx0Bp)(2, 0);
		}
		delete[]dir;
		delete[]p_f;
		delete P_0_A;
		delete P_0_B;
	}

	return true;
}

void RigidNURBSSurface_RigidNURBSSurface::SurfacePointsTemp()
{
	double z;
	double th;

	//Gamma A
	z = (*cNR2[/*i*/0])(0, 0);
	th = (*cNR2[/*i*/0])(1, 0);
	surfA->patches[(*patches2[/*i*/0])(0, 0)]->SurfacePoint(ptrQAp, ptrx0Ap, z, th, *GammaA);

	//Gamma B
	z = (*cNR2[/*i*/0])(2, 0);
	th = (*cNR2[/*i*/0])(3, 0);
	surfB->patches[(*patches2[/*i*/0])(1, 0)]->SurfacePoint(ptrQBp, ptrx0Bp, z, th, *GammaB);
}
